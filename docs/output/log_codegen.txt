

=== INICIANDO GERAÇÃO DE ASSEMBLY ===

--- Passagem 1A: Coletando definições de funções ---
[Passagem 1A] Função encontrada: 'count'
[ALLOC_INIT] Inicializando alocador para a função 'count'
[ALLOC_INIT] Pool de registradores definido: ['r12', 'r13', 'r14', 'r15', 'r16', 'r17', 'r18', 'r19', 'r20', 'r21', 'r22', 'r23', 'r24', 'r25', 'r26', 'r4', 'r5', 'r6', 'r7', 'r8', 'r9', 'r10', 'r11']
[ALLOC_INIT] Registrador de spill reservado: r30
[ALLOC_INIT] Estado inicial: 23 registradores livres.
[FUNC_CTX] Contexto para a função 'count' criado.
[Passagem 1A] Função encontrada: 'main'
[ALLOC_INIT] Inicializando alocador para a função 'main'
[ALLOC_INIT] Pool de registradores definido: ['r12', 'r13', 'r14', 'r15', 'r16', 'r17', 'r18', 'r19', 'r20', 'r21', 'r22', 'r23', 'r24', 'r25', 'r26', 'r4', 'r5', 'r6', 'r7', 'r8', 'r9', 'r10', 'r11']
[ALLOC_INIT] Registrador de spill reservado: r30
[ALLOC_INIT] Estado inicial: 23 registradores livres.
[FUNC_CTX] Contexto para a função 'main' criado.

--- Passagem 1B: Descobrindo parâmetros de cada função ---
-> Função 'count' tem os parâmetros: ['number']
-> Função 'main' tem os parâmetros: []

--- Passagem 1C: Coletando variáveis GLOBAIS do IR ---
[Passagem 1C] Variável global encontrada: 'x'
--- Fim da Passagem 1: 2 funções, 1 params, e 1 globais encontradas. ---

--- Passagem 2: Traduzindo o IR para cada função ---

[Processando Função] -> 'count'
-> IR isolado para 'count' contém 15 instruções.
--> Tamanho total do frame para 'count': 6 palavras.
--> Gerando código para salvar parâmetros de 'count' na pilha.
[ADD_INSTR] Adicionando instrução para 'count': subi: r30 = r31, 1
[ADD_INSTR] Adicionando instrução para 'count': store: [r30] = r1
--> Pseudo-instrução para salvar 'number' expandida.

--- [TRANSLATE] Processando IR: t0 := *number ---
[TRANSLATE] -> Detalhes: Destino='t0', Expressão='*number'
[TRANSLATE] -> Caminho: Carregar de Ponteiro (*)
[ENSURE] Tentando garantir 'number' em um registrador.
[ENSURE] -> 'number' é um parâmetro. Carregando da pilha.
[GET_FREE] -> Encontrado registrador livre: r12. Restantes: 22.
[ADD_INSTR] Adicionando instrução para 'count': subi: r30 = r31, 1
[ADD_INSTR] Adicionando instrução para 'count': load: r12 = [r30]
--> Pseudo-instrução para carregar 'number' expandida.
[ASSIGN_REG] Mapeando 'number' para r12.
[UPDATE_MAP] Mapeando 't0' para o registrador r12 (que contém o valor de origem).
[ASSIGN_REG] Mapeando 't0' para r12.
[ASSIGN_REG] -> Registrador r12 já continha 'number'. Liberando o mapeamento antigo.
[UNASSIGN_REG] Desmapeado r12 de 'number'.
[UNASSIGN_REG] -> Estado atual: 23 registradores livres. Mapeamentos: {}
[TRANSLATE] -> Valor de 'number' agora em r12, mapeado para 't0'.

--- [TRANSLATE] Processando IR: arg t0 ---
[TRANSLATE] -> Caminho: Passagem de Argumento (arg 1)
[ENSURE] Tentando garantir 't0' em um registrador.
[ENSURE] -> Sucesso! 't0' já está em r12.
[ADD_INSTR] Adicionando instrução para 'count': mov: r1 = r12

--- [TRANSLATE] Processando IR: call output, 1 ---
[TRANSLATE] -> Caminho: Chamada de Procedimento
[SPILL_ALL] Verificando registradores sujos para salvar antes da chamada de função. Sujos: set()
[ADD_INSTR] Adicionando instrução para 'count': out: r1
[UNASSIGN_REG] Desmapeado r12 de 't0'.
[UNASSIGN_REG] -> Estado atual: 23 registradores livres. Mapeamentos: {}

--- [TRANSLATE] Processando IR: t1 := *number ---
[TRANSLATE] -> Detalhes: Destino='t1', Expressão='*number'
[TRANSLATE] -> Caminho: Carregar de Ponteiro (*)
[ENSURE] Tentando garantir 'number' em um registrador.
[ENSURE] -> 'number' é um parâmetro. Carregando da pilha.
[GET_FREE] -> Encontrado registrador livre: r13. Restantes: 22.
[ADD_INSTR] Adicionando instrução para 'count': subi: r30 = r31, 1
[ADD_INSTR] Adicionando instrução para 'count': load: r13 = [r30]
--> Pseudo-instrução para carregar 'number' expandida.
[ASSIGN_REG] Mapeando 'number' para r13.
[UPDATE_MAP] Mapeando 't1' para o registrador r13 (que contém o valor de origem).
[ASSIGN_REG] Mapeando 't1' para r13.
[ASSIGN_REG] -> Registrador r13 já continha 'number'. Liberando o mapeamento antigo.
[UNASSIGN_REG] Desmapeado r13 de 'number'.
[UNASSIGN_REG] -> Estado atual: 23 registradores livres. Mapeamentos: {}
[TRANSLATE] -> Valor de 'number' agora em r13, mapeado para 't1'.

--- [TRANSLATE] Processando IR: t2 := t1 == 0 ---
[TRANSLATE] -> Detalhes: Destino='t2', Expressão='t1 == 0'
[TRANSLATE] -> Caminho: Comparação (condicional)
[ENSURE] Tentando garantir 't1' em um registrador.
[ENSURE] -> Sucesso! 't1' já está em r13.
[ENSURE] Tentando garantir '0' em um registrador.
[GET_FREE] -> Encontrado registrador livre: r14. Restantes: 22.
[ENSURE] -> Alocando r14 para a constante '0'.
[ADD_INSTR] Adicionando instrução para 'count': movi: r14 = 0
[ADD_INSTR] Adicionando instrução para 'count': subs: r0 = r13, r14

--- [TRANSLATE] Processando IR: if_false t2 goto L0 ---
[TRANSLATE] -> Caminho: Desvio Condicional (if_false)
[ADD_INSTR] Adicionando instrução para 'count': bineq: L0

--- [TRANSLATE] Processando IR: return _ ---
[TRANSLATE] -> Caminho: Retorno de Função
[SPILL_ALL] Verificando registradores sujos para salvar antes da chamada de função. Sujos: set()
[ADD_INSTR] Adicionando instrução para 'count': bi: count_epilogue

--- [TRANSLATE] Processando IR: goto L1 ---
[TRANSLATE] -> Desvio incondicional detectado: L1
[SPILL_ALL] Verificando registradores sujos para salvar antes da chamada de função. Sujos: set()
[ADD_INSTR] Adicionando instrução para 'count': bi: L1

--- [TRANSLATE] Processando IR: L0: ---
[TRANSLATE] -> Rótulo detectado: L0:
[SPILL_ALL] Verificando registradores sujos para salvar antes da chamada de função. Sujos: set()
[ADD_INSTR] Adicionando instrução para 'count': L0:

--- [TRANSLATE] Processando IR: L1: ---
[TRANSLATE] -> Rótulo detectado: L1:
[SPILL_ALL] Verificando registradores sujos para salvar antes da chamada de função. Sujos: set()
[ADD_INSTR] Adicionando instrução para 'count': L1:

--- [TRANSLATE] Processando IR: t3 := *number ---
[TRANSLATE] -> Detalhes: Destino='t3', Expressão='*number'
[TRANSLATE] -> Caminho: Carregar de Ponteiro (*)
[ENSURE] Tentando garantir 'number' em um registrador.
[ENSURE] -> 'number' é um parâmetro. Carregando da pilha.
[GET_FREE] -> Encontrado registrador livre: r15. Restantes: 21.
[ADD_INSTR] Adicionando instrução para 'count': subi: r30 = r31, 1
[ADD_INSTR] Adicionando instrução para 'count': load: r15 = [r30]
--> Pseudo-instrução para carregar 'number' expandida.
[ASSIGN_REG] Mapeando 'number' para r15.
[UPDATE_MAP] Mapeando 't3' para o registrador r15 (que contém o valor de origem).
[ASSIGN_REG] Mapeando 't3' para r15.
[ASSIGN_REG] -> Registrador r15 já continha 'number'. Liberando o mapeamento antigo.
[UNASSIGN_REG] Desmapeado r15 de 'number'.
[UNASSIGN_REG] -> Estado atual: 22 registradores livres. Mapeamentos: {'t1': 'r13'}
[TRANSLATE] -> Valor de 'number' agora em r15, mapeado para 't3'.

--- [TRANSLATE] Processando IR: t4 := t3 - 1 ---
[TRANSLATE] -> Detalhes: Destino='t4', Expressão='t3 - 1'
[TRANSLATE] -> Caminho: Operação Aritmética
[ENSURE] Tentando garantir 't3' em um registrador.
[ENSURE] -> Sucesso! 't3' já está em r15.
[TRANSLATE] -> Operando 2 é um imediato: 1
[GET_TEMP] Solicitando registrador para o temporário 't4'.
[GET_FREE] -> Encontrado registrador livre: r16. Restantes: 21.
[ASSIGN_REG] Mapeando 't4' para r16.
[GET_TEMP] -> 't4' alocado no registrador r16.
[ADD_INSTR] Adicionando instrução para 'count': subi: r16 = r15, 1

--- [TRANSLATE] Processando IR: arg t4 ---
[TRANSLATE] -> Caminho: Passagem de Argumento (arg 1)
[ENSURE] Tentando garantir 't4' em um registrador.
[ENSURE] -> Sucesso! 't4' já está em r16.
[ADD_INSTR] Adicionando instrução para 'count': mov: r1 = r16

--- [TRANSLATE] Processando IR: call count, 1 ---
[TRANSLATE] -> Caminho: Chamada de Procedimento
[SPILL_ALL] Verificando registradores sujos para salvar antes da chamada de função. Sujos: {'r16'}
[ADD_INSTR] Adicionando instrução para 'count': movi: r28 = count_Lret0
[ADD_INSTR] Adicionando instrução para 'count': bl: count
[ADD_INSTR] Adicionando instrução para 'count': count_Lret0:
[UNASSIGN_REG] Desmapeado r16 de 't4'.
[UNASSIGN_REG] -> Estado atual: 22 registradores livres. Mapeamentos: {'t1': 'r13', 't3': 'r15'}

--- [TRANSLATE] Processando IR: return _ ---
[TRANSLATE] -> Caminho: Retorno de Função
[SPILL_ALL] Verificando registradores sujos para salvar antes da chamada de função. Sujos: set()
[ADD_INSTR] Adicionando instrução para 'count': bi: count_epilogue
-> Finalizando a função 'count', fazendo spill de todos os registradores sujos.
[SPILL_ALL] Verificando registradores sujos para salvar antes da chamada de função. Sujos: set()

[Processando Função] -> 'main'
-> IR isolado para 'main' contém 6 instruções.
--> Tamanho total do frame para 'main': 2 palavras.
--> Gerando código para salvar parâmetros de 'main' na pilha.

--- [TRANSLATE] Processando IR: t5 := call input, 0 ---
[TRANSLATE] -> Detalhes: Destino='t5', Expressão='call input, 0'
[TRANSLATE] -> Caminho: Chamada de Função com Retorno
[SPILL_ALL] Verificando registradores sujos para salvar antes da chamada de função. Sujos: set()
[GET_TEMP] Solicitando registrador para o temporário 't5'.
[GET_FREE] -> Encontrado registrador livre: r12. Restantes: 22.
[ASSIGN_REG] Mapeando 't5' para r12.
[GET_TEMP] -> 't5' alocado no registrador r12.
[ADD_INSTR] Adicionando instrução para 'main': in: r12

--- [TRANSLATE] Processando IR: *x := t5 ---
[TRANSLATE] -> Detalhes: Destino='*x', Expressão='t5'
[TRANSLATE] -> Caminho: Armazenar em Ponteiro (*)
[ENSURE] Tentando garantir 't5' em um registrador.
[ENSURE] -> Sucesso! 't5' já está em r12.
[TRANSLATE] -> Endereço de destino é uma variável real. Obtendo endereço em registrador.
[GET_ADDR] Obtendo endereço para 'x'.
[GET_FREE] -> Encontrado registrador livre: r13. Restantes: 21.
[ADD_INSTR] Adicionando instrução para 'main': movi: r13 = 128
[GET_ADDR] -> Endereço de 'x' (128) carregado em r13.
[ADD_INSTR] Adicionando instrução para 'main': store: [r13] = r12
[FREE_TEMP] Liberando registrador r12 que continha o temporário 't5'.
[UNASSIGN_REG] Desmapeado r12 de 't5'.
[UNASSIGN_REG] -> Estado atual: 22 registradores livres. Mapeamentos: {}
[UNASSIGN_REG] r13 já estava desmapeado.
[UNASSIGN_REG] -> Estado atual: 23 registradores livres. Mapeamentos: {}

--- [TRANSLATE] Processando IR: t6 := *x ---
[TRANSLATE] -> Detalhes: Destino='t6', Expressão='*x'
[TRANSLATE] -> Caminho: Carregar de Ponteiro (*)
[ENSURE] Tentando garantir 'x' em um registrador.
[ENSURE] -> Variável 'x' não está em um registrador. Carregando da memória.
[GET_FREE] -> Encontrado registrador livre: r14. Restantes: 22.
[GET_FREE] -> Encontrado registrador livre: r15. Restantes: 21.
[ADD_INSTR] Adicionando instrução para 'main': movi: r15 = 128
[ENSURE] -> Usando r14 para o valor e r15 para o endereço 128.
[ADD_INSTR] Adicionando instrução para 'main': load: r14 = [r15]
[ASSIGN_REG] Mapeando 'x' para r14.
[UNASSIGN_REG] r15 já estava desmapeado.
[UNASSIGN_REG] -> Estado atual: 22 registradores livres. Mapeamentos: {'x': 'r14'}
[UPDATE_MAP] Mapeando 't6' para o registrador r14 (que contém o valor de origem).
[ASSIGN_REG] Mapeando 't6' para r14.
[ASSIGN_REG] -> Registrador r14 já continha 'x'. Liberando o mapeamento antigo.
[UNASSIGN_REG] Desmapeado r14 de 'x'.
[UNASSIGN_REG] -> Estado atual: 23 registradores livres. Mapeamentos: {}
[TRANSLATE] -> Valor de 'x' agora em r14, mapeado para 't6'.

--- [TRANSLATE] Processando IR: arg t6 ---
[TRANSLATE] -> Caminho: Passagem de Argumento (arg 1)
[ENSURE] Tentando garantir 't6' em um registrador.
[ENSURE] -> Sucesso! 't6' já está em r14.
[ADD_INSTR] Adicionando instrução para 'main': mov: r1 = r14

--- [TRANSLATE] Processando IR: call count, 1 ---
[TRANSLATE] -> Caminho: Chamada de Procedimento
[SPILL_ALL] Verificando registradores sujos para salvar antes da chamada de função. Sujos: {'r12'}
[ADD_INSTR] Adicionando instrução para 'main': movi: r28 = main_Lret0
[ADD_INSTR] Adicionando instrução para 'main': bl: count
[ADD_INSTR] Adicionando instrução para 'main': main_Lret0:
[UNASSIGN_REG] Desmapeado r14 de 't6'.
[UNASSIGN_REG] -> Estado atual: 23 registradores livres. Mapeamentos: {}

--- [TRANSLATE] Processando IR: return _ ---
[TRANSLATE] -> Caminho: Retorno de Função
[SPILL_ALL] Verificando registradores sujos para salvar antes da chamada de função. Sujos: {'r12'}
[ADD_INSTR] Adicionando instrução para 'main': bi: main_epilogue
-> Finalizando a função 'main', fazendo spill de todos os registradores sujos.
[SPILL_ALL] Verificando registradores sujos para salvar antes da chamada de função. Sujos: {'r12'}
--- Fim da Passagem 2 ---

--- Montagem Final: Construindo o arquivo assembly completo ---
[Montagem] Processando função 'count' com 23 instruções.
[Montagem] Processando função 'main' com 10 instruções.
[Montagem] Adicionando a seção .data.
[Montagem] -> Variáveis a serem declaradas: ['x']
=== GERAÇÃO DE ASSEMBLY CONCLUÍDA ===
--- ASSEMBLY CODE READY FOR YOUR ASSEMBLER ---
.text
.global main

	bi: main
count:
	subi: r29 = r29, 1
	store: [r29] = r28
	subi: r29 = r29, 1
	store: [r29] = r31
	mov: r31 = r29
	subi: r29 = r29, 6
	subi: r30 = r31, 1
	store: [r30] = r1
	subi: r30 = r31, 1
	load: r12 = [r30]
	mov: r1 = r12
	out: r1
	subi: r30 = r31, 1
	load: r13 = [r30]
	movi: r14 = 0
	subs: r0 = r13, r14
	bineq: L0
	bi: count_epilogue
	bi: L1
L0:
L1:
	subi: r30 = r31, 1
	load: r15 = [r30]
	subi: r16 = r15, 1
	mov: r1 = r16
	movi: r28 = count_Lret0
	bl: count
count_Lret0:
	bi: count_epilogue
count_epilogue:
	mov: r29 = r31
	load: r31 = [r29]
	addi: r29 = r29, 1
	load: r28 = [r29]
	addi: r29 = r29, 1
	b: r28

main:
	movi: r29 = stack_space
	mov: r31 = r29
	subi: r29 = r29, 2
	in: r12
	movi: r13 = 128
	store: [r13] = r12
	movi: r15 = 128
	load: r14 = [r15]
	mov: r1 = r14
	movi: r28 = main_Lret0
	bl: count
main_Lret0:
	bi: main_epilogue
main_epilogue:
	ret:

.data
stack_space: .space 256
var_x: .word 128
---------------------------------------------


=== INICIANDO PROCESSO DE MONTAGEM (FullCode) ===
[INIT] Executando a primeira passagem para construir a tabela de símbolos...

--- [PASS 1] Iniciando a Primeira Passagem ---
[PASS 1] Etapa 1: Prevendo o tamanho de cada instrução na seção .text...

[DEBUG PASS 1] Tabela de Símbolos Final:
{
  "output": 1
}
--- Fim do Debug ---


[PASS 1] Etapa 2: Mapeando os rótulos de código para endereços...
[PASS 1] -> Rótulo 'count' mapeado para o endereço 1.
[PASS 1] -> Rótulo 'L0' mapeado para o endereço 20.
[PASS 1] -> Rótulo 'L1' mapeado para o endereço 20.
[PASS 1] -> Rótulo 'count_Lret0' mapeado para o endereço 26.
[PASS 1] -> Rótulo 'count_epilogue' mapeado para o endereço 27.
[PASS 1] -> Rótulo 'main' mapeado para o endereço 33.
[PASS 1] -> Rótulo 'main_Lret0' mapeado para o endereço 44.
[PASS 1] -> Rótulo 'main_epilogue' mapeado para o endereço 45.

[PASS 1] Etapa 3: A seção de código termina no endereço 45. A seção .data começará em 46.

[PASS 1] Etapa 4: Mapeando os rótulos da seção .data...
[PASS 1] -> Rótulo de dados 'stack_space' mapeado para o endereço 46.
[PASS 1] -> Rótulo de dados 'var_x' mapeado para o endereço 46.
--- Fim da Primeira Passagem ---
[INIT] Tabela de símbolos após a primeira passagem: {'output': 1, 'count': 1, 'L0': 20, 'L1': 20, 'count_Lret0': 26, 'count_epilogue': 27, 'main': 33, 'main_Lret0': 44, 'main_epilogue': 45, 'stack_space': 46, 'var_x': 46}
[INIT] Executando a segunda passagem para codificar as instruções...

--- [PASS 2] Iniciando a Segunda Passagem ---
[PASS 2] Etapa 1: Coletando literais grandes e atribuindo endereços a eles...
[PASS 2] -> Linha 9 ('mov: r31 = r29') é uma instrução 'mov' sem imediato. Ignorando para literais.
[PASS 2] -> Linha 15 ('mov: r1 = r12') é uma instrução 'mov' sem imediato. Ignorando para literais.
[PASS 2] -> Linha 16 ('out: r1') é uma instrução 'out'. Ignorando para literais.
[PASS 2] -> Linha 29 ('mov: r1 = r16') é uma instrução 'mov' sem imediato. Ignorando para literais.
[PASS 2] -> Linha 35 ('mov: r29 = r31') é uma instrução 'mov' sem imediato. Ignorando para literais.
[PASS 2] -> Linha 43 ('mov: r31 = r29') é uma instrução 'mov' sem imediato. Ignorando para literais.
[PASS 2] -> Linha 50 ('mov: r1 = r14') é uma instrução 'mov' sem imediato. Ignorando para literais.
[PASS 2] -> Nenhum literal grande encontrado.

[PASS 2] Etapa 2: Codificando cada linha de instrução para binário...

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'bi: main' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'bi: main'
[DISASSEMBLE] -> Parte do opcode: 'bi', Parte dos operandos: 'main'
[DISASSEMBLE] -> Instrução de branch identificada: 'bi'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'i', 'opcode': 'b', 'type': '11', 'op2': 'main'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'b', 'type': '11', 'op2': 'main'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'b', 'type': '11', 'op2': 'main'}
[ENCODE] -> Instrução de branch detectada: b com condição do
[INSTRUCTION] -> Codificação concluída. Binário: 00001110000000000000000000100000

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'subi: r29 = r29, 1' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'subi: r29 = r29, 1'
[DISASSEMBLE] -> Parte do opcode: 'subi', Parte dos operandos: 'r29 = r29, 1'
[DISASSEMBLE] -> Sufixo de suporte encontrado: 'i'. Opcode final é 'sub'
[DISASSEMBLE] -> Opcode final: 'sub', Tipo: 00
[DISASSEMBLE] -> Instrução com atribuição. Destino: 'r29', Origem: 'r29, 1'
[DISASSEMBLE] -> Operandos finais: Rd='r29', Rh='r29', Op2='1'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'i', 'opcode': 'sub', 'type': '00', 'rd': 'r29', 'rh': 'r29', 'op2': '1'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'sub', 'type': '00', 'rd': 'r29', 'rh': 'r29', 'op2': '1'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'sub', 'type': '00', 'rd': 'r29', 'rh': 'r29', 'op2': '1'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000010000111101111010000000001

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'store: [r29] = r28' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'store: [r29] = r28'
[DISASSEMBLE] -> Parte do opcode: 'store', Parte dos operandos: '[r29] = r28'
[DISASSEMBLE] -> Opcode final: 'store', Tipo: 01
[DISASSEMBLE] -> Instrução Store com endereçamento por registrador. Dest detectado: [r29]. Source detectado: 'r28'
[DISASSEMBLE] -> Instrução Load/Store com endereçamento por registrador.
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'na', 'opcode': 'store', 'type': '01', 'rd': 'r0', 'op2': 'r29', 'rh': 'r28'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'store', 'type': '01', 'rd': 'r0', 'op2': 'r29', 'rh': 'r28'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'store', 'type': '01', 'rd': 'r0', 'op2': 'r29', 'rh': 'r28'}
[ENCODE] -> Instrução Store detectada.
[ENCODE] -> rd_bin, rh_bin calculados: Rd(r0)=:00000 e Rh(r28)=:11100
[ENCODE] -> Op2 é um registrador: r29, convertido para binário: 1110100000
[INSTRUCTION] -> Codificação concluída. Binário: 00000100000000000111001110100000

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'subi: r29 = r29, 1' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'subi: r29 = r29, 1'
[DISASSEMBLE] -> Parte do opcode: 'subi', Parte dos operandos: 'r29 = r29, 1'
[DISASSEMBLE] -> Sufixo de suporte encontrado: 'i'. Opcode final é 'sub'
[DISASSEMBLE] -> Opcode final: 'sub', Tipo: 00
[DISASSEMBLE] -> Instrução com atribuição. Destino: 'r29', Origem: 'r29, 1'
[DISASSEMBLE] -> Operandos finais: Rd='r29', Rh='r29', Op2='1'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'i', 'opcode': 'sub', 'type': '00', 'rd': 'r29', 'rh': 'r29', 'op2': '1'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'sub', 'type': '00', 'rd': 'r29', 'rh': 'r29', 'op2': '1'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'sub', 'type': '00', 'rd': 'r29', 'rh': 'r29', 'op2': '1'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000010000111101111010000000001

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'store: [r29] = r31' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'store: [r29] = r31'
[DISASSEMBLE] -> Parte do opcode: 'store', Parte dos operandos: '[r29] = r31'
[DISASSEMBLE] -> Opcode final: 'store', Tipo: 01
[DISASSEMBLE] -> Instrução Store com endereçamento por registrador. Dest detectado: [r29]. Source detectado: 'r31'
[DISASSEMBLE] -> Instrução Load/Store com endereçamento por registrador.
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'na', 'opcode': 'store', 'type': '01', 'rd': 'r0', 'op2': 'r29', 'rh': 'r31'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'store', 'type': '01', 'rd': 'r0', 'op2': 'r29', 'rh': 'r31'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'store', 'type': '01', 'rd': 'r0', 'op2': 'r29', 'rh': 'r31'}
[ENCODE] -> Instrução Store detectada.
[ENCODE] -> rd_bin, rh_bin calculados: Rd(r0)=:00000 e Rh(r31)=:11111
[ENCODE] -> Op2 é um registrador: r29, convertido para binário: 1110100000
[INSTRUCTION] -> Codificação concluída. Binário: 00000100000000000111111110100000

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'mov: r31 = r29' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'mov: r31 = r29'
[DISASSEMBLE] -> Parte do opcode: 'mov', Parte dos operandos: 'r31 = r29'
[DISASSEMBLE] -> Opcode final: 'mov', Tipo: 00
[DISASSEMBLE] -> Instrução 'mov' identificada. Destino: 'r31', Origem: 'r29'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'na', 'opcode': 'mov', 'type': '00', 'rd': 'r31', 'rh': 'r0', 'op2': 'r29'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'mov', 'type': '00', 'rd': 'r31', 'rh': 'r0', 'op2': 'r29'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'mov', 'type': '00', 'rd': 'r31', 'rh': 'r0', 'op2': 'r29'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000000100011111000001110100000

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'subi: r29 = r29, 6' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'subi: r29 = r29, 6'
[DISASSEMBLE] -> Parte do opcode: 'subi', Parte dos operandos: 'r29 = r29, 6'
[DISASSEMBLE] -> Sufixo de suporte encontrado: 'i'. Opcode final é 'sub'
[DISASSEMBLE] -> Opcode final: 'sub', Tipo: 00
[DISASSEMBLE] -> Instrução com atribuição. Destino: 'r29', Origem: 'r29, 6'
[DISASSEMBLE] -> Operandos finais: Rd='r29', Rh='r29', Op2='6'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'i', 'opcode': 'sub', 'type': '00', 'rd': 'r29', 'rh': 'r29', 'op2': '6'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'sub', 'type': '00', 'rd': 'r29', 'rh': 'r29', 'op2': '6'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'sub', 'type': '00', 'rd': 'r29', 'rh': 'r29', 'op2': '6'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000010000111101111010000000110

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'subi: r30 = r31, 1' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'subi: r30 = r31, 1'
[DISASSEMBLE] -> Parte do opcode: 'subi', Parte dos operandos: 'r30 = r31, 1'
[DISASSEMBLE] -> Sufixo de suporte encontrado: 'i'. Opcode final é 'sub'
[DISASSEMBLE] -> Opcode final: 'sub', Tipo: 00
[DISASSEMBLE] -> Instrução com atribuição. Destino: 'r30', Origem: 'r31, 1'
[DISASSEMBLE] -> Operandos finais: Rd='r30', Rh='r31', Op2='1'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'i', 'opcode': 'sub', 'type': '00', 'rd': 'r30', 'rh': 'r31', 'op2': '1'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'sub', 'type': '00', 'rd': 'r30', 'rh': 'r31', 'op2': '1'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'sub', 'type': '00', 'rd': 'r30', 'rh': 'r31', 'op2': '1'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000010000111110111110000000001

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'store: [r30] = r1' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'store: [r30] = r1'
[DISASSEMBLE] -> Parte do opcode: 'store', Parte dos operandos: '[r30] = r1'
[DISASSEMBLE] -> Opcode final: 'store', Tipo: 01
[DISASSEMBLE] -> Instrução Store com endereçamento por registrador. Dest detectado: [r30]. Source detectado: 'r1'
[DISASSEMBLE] -> Instrução Load/Store com endereçamento por registrador.
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'na', 'opcode': 'store', 'type': '01', 'rd': 'r0', 'op2': 'r30', 'rh': 'r1'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'store', 'type': '01', 'rd': 'r0', 'op2': 'r30', 'rh': 'r1'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'store', 'type': '01', 'rd': 'r0', 'op2': 'r30', 'rh': 'r1'}
[ENCODE] -> Instrução Store detectada.
[ENCODE] -> rd_bin, rh_bin calculados: Rd(r0)=:00000 e Rh(r1)=:00001
[ENCODE] -> Op2 é um registrador: r30, convertido para binário: 1111000000
[INSTRUCTION] -> Codificação concluída. Binário: 00000100000000000000011111000000

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'subi: r30 = r31, 1' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'subi: r30 = r31, 1'
[DISASSEMBLE] -> Parte do opcode: 'subi', Parte dos operandos: 'r30 = r31, 1'
[DISASSEMBLE] -> Sufixo de suporte encontrado: 'i'. Opcode final é 'sub'
[DISASSEMBLE] -> Opcode final: 'sub', Tipo: 00
[DISASSEMBLE] -> Instrução com atribuição. Destino: 'r30', Origem: 'r31, 1'
[DISASSEMBLE] -> Operandos finais: Rd='r30', Rh='r31', Op2='1'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'i', 'opcode': 'sub', 'type': '00', 'rd': 'r30', 'rh': 'r31', 'op2': '1'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'sub', 'type': '00', 'rd': 'r30', 'rh': 'r31', 'op2': '1'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'sub', 'type': '00', 'rd': 'r30', 'rh': 'r31', 'op2': '1'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000010000111110111110000000001

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'load: r12 = [r30]' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'load: r12 = [r30]'
[DISASSEMBLE] -> Parte do opcode: 'load', Parte dos operandos: 'r12 = [r30]'
[DISASSEMBLE] -> Opcode final: 'load', Tipo: 01
[DISASSEMBLE] -> Instrução Load/Store com endereçamento por registrador.
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'na', 'opcode': 'load', 'type': '01', 'rd': 'r12', 'rh': 'r0', 'op2': 'r30'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'load', 'type': '01', 'rd': 'r12', 'rh': 'r0', 'op2': 'r30'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'load', 'type': '01', 'rd': 'r12', 'rh': 'r0', 'op2': 'r30'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000100000101100000001111000000

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'mov: r1 = r12' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'mov: r1 = r12'
[DISASSEMBLE] -> Parte do opcode: 'mov', Parte dos operandos: 'r1 = r12'
[DISASSEMBLE] -> Opcode final: 'mov', Tipo: 00
[DISASSEMBLE] -> Instrução 'mov' identificada. Destino: 'r1', Origem: 'r12'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'na', 'opcode': 'mov', 'type': '00', 'rd': 'r1', 'rh': 'r0', 'op2': 'r12'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'mov', 'type': '00', 'rd': 'r1', 'rh': 'r0', 'op2': 'r12'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'mov', 'type': '00', 'rd': 'r1', 'rh': 'r0', 'op2': 'r12'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000000100000001000000110000000

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'out: r1' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'out: r1'
[DISASSEMBLE] -> Parte do opcode: 'out', Parte dos operandos: 'r1'
[DISASSEMBLE] -> Instrução 'out' identificada.
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'na', 'opcode': 'out', 'type': '00', 'rd': 'r0', 'rh': 'r0', 'op2': 'r1'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'out', 'type': '00', 'rd': 'r0', 'rh': 'r0', 'op2': 'r1'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'out', 'type': '00', 'rd': 'r0', 'rh': 'r0', 'op2': 'r1'}
[ENCODE] -> Instrução 'out' detectada.
[INSTRUCTION] -> Codificação concluída. Binário: 00000000101000000000000000100000

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'subi: r30 = r31, 1' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'subi: r30 = r31, 1'
[DISASSEMBLE] -> Parte do opcode: 'subi', Parte dos operandos: 'r30 = r31, 1'
[DISASSEMBLE] -> Sufixo de suporte encontrado: 'i'. Opcode final é 'sub'
[DISASSEMBLE] -> Opcode final: 'sub', Tipo: 00
[DISASSEMBLE] -> Instrução com atribuição. Destino: 'r30', Origem: 'r31, 1'
[DISASSEMBLE] -> Operandos finais: Rd='r30', Rh='r31', Op2='1'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'i', 'opcode': 'sub', 'type': '00', 'rd': 'r30', 'rh': 'r31', 'op2': '1'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'sub', 'type': '00', 'rd': 'r30', 'rh': 'r31', 'op2': '1'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'sub', 'type': '00', 'rd': 'r30', 'rh': 'r31', 'op2': '1'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000010000111110111110000000001

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'load: r13 = [r30]' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'load: r13 = [r30]'
[DISASSEMBLE] -> Parte do opcode: 'load', Parte dos operandos: 'r13 = [r30]'
[DISASSEMBLE] -> Opcode final: 'load', Tipo: 01
[DISASSEMBLE] -> Instrução Load/Store com endereçamento por registrador.
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'na', 'opcode': 'load', 'type': '01', 'rd': 'r13', 'rh': 'r0', 'op2': 'r30'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'load', 'type': '01', 'rd': 'r13', 'rh': 'r0', 'op2': 'r30'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'load', 'type': '01', 'rd': 'r13', 'rh': 'r0', 'op2': 'r30'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000100000101101000001111000000

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'movi: r14 = 0' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'movi: r14 = 0'
[DISASSEMBLE] -> Parte do opcode: 'movi', Parte dos operandos: 'r14 = 0'
[DISASSEMBLE] -> Sufixo de suporte encontrado: 'i'. Opcode final é 'mov'
[DISASSEMBLE] -> Opcode final: 'mov', Tipo: 00
[DISASSEMBLE] -> Instrução 'mov' identificada. Destino: 'r14', Origem: '0'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'i', 'opcode': 'mov', 'type': '00', 'rd': 'r14', 'rh': 'r0', 'op2': '0'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'mov', 'type': '00', 'rd': 'r14', 'rh': 'r0', 'op2': '0'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'mov', 'type': '00', 'rd': 'r14', 'rh': 'r0', 'op2': '0'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000010100001110000000000000000

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'subs: r0 = r13, r14' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'subs: r0 = r13, r14'
[DISASSEMBLE] -> Parte do opcode: 'subs', Parte dos operandos: 'r0 = r13, r14'
[DISASSEMBLE] -> Sufixo de suporte encontrado: 's'. Opcode final é 'sub'
[DISASSEMBLE] -> Opcode final: 'sub', Tipo: 00
[DISASSEMBLE] -> Instrução com atribuição. Destino: 'r0', Origem: 'r13, r14'
[DISASSEMBLE] -> Operandos finais: Rd='r0', Rh='r13', Op2='r14'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 's', 'opcode': 'sub', 'type': '00', 'rd': 'r0', 'rh': 'r13', 'op2': 'r14'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 's', 'opcode': 'sub', 'type': '00', 'rd': 'r0', 'rh': 'r13', 'op2': 'r14'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 's', 'opcode': 'sub', 'type': '00', 'rd': 'r0', 'rh': 'r13', 'op2': 'r14'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000001000100000011010111000000

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'bineq: L0' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'bineq: L0'
[DISASSEMBLE] -> Parte do opcode: 'bineq', Parte dos operandos: 'L0'
[DISASSEMBLE] -> Instrução de branch identificada: 'bineq'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'neq', 'supp': 'i', 'opcode': 'b', 'type': '11', 'op2': 'L0'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'neq', 'supp': 'i', 'opcode': 'b', 'type': '11', 'op2': 'L0'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'neq', 'supp': 'i', 'opcode': 'b', 'type': '11', 'op2': 'L0'}
[ENCODE] -> Instrução de branch detectada: b com condição neq
[INSTRUCTION] -> Codificação concluída. Binário: 00101110000000000000000000000010

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'bi: count_epilogue' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'bi: count_epilogue'
[DISASSEMBLE] -> Parte do opcode: 'bi', Parte dos operandos: 'count_epilogue'
[DISASSEMBLE] -> Instrução de branch identificada: 'bi'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'i', 'opcode': 'b', 'type': '11', 'op2': 'count_epilogue'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'b', 'type': '11', 'op2': 'count_epilogue'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'b', 'type': '11', 'op2': 'count_epilogue'}
[ENCODE] -> Instrução de branch detectada: b com condição do
[INSTRUCTION] -> Codificação concluída. Binário: 00001110000000000000000000001000

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'bi: L1' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'bi: L1'
[DISASSEMBLE] -> Parte do opcode: 'bi', Parte dos operandos: 'L1'
[DISASSEMBLE] -> Instrução de branch identificada: 'bi'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'i', 'opcode': 'b', 'type': '11', 'op2': 'L1'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'b', 'type': '11', 'op2': 'L1'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'b', 'type': '11', 'op2': 'L1'}
[ENCODE] -> Instrução de branch detectada: b com condição do
[INSTRUCTION] -> Codificação concluída. Binário: 00001110000000000000000000000000

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'subi: r30 = r31, 1' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'subi: r30 = r31, 1'
[DISASSEMBLE] -> Parte do opcode: 'subi', Parte dos operandos: 'r30 = r31, 1'
[DISASSEMBLE] -> Sufixo de suporte encontrado: 'i'. Opcode final é 'sub'
[DISASSEMBLE] -> Opcode final: 'sub', Tipo: 00
[DISASSEMBLE] -> Instrução com atribuição. Destino: 'r30', Origem: 'r31, 1'
[DISASSEMBLE] -> Operandos finais: Rd='r30', Rh='r31', Op2='1'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'i', 'opcode': 'sub', 'type': '00', 'rd': 'r30', 'rh': 'r31', 'op2': '1'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'sub', 'type': '00', 'rd': 'r30', 'rh': 'r31', 'op2': '1'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'sub', 'type': '00', 'rd': 'r30', 'rh': 'r31', 'op2': '1'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000010000111110111110000000001

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'load: r15 = [r30]' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'load: r15 = [r30]'
[DISASSEMBLE] -> Parte do opcode: 'load', Parte dos operandos: 'r15 = [r30]'
[DISASSEMBLE] -> Opcode final: 'load', Tipo: 01
[DISASSEMBLE] -> Instrução Load/Store com endereçamento por registrador.
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'na', 'opcode': 'load', 'type': '01', 'rd': 'r15', 'rh': 'r0', 'op2': 'r30'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'load', 'type': '01', 'rd': 'r15', 'rh': 'r0', 'op2': 'r30'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'load', 'type': '01', 'rd': 'r15', 'rh': 'r0', 'op2': 'r30'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000100000101111000001111000000

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'subi: r16 = r15, 1' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'subi: r16 = r15, 1'
[DISASSEMBLE] -> Parte do opcode: 'subi', Parte dos operandos: 'r16 = r15, 1'
[DISASSEMBLE] -> Sufixo de suporte encontrado: 'i'. Opcode final é 'sub'
[DISASSEMBLE] -> Opcode final: 'sub', Tipo: 00
[DISASSEMBLE] -> Instrução com atribuição. Destino: 'r16', Origem: 'r15, 1'
[DISASSEMBLE] -> Operandos finais: Rd='r16', Rh='r15', Op2='1'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'i', 'opcode': 'sub', 'type': '00', 'rd': 'r16', 'rh': 'r15', 'op2': '1'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'sub', 'type': '00', 'rd': 'r16', 'rh': 'r15', 'op2': '1'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'sub', 'type': '00', 'rd': 'r16', 'rh': 'r15', 'op2': '1'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000010000110000011110000000001

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'mov: r1 = r16' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'mov: r1 = r16'
[DISASSEMBLE] -> Parte do opcode: 'mov', Parte dos operandos: 'r1 = r16'
[DISASSEMBLE] -> Opcode final: 'mov', Tipo: 00
[DISASSEMBLE] -> Instrução 'mov' identificada. Destino: 'r1', Origem: 'r16'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'na', 'opcode': 'mov', 'type': '00', 'rd': 'r1', 'rh': 'r0', 'op2': 'r16'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'mov', 'type': '00', 'rd': 'r1', 'rh': 'r0', 'op2': 'r16'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'mov', 'type': '00', 'rd': 'r1', 'rh': 'r0', 'op2': 'r16'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000000100000001000001000000000

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'movi: r28 = count_Lret0' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'movi: r28 = count_Lret0'
[DISASSEMBLE] -> Parte do opcode: 'movi', Parte dos operandos: 'r28 = count_Lret0'
[DISASSEMBLE] -> Sufixo de suporte encontrado: 'i'. Opcode final é 'mov'
[DISASSEMBLE] -> Opcode final: 'mov', Tipo: 00
[DISASSEMBLE] -> Instrução 'mov' identificada. Destino: 'r28', Origem: 'count_Lret0'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'i', 'opcode': 'mov', 'type': '00', 'rd': 'r28', 'rh': 'r0', 'op2': 'count_Lret0'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'mov', 'type': '00', 'rd': 'r28', 'rh': 'r0', 'op2': 'count_Lret0'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'mov', 'type': '00', 'rd': 'r28', 'rh': 'r0', 'op2': 'count_Lret0'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000010100011100000000000011010

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'bl: count' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'bl: count'
[DISASSEMBLE] -> Parte do opcode: 'bl', Parte dos operandos: 'count'
[DISASSEMBLE] -> Instrução de branch com link identificada: 'bl'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'i', 'opcode': 'bl', 'type': '11', 'op2': 'count'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'bl', 'type': '11', 'op2': 'count'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'bl', 'type': '11', 'op2': 'count'}
[ENCODE] -> Instrução de branch detectada: bl com condição do
[INSTRUCTION] -> Codificação concluída. Binário: 00001110100011111111111111100111

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'bi: count_epilogue' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'bi: count_epilogue'
[DISASSEMBLE] -> Parte do opcode: 'bi', Parte dos operandos: 'count_epilogue'
[DISASSEMBLE] -> Instrução de branch identificada: 'bi'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'i', 'opcode': 'b', 'type': '11', 'op2': 'count_epilogue'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'b', 'type': '11', 'op2': 'count_epilogue'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'b', 'type': '11', 'op2': 'count_epilogue'}
[ENCODE] -> Instrução de branch detectada: b com condição do
[INSTRUCTION] -> Codificação concluída. Binário: 00001110000000000000000000000000

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'mov: r29 = r31' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'mov: r29 = r31'
[DISASSEMBLE] -> Parte do opcode: 'mov', Parte dos operandos: 'r29 = r31'
[DISASSEMBLE] -> Opcode final: 'mov', Tipo: 00
[DISASSEMBLE] -> Instrução 'mov' identificada. Destino: 'r29', Origem: 'r31'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'na', 'opcode': 'mov', 'type': '00', 'rd': 'r29', 'rh': 'r0', 'op2': 'r31'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'mov', 'type': '00', 'rd': 'r29', 'rh': 'r0', 'op2': 'r31'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'mov', 'type': '00', 'rd': 'r29', 'rh': 'r0', 'op2': 'r31'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000000100011101000001111100000

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'load: r31 = [r29]' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'load: r31 = [r29]'
[DISASSEMBLE] -> Parte do opcode: 'load', Parte dos operandos: 'r31 = [r29]'
[DISASSEMBLE] -> Opcode final: 'load', Tipo: 01
[DISASSEMBLE] -> Instrução Load/Store com endereçamento por registrador.
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'na', 'opcode': 'load', 'type': '01', 'rd': 'r31', 'rh': 'r0', 'op2': 'r29'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'load', 'type': '01', 'rd': 'r31', 'rh': 'r0', 'op2': 'r29'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'load', 'type': '01', 'rd': 'r31', 'rh': 'r0', 'op2': 'r29'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000100000111111000001110100000

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'addi: r29 = r29, 1' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'addi: r29 = r29, 1'
[DISASSEMBLE] -> Parte do opcode: 'addi', Parte dos operandos: 'r29 = r29, 1'
[DISASSEMBLE] -> Sufixo de suporte encontrado: 'i'. Opcode final é 'add'
[DISASSEMBLE] -> Opcode final: 'add', Tipo: 00
[DISASSEMBLE] -> Instrução com atribuição. Destino: 'r29', Origem: 'r29, 1'
[DISASSEMBLE] -> Operandos finais: Rd='r29', Rh='r29', Op2='1'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'i', 'opcode': 'add', 'type': '00', 'rd': 'r29', 'rh': 'r29', 'op2': '1'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'add', 'type': '00', 'rd': 'r29', 'rh': 'r29', 'op2': '1'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'add', 'type': '00', 'rd': 'r29', 'rh': 'r29', 'op2': '1'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000010000011101111010000000001

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'load: r28 = [r29]' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'load: r28 = [r29]'
[DISASSEMBLE] -> Parte do opcode: 'load', Parte dos operandos: 'r28 = [r29]'
[DISASSEMBLE] -> Opcode final: 'load', Tipo: 01
[DISASSEMBLE] -> Instrução Load/Store com endereçamento por registrador.
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'na', 'opcode': 'load', 'type': '01', 'rd': 'r28', 'rh': 'r0', 'op2': 'r29'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'load', 'type': '01', 'rd': 'r28', 'rh': 'r0', 'op2': 'r29'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'load', 'type': '01', 'rd': 'r28', 'rh': 'r0', 'op2': 'r29'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000100000111100000001110100000

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'addi: r29 = r29, 1' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'addi: r29 = r29, 1'
[DISASSEMBLE] -> Parte do opcode: 'addi', Parte dos operandos: 'r29 = r29, 1'
[DISASSEMBLE] -> Sufixo de suporte encontrado: 'i'. Opcode final é 'add'
[DISASSEMBLE] -> Opcode final: 'add', Tipo: 00
[DISASSEMBLE] -> Instrução com atribuição. Destino: 'r29', Origem: 'r29, 1'
[DISASSEMBLE] -> Operandos finais: Rd='r29', Rh='r29', Op2='1'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'i', 'opcode': 'add', 'type': '00', 'rd': 'r29', 'rh': 'r29', 'op2': '1'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'add', 'type': '00', 'rd': 'r29', 'rh': 'r29', 'op2': '1'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'add', 'type': '00', 'rd': 'r29', 'rh': 'r29', 'op2': '1'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000010000011101111010000000001

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'b: r28' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'b: r28'
[DISASSEMBLE] -> Parte do opcode: 'b', Parte dos operandos: 'r28'
[DISASSEMBLE] -> Instrução de branch identificada: 'b'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'na', 'opcode': 'b', 'type': '11', 'op2': 'r28'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'b', 'type': '11', 'op2': 'r28'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'b', 'type': '11', 'op2': 'r28'}
[ENCODE] -> Instrução de branch detectada: b com condição do
[ENCODE] -> Branch para registrador detectado: r28
[INSTRUCTION] -> Codificação concluída. Binário: 00001100000000000000001110000000

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'movi: r29 = stack_space' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'movi: r29 = stack_space'
[DISASSEMBLE] -> Parte do opcode: 'movi', Parte dos operandos: 'r29 = stack_space'
[DISASSEMBLE] -> Sufixo de suporte encontrado: 'i'. Opcode final é 'mov'
[DISASSEMBLE] -> Opcode final: 'mov', Tipo: 00
[DISASSEMBLE] -> Instrução 'mov' identificada. Destino: 'r29', Origem: 'stack_space'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'i', 'opcode': 'mov', 'type': '00', 'rd': 'r29', 'rh': 'r0', 'op2': 'stack_space'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'mov', 'type': '00', 'rd': 'r29', 'rh': 'r0', 'op2': 'stack_space'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'mov', 'type': '00', 'rd': 'r29', 'rh': 'r0', 'op2': 'stack_space'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000010100011101000000000101110

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'mov: r31 = r29' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'mov: r31 = r29'
[DISASSEMBLE] -> Parte do opcode: 'mov', Parte dos operandos: 'r31 = r29'
[DISASSEMBLE] -> Opcode final: 'mov', Tipo: 00
[DISASSEMBLE] -> Instrução 'mov' identificada. Destino: 'r31', Origem: 'r29'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'na', 'opcode': 'mov', 'type': '00', 'rd': 'r31', 'rh': 'r0', 'op2': 'r29'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'mov', 'type': '00', 'rd': 'r31', 'rh': 'r0', 'op2': 'r29'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'mov', 'type': '00', 'rd': 'r31', 'rh': 'r0', 'op2': 'r29'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000000100011111000001110100000

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'subi: r29 = r29, 2' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'subi: r29 = r29, 2'
[DISASSEMBLE] -> Parte do opcode: 'subi', Parte dos operandos: 'r29 = r29, 2'
[DISASSEMBLE] -> Sufixo de suporte encontrado: 'i'. Opcode final é 'sub'
[DISASSEMBLE] -> Opcode final: 'sub', Tipo: 00
[DISASSEMBLE] -> Instrução com atribuição. Destino: 'r29', Origem: 'r29, 2'
[DISASSEMBLE] -> Operandos finais: Rd='r29', Rh='r29', Op2='2'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'i', 'opcode': 'sub', 'type': '00', 'rd': 'r29', 'rh': 'r29', 'op2': '2'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'sub', 'type': '00', 'rd': 'r29', 'rh': 'r29', 'op2': '2'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'sub', 'type': '00', 'rd': 'r29', 'rh': 'r29', 'op2': '2'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000010000111101111010000000010

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'in: r12' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'in: r12'
[DISASSEMBLE] -> Parte do opcode: 'in', Parte dos operandos: 'r12'
[DISASSEMBLE] -> Opcode final: 'in', Tipo: 00
[DISASSEMBLE] -> Instrução de operando único. Rd: 'r12'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'na', 'opcode': 'in', 'type': '00', 'rd': 'r12', 'rh': 'r0', 'op2': '0'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'in', 'type': '00', 'rd': 'r12', 'rh': 'r0', 'op2': '0'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'in', 'type': '00', 'rd': 'r12', 'rh': 'r0', 'op2': '0'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000000100101100000000000000000

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'movi: r13 = 128' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'movi: r13 = 128'
[DISASSEMBLE] -> Parte do opcode: 'movi', Parte dos operandos: 'r13 = 128'
[DISASSEMBLE] -> Sufixo de suporte encontrado: 'i'. Opcode final é 'mov'
[DISASSEMBLE] -> Opcode final: 'mov', Tipo: 00
[DISASSEMBLE] -> Instrução 'mov' identificada. Destino: 'r13', Origem: '128'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'i', 'opcode': 'mov', 'type': '00', 'rd': 'r13', 'rh': 'r0', 'op2': '128'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'mov', 'type': '00', 'rd': 'r13', 'rh': 'r0', 'op2': '128'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'mov', 'type': '00', 'rd': 'r13', 'rh': 'r0', 'op2': '128'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000010100001101000000010000000

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'store: [r13] = r12' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'store: [r13] = r12'
[DISASSEMBLE] -> Parte do opcode: 'store', Parte dos operandos: '[r13] = r12'
[DISASSEMBLE] -> Opcode final: 'store', Tipo: 01
[DISASSEMBLE] -> Instrução Store com endereçamento por registrador. Dest detectado: [r13]. Source detectado: 'r12'
[DISASSEMBLE] -> Instrução Load/Store com endereçamento por registrador.
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'na', 'opcode': 'store', 'type': '01', 'rd': 'r0', 'op2': 'r13', 'rh': 'r12'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'store', 'type': '01', 'rd': 'r0', 'op2': 'r13', 'rh': 'r12'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'store', 'type': '01', 'rd': 'r0', 'op2': 'r13', 'rh': 'r12'}
[ENCODE] -> Instrução Store detectada.
[ENCODE] -> rd_bin, rh_bin calculados: Rd(r0)=:00000 e Rh(r12)=:01100
[ENCODE] -> Op2 é um registrador: r13, convertido para binário: 0110100000
[INSTRUCTION] -> Codificação concluída. Binário: 00000100000000000011000110100000

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'movi: r15 = 128' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'movi: r15 = 128'
[DISASSEMBLE] -> Parte do opcode: 'movi', Parte dos operandos: 'r15 = 128'
[DISASSEMBLE] -> Sufixo de suporte encontrado: 'i'. Opcode final é 'mov'
[DISASSEMBLE] -> Opcode final: 'mov', Tipo: 00
[DISASSEMBLE] -> Instrução 'mov' identificada. Destino: 'r15', Origem: '128'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'i', 'opcode': 'mov', 'type': '00', 'rd': 'r15', 'rh': 'r0', 'op2': '128'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'mov', 'type': '00', 'rd': 'r15', 'rh': 'r0', 'op2': '128'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'mov', 'type': '00', 'rd': 'r15', 'rh': 'r0', 'op2': '128'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000010100001111000000010000000

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'load: r14 = [r15]' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'load: r14 = [r15]'
[DISASSEMBLE] -> Parte do opcode: 'load', Parte dos operandos: 'r14 = [r15]'
[DISASSEMBLE] -> Opcode final: 'load', Tipo: 01
[DISASSEMBLE] -> Instrução Load/Store com endereçamento por registrador.
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'na', 'opcode': 'load', 'type': '01', 'rd': 'r14', 'rh': 'r0', 'op2': 'r15'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'load', 'type': '01', 'rd': 'r14', 'rh': 'r0', 'op2': 'r15'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'load', 'type': '01', 'rd': 'r14', 'rh': 'r0', 'op2': 'r15'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000100000101110000000111100000

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'mov: r1 = r14' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'mov: r1 = r14'
[DISASSEMBLE] -> Parte do opcode: 'mov', Parte dos operandos: 'r1 = r14'
[DISASSEMBLE] -> Opcode final: 'mov', Tipo: 00
[DISASSEMBLE] -> Instrução 'mov' identificada. Destino: 'r1', Origem: 'r14'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'na', 'opcode': 'mov', 'type': '00', 'rd': 'r1', 'rh': 'r0', 'op2': 'r14'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'mov', 'type': '00', 'rd': 'r1', 'rh': 'r0', 'op2': 'r14'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'mov', 'type': '00', 'rd': 'r1', 'rh': 'r0', 'op2': 'r14'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000000100000001000000111000000

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'movi: r28 = main_Lret0' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'movi: r28 = main_Lret0'
[DISASSEMBLE] -> Parte do opcode: 'movi', Parte dos operandos: 'r28 = main_Lret0'
[DISASSEMBLE] -> Sufixo de suporte encontrado: 'i'. Opcode final é 'mov'
[DISASSEMBLE] -> Opcode final: 'mov', Tipo: 00
[DISASSEMBLE] -> Instrução 'mov' identificada. Destino: 'r28', Origem: 'main_Lret0'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'i', 'opcode': 'mov', 'type': '00', 'rd': 'r28', 'rh': 'r0', 'op2': 'main_Lret0'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'mov', 'type': '00', 'rd': 'r28', 'rh': 'r0', 'op2': 'main_Lret0'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'mov', 'type': '00', 'rd': 'r28', 'rh': 'r0', 'op2': 'main_Lret0'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000010100011100000000000101100

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'bl: count' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'bl: count'
[DISASSEMBLE] -> Parte do opcode: 'bl', Parte dos operandos: 'count'
[DISASSEMBLE] -> Instrução de branch com link identificada: 'bl'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'i', 'opcode': 'bl', 'type': '11', 'op2': 'count'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'bl', 'type': '11', 'op2': 'count'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'bl', 'type': '11', 'op2': 'count'}
[ENCODE] -> Instrução de branch detectada: bl com condição do
[INSTRUCTION] -> Codificação concluída. Binário: 00001110100011111111111111010101

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'bi: main_epilogue' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'bi: main_epilogue'
[DISASSEMBLE] -> Parte do opcode: 'bi', Parte dos operandos: 'main_epilogue'
[DISASSEMBLE] -> Instrução de branch identificada: 'bi'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'i', 'opcode': 'b', 'type': '11', 'op2': 'main_epilogue'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'b', 'type': '11', 'op2': 'main_epilogue'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'b', 'type': '11', 'op2': 'main_epilogue'}
[ENCODE] -> Instrução de branch detectada: b com condição do
[INSTRUCTION] -> Codificação concluída. Binário: 00001110000000000000000000000000

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'ret:' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'ret:'
[DISASSEMBLE] -> Instrução 'ret' identificada.
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'na', 'opcode': 'ret', 'type': '11'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'ret', 'type': '11'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'ret', 'type': '11'}
[INSTRUCTION] -> Codificação concluída. Binário: 00001100111111111111111111111111

[PASS 2] -> 46 linhas de código de máquina geradas.

[PASS 2] Etapa 3: Adicionando a seção de dados e literais ao código de máquina final...
[PASS 2] -> Dados a serem adicionados (endereço: valor): [(46, '128'), (47, '0'), (48, '0'), (49, '0'), (50, '0'), (51, '0'), (52, '0'), (53, '0'), (54, '0'), (55, '0'), (56, '0'), (57, '0'), (58, '0'), (59, '0'), (60, '0'), (61, '0'), (62, '0'), (63, '0'), (64, '0'), (65, '0'), (66, '0'), (67, '0'), (68, '0'), (69, '0'), (70, '0'), (71, '0'), (72, '0'), (73, '0'), (74, '0'), (75, '0'), (76, '0'), (77, '0'), (78, '0'), (79, '0'), (80, '0'), (81, '0'), (82, '0'), (83, '0'), (84, '0'), (85, '0'), (86, '0'), (87, '0'), (88, '0'), (89, '0'), (90, '0'), (91, '0'), (92, '0'), (93, '0'), (94, '0'), (95, '0'), (96, '0'), (97, '0'), (98, '0'), (99, '0'), (100, '0'), (101, '0'), (102, '0'), (103, '0'), (104, '0'), (105, '0'), (106, '0'), (107, '0'), (108, '0'), (109, '0'), (110, '0'), (111, '0'), (112, '0'), (113, '0'), (114, '0'), (115, '0'), (116, '0'), (117, '0'), (118, '0'), (119, '0'), (120, '0'), (121, '0'), (122, '0'), (123, '0'), (124, '0'), (125, '0'), (126, '0'), (127, '0'), (128, '0'), (129, '0'), (130, '0'), (131, '0'), (132, '0'), (133, '0'), (134, '0'), (135, '0'), (136, '0'), (137, '0'), (138, '0'), (139, '0'), (140, '0'), (141, '0'), (142, '0'), (143, '0'), (144, '0'), (145, '0'), (146, '0'), (147, '0'), (148, '0'), (149, '0'), (150, '0'), (151, '0'), (152, '0'), (153, '0'), (154, '0'), (155, '0'), (156, '0'), (157, '0'), (158, '0'), (159, '0'), (160, '0'), (161, '0'), (162, '0'), (163, '0'), (164, '0'), (165, '0'), (166, '0'), (167, '0'), (168, '0'), (169, '0'), (170, '0'), (171, '0'), (172, '0'), (173, '0'), (174, '0'), (175, '0'), (176, '0'), (177, '0'), (178, '0'), (179, '0'), (180, '0'), (181, '0'), (182, '0'), (183, '0'), (184, '0'), (185, '0'), (186, '0'), (187, '0'), (188, '0'), (189, '0'), (190, '0'), (191, '0'), (192, '0'), (193, '0'), (194, '0'), (195, '0'), (196, '0'), (197, '0'), (198, '0'), (199, '0'), (200, '0'), (201, '0'), (202, '0'), (203, '0'), (204, '0'), (205, '0'), (206, '0'), (207, '0'), (208, '0'), (209, '0'), (210, '0'), (211, '0'), (212, '0'), (213, '0'), (214, '0'), (215, '0'), (216, '0'), (217, '0'), (218, '0'), (219, '0'), (220, '0'), (221, '0'), (222, '0'), (223, '0'), (224, '0'), (225, '0'), (226, '0'), (227, '0'), (228, '0'), (229, '0'), (230, '0'), (231, '0'), (232, '0'), (233, '0'), (234, '0'), (235, '0'), (236, '0'), (237, '0'), (238, '0'), (239, '0'), (240, '0'), (241, '0'), (242, '0'), (243, '0'), (244, '0'), (245, '0'), (246, '0'), (247, '0'), (248, '0'), (249, '0'), (250, '0'), (251, '0'), (252, '0'), (253, '0'), (254, '0'), (255, '0'), (256, '0'), (257, '0'), (258, '0'), (259, '0'), (260, '0'), (261, '0'), (262, '0'), (263, '0'), (264, '0'), (265, '0'), (266, '0'), (267, '0'), (268, '0'), (269, '0'), (270, '0'), (271, '0'), (272, '0'), (273, '0'), (274, '0'), (275, '0'), (276, '0'), (277, '0'), (278, '0'), (279, '0'), (280, '0'), (281, '0'), (282, '0'), (283, '0'), (284, '0'), (285, '0'), (286, '0'), (287, '0'), (288, '0'), (289, '0'), (290, '0'), (291, '0'), (292, '0'), (293, '0'), (294, '0'), (295, '0'), (296, '0'), (297, '0'), (298, '0'), (299, '0'), (300, '0'), (301, '0')]
--- Fim da Segunda Passagem ---
=== PROCESSO DE MONTAGEM CONCLUÍDO ===
--- DEBUG OUTPUT ---
00001110000000000000000000100000 -> cond[0000] type[11] supp[10] op[0000] offset_calc[(33 - 1) = 32]->bin[00000000000000100000]
00000010000111101111010000000001 -> cond[0000] type[00] supp[10] op[0001] Rd[11101] Rh[11101] imm[1=1]->[0000000001]
00000100000000000111001110100000 -> cond[0000] type[01] supp[00] op[0000] Rd[00000] Rh[11100] Ro[11101] pad[00000] (Store sem imediato)
00000010000111101111010000000001 -> cond[0000] type[00] supp[10] op[0001] Rd[11101] Rh[11101] imm[1=1]->[0000000001]
00000100000000000111111110100000 -> cond[0000] type[01] supp[00] op[0000] Rd[00000] Rh[11111] Ro[11101] pad[00000] (Store sem imediato)
00000000100011111000001110100000 -> cond[0000] type[00] supp[00] op[1000] Rd[11111] Rh[00000] Ro[11101] pad[00000] (Mov sem imediato)
00000010000111101111010000000110 -> cond[0000] type[00] supp[10] op[0001] Rd[11101] Rh[11101] imm[6=6]->[0000000110]
00000010000111110111110000000001 -> cond[0000] type[00] supp[10] op[0001] Rd[11110] Rh[11111] imm[1=1]->[0000000001]
00000100000000000000011111000000 -> cond[0000] type[01] supp[00] op[0000] Rd[00000] Rh[00001] Ro[11110] pad[00000] (Store sem imediato)
00000010000111110111110000000001 -> cond[0000] type[00] supp[10] op[0001] Rd[11110] Rh[11111] imm[1=1]->[0000000001]
00000100000101100000001111000000 -> cond[0000] type[01] supp[00] op[0001] Rd[01100] Rh[00000] Ro[11110] pad[00000] (Load sem imediato)
00000000100000001000000110000000 -> cond[0000] type[00] supp[00] op[1000] Rd[00001] Rh[00000] Ro[01100] pad[00000] (Mov sem imediato)
00000000101000000000000000100000 -> cond[0000] type[00] supp[00] op[1010] Rd[00000] Rh[00000] Ro[00001] pad[00000] (Out sem imediato)
00000010000111110111110000000001 -> cond[0000] type[00] supp[10] op[0001] Rd[11110] Rh[11111] imm[1=1]->[0000000001]
00000100000101101000001111000000 -> cond[0000] type[01] supp[00] op[0001] Rd[01101] Rh[00000] Ro[11110] pad[00000] (Load sem imediato)
00000010100001110000000000000000 -> cond[0000] type[00] supp[10] op[1000] Rd[01110] Rh[00000] imm[0=0]->[0000000000]
00000001000100000011010111000000 -> cond[0000] type[00] supp[01] op[0001] Rd[00000] Rh[01101] Ro[01110] pad[00000]
00101110000000000000000000000010 -> cond[0010] type[11] supp[10] op[0000] offset_calc[(20 - 18) = 2]->bin[00000000000000000010]
00001110000000000000000000001000 -> cond[0000] type[11] supp[10] op[0000] offset_calc[(27 - 19) = 8]->bin[00000000000000001000]
00001110000000000000000000000000 -> cond[0000] type[11] supp[10] op[0000] offset_calc[(20 - 20) = 0]->bin[00000000000000000000]
00000010000111110111110000000001 -> cond[0000] type[00] supp[10] op[0001] Rd[11110] Rh[11111] imm[1=1]->[0000000001]
00000100000101111000001111000000 -> cond[0000] type[01] supp[00] op[0001] Rd[01111] Rh[00000] Ro[11110] pad[00000] (Load sem imediato)
00000010000110000011110000000001 -> cond[0000] type[00] supp[10] op[0001] Rd[10000] Rh[01111] imm[1=1]->[0000000001]
00000000100000001000001000000000 -> cond[0000] type[00] supp[00] op[1000] Rd[00001] Rh[00000] Ro[10000] pad[00000] (Mov sem imediato)
00000010100011100000000000011010 -> cond[0000] type[00] supp[10] op[1000] Rd[11100] Rh[00000] imm[count_Lret0=26]->[0000011010]
00001110100011111111111111100111 -> cond[0000] type[11] supp[10] op[1000] offset_calc[(1 - 26) = -25]->bin[11111111111111100111]
00001110000000000000000000000000 -> cond[0000] type[11] supp[10] op[0000] offset_calc[(27 - 27) = 0]->bin[00000000000000000000]
00000000100011101000001111100000 -> cond[0000] type[00] supp[00] op[1000] Rd[11101] Rh[00000] Ro[11111] pad[00000] (Mov sem imediato)
00000100000111111000001110100000 -> cond[0000] type[01] supp[00] op[0001] Rd[11111] Rh[00000] Ro[11101] pad[00000] (Load sem imediato)
00000010000011101111010000000001 -> cond[0000] type[00] supp[10] op[0000] Rd[11101] Rh[11101] imm[1=1]->[0000000001]
00000100000111100000001110100000 -> cond[0000] type[01] supp[00] op[0001] Rd[11100] Rh[00000] Ro[11101] pad[00000] (Load sem imediato)
00000010000011101111010000000001 -> cond[0000] type[00] supp[10] op[0000] Rd[11101] Rh[11101] imm[1=1]->[0000000001]
00001100000000000000001110000000 -> cond[0000] type[11] supp[00] op[0000] reg_target[r28]->bin[00000000001110000000]
00000010100011101000000000101110 -> cond[0000] type[00] supp[10] op[1000] Rd[11101] Rh[00000] imm[stack_space=46]->[0000101110]
00000000100011111000001110100000 -> cond[0000] type[00] supp[00] op[1000] Rd[11111] Rh[00000] Ro[11101] pad[00000] (Mov sem imediato)
00000010000111101111010000000010 -> cond[0000] type[00] supp[10] op[0001] Rd[11101] Rh[11101] imm[2=2]->[0000000010]
00000000100101100000000000000000 -> cond[0000] type[00] supp[00] op[1001] Rd[01100] Rh[00000] Ro[00000] pad[00000]
00000010100001101000000010000000 -> cond[0000] type[00] supp[10] op[1000] Rd[01101] Rh[00000] imm[128=128]->[0010000000]
00000100000000000011000110100000 -> cond[0000] type[01] supp[00] op[0000] Rd[00000] Rh[01100] Ro[01101] pad[00000] (Store sem imediato)
00000010100001111000000010000000 -> cond[0000] type[00] supp[10] op[1000] Rd[01111] Rh[00000] imm[128=128]->[0010000000]
00000100000101110000000111100000 -> cond[0000] type[01] supp[00] op[0001] Rd[01110] Rh[00000] Ro[01111] pad[00000] (Load sem imediato)
00000000100000001000000111000000 -> cond[0000] type[00] supp[00] op[1000] Rd[00001] Rh[00000] Ro[01110] pad[00000] (Mov sem imediato)
00000010100011100000000000101100 -> cond[0000] type[00] supp[10] op[1000] Rd[11100] Rh[00000] imm[main_Lret0=44]->[0000101100]
00001110100011111111111111010101 -> cond[0000] type[11] supp[10] op[1000] offset_calc[(1 - 44) = -43]->bin[11111111111111010101]
00001110000000000000000000000000 -> cond[0000] type[11] supp[10] op[0000] offset_calc[(45 - 45) = 0]->bin[00000000000000000000]
00001100111111111111111111111111 -> cond[0000] type[11] supp[00] op[1111] operand[-1]

Código de máquina gerado com sucesso em: docs/output/generated_machine_code.txt

--- Iniciando a Decodificação do Código de Máquina ---
--- Decodificação Concluída ---
--- MACHINE CODE DECODED ---
