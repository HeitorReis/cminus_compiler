

=== INICIANDO GERAÇÃO DE ASSEMBLY ===

--- Passagem 1: Coletando funções e variáveis globais do IR ---
[Passagem 1] Variável global encontrada: 'minloc' na linha 1
[Passagem 1] Função encontrada: 'minloc'
[ALLOC_INIT] Inicializando alocador para a função 'minloc'
[ALLOC_INIT] Pool de registradores definido: ['r12', 'r13', 'r14', 'r15', 'r16', 'r17', 'r18', 'r19', 'r20', 'r21', 'r22', 'r23', 'r24', 'r25', 'r26', 'r4', 'r5', 'r6', 'r7', 'r8', 'r9', 'r10', 'r11']
[ALLOC_INIT] Registrador de spill reservado: r30
[ALLOC_INIT] Estado inicial: 23 registradores livres.
[FUNC_CTX] Contexto para a função 'minloc' criado.
[Passagem 1] Variável global encontrada: 'low' na linha 2
[Passagem 1] Variável global encontrada: 'k' na linha 3
[Passagem 1] Variável global encontrada: 'a' na linha 6
[Passagem 1] Variável global encontrada: 'x' na linha 9
[Passagem 1] Variável global encontrada: 'i' na linha 12
[Passagem 1] Variável global encontrada: 'high' na linha 15
[Passagem 1] Variável global encontrada: '_' na linha 44
[Passagem 1] Variável global encontrada: 'sort' na linha 45
[Passagem 1] Função encontrada: 'sort'
[ALLOC_INIT] Inicializando alocador para a função 'sort'
[ALLOC_INIT] Pool de registradores definido: ['r12', 'r13', 'r14', 'r15', 'r16', 'r17', 'r18', 'r19', 'r20', 'r21', 'r22', 'r23', 'r24', 'r25', 'r26', 'r4', 'r5', 'r6', 'r7', 'r8', 'r9', 'r10', 'r11']
[ALLOC_INIT] Registrador de spill reservado: r30
[ALLOC_INIT] Estado inicial: 23 registradores livres.
[FUNC_CTX] Contexto para a função 'sort' criado.
[Passagem 1] Variável global encontrada: 't' na linha 67
[Passagem 1] Variável global encontrada: 'main' na linha 90
[Passagem 1] Função encontrada: 'main'
[ALLOC_INIT] Inicializando alocador para a função 'main'
[ALLOC_INIT] Pool de registradores definido: ['r12', 'r13', 'r14', 'r15', 'r16', 'r17', 'r18', 'r19', 'r20', 'r21', 'r22', 'r23', 'r24', 'r25', 'r26', 'r4', 'r5', 'r6', 'r7', 'r8', 'r9', 'r10', 'r11']
[ALLOC_INIT] Registrador de spill reservado: r30
[ALLOC_INIT] Estado inicial: 23 registradores livres.
[FUNC_CTX] Contexto para a função 'main' criado.
[Passagem 1] Variável global encontrada: 'vet' na linha 99
--- Fim da Passagem 1: 3 funções e 12 variáveis encontradas. ---

--- Passagem 2: Traduzindo o IR para cada função ---

[Processando Função] -> 'minloc'
-> IR isolado para 'minloc' contém 43 instruções.

--- [TRANSLATE] Processando IR: t0 := *low ---
[TRANSLATE] -> Detalhes: Destino='t0', Expressão='*low'
[TRANSLATE] -> Caminho: Carregar de Ponteiro (*)
[ENSURE] Tentando garantir 'low' em um registrador.
[ENSURE] -> Variável 'low' não está em um registrador. Carregando da memória.
[GET_FREE] -> Encontrado registrador livre: r12. Restantes: 22.
[GET_FREE] -> Encontrado registrador livre: r13. Restantes: 21.
[ADD_INSTR] Adicionando instrução para 'minloc': movi: r13 = 35
[ENSURE] -> Usando r12 para o valor e r13 para o endereço 35.
[ADD_INSTR] Adicionando instrução para 'minloc': load: r12 = [r13]
[ASSIGN_REG] Mapeando 'low' para r12.
[UNASSIGN_REG] r13 já estava desmapeado.
[UNASSIGN_REG] -> Estado atual: 22 registradores livres. Mapeamentos: {'low': 'r12'}
[UPDATE_MAP] Mapeando 't0' para o registrador r12 (que contém o valor de origem).
[ASSIGN_REG] Mapeando 't0' para r12.
[ASSIGN_REG] -> Registrador r12 já continha 'low'. Liberando o mapeamento antigo.
[UNASSIGN_REG] Desmapeado r12 de 'low'.
[UNASSIGN_REG] -> Estado atual: 23 registradores livres. Mapeamentos: {}
[TRANSLATE] -> Valor de 'low' agora em r12, mapeado para 't0'.

--- [TRANSLATE] Processando IR: *k := t0 ---
[TRANSLATE] -> Detalhes: Destino='*k', Expressão='t0'
[TRANSLATE] -> Caminho: Armazenar em Ponteiro (*)
[ENSURE] Tentando garantir 't0' em um registrador.
[ENSURE] -> Sucesso! 't0' já está em r12.
[TRANSLATE] -> Endereço de destino é uma variável real. Obtendo endereço em registrador.
[GET_ADDR] Obtendo endereço para 'k'.
[GET_FREE] -> Encontrado registrador livre: r14. Restantes: 22.
[ADD_INSTR] Adicionando instrução para 'minloc': movi: r14 = 38
[GET_ADDR] -> Endereço de 'k' (38) carregado em r14.
[ADD_INSTR] Adicionando instrução para 'minloc': store: [r14] = r12
[FREE_TEMP] Liberando registrador r12 que continha o temporário 't0'.
[UNASSIGN_REG] Desmapeado r12 de 't0'.
[UNASSIGN_REG] -> Estado atual: 22 registradores livres. Mapeamentos: {}
[UNASSIGN_REG] r14 já estava desmapeado.
[UNASSIGN_REG] -> Estado atual: 23 registradores livres. Mapeamentos: {}

--- [TRANSLATE] Processando IR: t1 := *low ---
[TRANSLATE] -> Detalhes: Destino='t1', Expressão='*low'
[TRANSLATE] -> Caminho: Carregar de Ponteiro (*)
[ENSURE] Tentando garantir 'low' em um registrador.
[ENSURE] -> Variável 'low' não está em um registrador. Carregando da memória.
[GET_FREE] -> Encontrado registrador livre: r15. Restantes: 22.
[GET_FREE] -> Encontrado registrador livre: r16. Restantes: 21.
[ADD_INSTR] Adicionando instrução para 'minloc': movi: r16 = 35
[ENSURE] -> Usando r15 para o valor e r16 para o endereço 35.
[ADD_INSTR] Adicionando instrução para 'minloc': load: r15 = [r16]
[ASSIGN_REG] Mapeando 'low' para r15.
[UNASSIGN_REG] r16 já estava desmapeado.
[UNASSIGN_REG] -> Estado atual: 22 registradores livres. Mapeamentos: {'low': 'r15'}
[UPDATE_MAP] Mapeando 't1' para o registrador r15 (que contém o valor de origem).
[ASSIGN_REG] Mapeando 't1' para r15.
[ASSIGN_REG] -> Registrador r15 já continha 'low'. Liberando o mapeamento antigo.
[UNASSIGN_REG] Desmapeado r15 de 'low'.
[UNASSIGN_REG] -> Estado atual: 23 registradores livres. Mapeamentos: {}
[TRANSLATE] -> Valor de 'low' agora em r15, mapeado para 't1'.

--- [TRANSLATE] Processando IR: t2 := t1 * 4 ---
[TRANSLATE] -> Detalhes: Destino='t2', Expressão='t1 * 4'
[TRANSLATE] -> Caminho: Operação Aritmética
[ENSURE] Tentando garantir 't1' em um registrador.
[ENSURE] -> Sucesso! 't1' já está em r15.
[TRANSLATE] -> Operando 2 é um imediato: 4
[GET_TEMP] Solicitando registrador para o temporário 't2'.
[GET_FREE] -> Encontrado registrador livre: r17. Restantes: 22.
[ASSIGN_REG] Mapeando 't2' para r17.
[GET_TEMP] -> 't2' alocado no registrador r17.
[ADD_INSTR] Adicionando instrução para 'minloc': muli: r17 = r15, 4

--- [TRANSLATE] Processando IR: t3 := &a ---
[TRANSLATE] -> Detalhes: Destino='t3', Expressão='&a'
[TRANSLATE] -> Caminho: Obter Endereço (&)
[GET_TEMP] Solicitando registrador para o temporário 't3'.
[GET_FREE] -> Encontrado registrador livre: r18. Restantes: 21.
[ASSIGN_REG] Mapeando 't3' para r18.
[GET_TEMP] -> 't3' alocado no registrador r18.
[ADD_INSTR] Adicionando instrução para 'minloc': movi: r18 = 33

--- [TRANSLATE] Processando IR: t4 := t3 + t2 ---
[TRANSLATE] -> Detalhes: Destino='t4', Expressão='t3 + t2'
[TRANSLATE] -> Caminho: Operação Aritmética
[ENSURE] Tentando garantir 't3' em um registrador.
[ENSURE] -> Sucesso! 't3' já está em r18.
[ENSURE] Tentando garantir 't2' em um registrador.
[ENSURE] -> Sucesso! 't2' já está em r17.
[GET_TEMP] Solicitando registrador para o temporário 't4'.
[GET_FREE] -> Encontrado registrador livre: r19. Restantes: 20.
[ASSIGN_REG] Mapeando 't4' para r19.
[GET_TEMP] -> 't4' alocado no registrador r19.
[ADD_INSTR] Adicionando instrução para 'minloc': add: r19 = r18, r17

--- [TRANSLATE] Processando IR: t5 := *t4 ---
[TRANSLATE] -> Detalhes: Destino='t5', Expressão='*t4'
[TRANSLATE] -> Caminho: Carregar de Ponteiro (*)
[ENSURE] Tentando garantir 't4' em um registrador.
[ENSURE] -> Sucesso! 't4' já está em r19.
[UPDATE_MAP] Mapeando 't5' para o registrador r19 (que contém o valor de origem).
[ASSIGN_REG] Mapeando 't5' para r19.
[ASSIGN_REG] -> Registrador r19 já continha 't4'. Liberando o mapeamento antigo.
[UNASSIGN_REG] Desmapeado r19 de 't4'.
[UNASSIGN_REG] -> Estado atual: 21 registradores livres. Mapeamentos: {'t1': 'r15', 't2': 'r17', 't3': 'r18'}
[TRANSLATE] -> Valor de 't4' agora em r19, mapeado para 't5'.

--- [TRANSLATE] Processando IR: *x := t5 ---
[TRANSLATE] -> Detalhes: Destino='*x', Expressão='t5'
[TRANSLATE] -> Caminho: Armazenar em Ponteiro (*)
[ENSURE] Tentando garantir 't5' em um registrador.
[ENSURE] -> Sucesso! 't5' já está em r19.
[TRANSLATE] -> Endereço de destino é uma variável real. Obtendo endereço em registrador.
[GET_ADDR] Obtendo endereço para 'x'.
[GET_FREE] -> Encontrado registrador livre: r20. Restantes: 20.
[ADD_INSTR] Adicionando instrução para 'minloc': movi: r20 = 36
[GET_ADDR] -> Endereço de 'x' (36) carregado em r20.
[ADD_INSTR] Adicionando instrução para 'minloc': store: [r20] = r19
[FREE_TEMP] Liberando registrador r19 que continha o temporário 't5'.
[UNASSIGN_REG] Desmapeado r19 de 't5'.
[UNASSIGN_REG] -> Estado atual: 20 registradores livres. Mapeamentos: {'t1': 'r15', 't2': 'r17', 't3': 'r18'}
[UNASSIGN_REG] r20 já estava desmapeado.
[UNASSIGN_REG] -> Estado atual: 21 registradores livres. Mapeamentos: {'t1': 'r15', 't2': 'r17', 't3': 'r18'}

--- [TRANSLATE] Processando IR: t6 := *low ---
[TRANSLATE] -> Detalhes: Destino='t6', Expressão='*low'
[TRANSLATE] -> Caminho: Carregar de Ponteiro (*)
[ENSURE] Tentando garantir 'low' em um registrador.
[ENSURE] -> Variável 'low' não está em um registrador. Carregando da memória.
[GET_FREE] -> Encontrado registrador livre: r21. Restantes: 20.
[GET_FREE] -> Encontrado registrador livre: r22. Restantes: 19.
[ADD_INSTR] Adicionando instrução para 'minloc': movi: r22 = 35
[ENSURE] -> Usando r21 para o valor e r22 para o endereço 35.
[ADD_INSTR] Adicionando instrução para 'minloc': load: r21 = [r22]
[ASSIGN_REG] Mapeando 'low' para r21.
[UNASSIGN_REG] r22 já estava desmapeado.
[UNASSIGN_REG] -> Estado atual: 20 registradores livres. Mapeamentos: {'t1': 'r15', 't2': 'r17', 't3': 'r18', 'low': 'r21'}
[UPDATE_MAP] Mapeando 't6' para o registrador r21 (que contém o valor de origem).
[ASSIGN_REG] Mapeando 't6' para r21.
[ASSIGN_REG] -> Registrador r21 já continha 'low'. Liberando o mapeamento antigo.
[UNASSIGN_REG] Desmapeado r21 de 'low'.
[UNASSIGN_REG] -> Estado atual: 21 registradores livres. Mapeamentos: {'t1': 'r15', 't2': 'r17', 't3': 'r18'}
[TRANSLATE] -> Valor de 'low' agora em r21, mapeado para 't6'.

--- [TRANSLATE] Processando IR: t7 := t6 + 1 ---
[TRANSLATE] -> Detalhes: Destino='t7', Expressão='t6 + 1'
[TRANSLATE] -> Caminho: Operação Aritmética
[ENSURE] Tentando garantir 't6' em um registrador.
[ENSURE] -> Sucesso! 't6' já está em r21.
[TRANSLATE] -> Operando 2 é um imediato: 1
[GET_TEMP] Solicitando registrador para o temporário 't7'.
[GET_FREE] -> Encontrado registrador livre: r23. Restantes: 20.
[ASSIGN_REG] Mapeando 't7' para r23.
[GET_TEMP] -> 't7' alocado no registrador r23.
[ADD_INSTR] Adicionando instrução para 'minloc': addi: r23 = r21, 1

--- [TRANSLATE] Processando IR: *i := t7 ---
[TRANSLATE] -> Detalhes: Destino='*i', Expressão='t7'
[TRANSLATE] -> Caminho: Armazenar em Ponteiro (*)
[ENSURE] Tentando garantir 't7' em um registrador.
[ENSURE] -> Sucesso! 't7' já está em r23.
[TRANSLATE] -> Endereço de destino é uma variável real. Obtendo endereço em registrador.
[GET_ADDR] Obtendo endereço para 'i'.
[GET_FREE] -> Encontrado registrador livre: r24. Restantes: 19.
[ADD_INSTR] Adicionando instrução para 'minloc': movi: r24 = 39
[GET_ADDR] -> Endereço de 'i' (39) carregado em r24.
[ADD_INSTR] Adicionando instrução para 'minloc': store: [r24] = r23
[FREE_TEMP] Liberando registrador r23 que continha o temporário 't7'.
[UNASSIGN_REG] Desmapeado r23 de 't7'.
[UNASSIGN_REG] -> Estado atual: 20 registradores livres. Mapeamentos: {'t1': 'r15', 't2': 'r17', 't3': 'r18', 't6': 'r21'}
[UNASSIGN_REG] r24 já estava desmapeado.
[UNASSIGN_REG] -> Estado atual: 21 registradores livres. Mapeamentos: {'t1': 'r15', 't2': 'r17', 't3': 'r18', 't6': 'r21'}

--- [TRANSLATE] Processando IR: L0: ---
[TRANSLATE] -> Rótulo detectado: L0:
[SPILL_ALL] Verificando registradores sujos para salvar antes da chamada de função. Sujos: {'r23', 'r17', 'r18', 'r19'}
[ADD_INSTR] Adicionando instrução para 'minloc': L0:

--- [TRANSLATE] Processando IR: t8 := *i ---
[TRANSLATE] -> Detalhes: Destino='t8', Expressão='*i'
[TRANSLATE] -> Caminho: Carregar de Ponteiro (*)
[ENSURE] Tentando garantir 'i' em um registrador.
[ENSURE] -> Variável 'i' não está em um registrador. Carregando da memória.
[GET_FREE] -> Encontrado registrador livre: r25. Restantes: 20.
[GET_FREE] -> Encontrado registrador livre: r26. Restantes: 19.
[ADD_INSTR] Adicionando instrução para 'minloc': movi: r26 = 39
[ENSURE] -> Usando r25 para o valor e r26 para o endereço 39.
[ADD_INSTR] Adicionando instrução para 'minloc': load: r25 = [r26]
[ASSIGN_REG] Mapeando 'i' para r25.
[UNASSIGN_REG] r26 já estava desmapeado.
[UNASSIGN_REG] -> Estado atual: 20 registradores livres. Mapeamentos: {'t1': 'r15', 't2': 'r17', 't3': 'r18', 't6': 'r21', 'i': 'r25'}
[UPDATE_MAP] Mapeando 't8' para o registrador r25 (que contém o valor de origem).
[ASSIGN_REG] Mapeando 't8' para r25.
[ASSIGN_REG] -> Registrador r25 já continha 'i'. Liberando o mapeamento antigo.
[UNASSIGN_REG] Desmapeado r25 de 'i'.
[UNASSIGN_REG] -> Estado atual: 21 registradores livres. Mapeamentos: {'t1': 'r15', 't2': 'r17', 't3': 'r18', 't6': 'r21'}
[TRANSLATE] -> Valor de 'i' agora em r25, mapeado para 't8'.

--- [TRANSLATE] Processando IR: t9 := *high ---
[TRANSLATE] -> Detalhes: Destino='t9', Expressão='*high'
[TRANSLATE] -> Caminho: Carregar de Ponteiro (*)
[ENSURE] Tentando garantir 'high' em um registrador.
[ENSURE] -> Variável 'high' não está em um registrador. Carregando da memória.
[GET_FREE] -> Encontrado registrador livre: r4. Restantes: 20.
[GET_FREE] -> Encontrado registrador livre: r5. Restantes: 19.
[ADD_INSTR] Adicionando instrução para 'minloc': movi: r5 = 40
[ENSURE] -> Usando r4 para o valor e r5 para o endereço 40.
[ADD_INSTR] Adicionando instrução para 'minloc': load: r4 = [r5]
[ASSIGN_REG] Mapeando 'high' para r4.
[UNASSIGN_REG] r5 já estava desmapeado.
[UNASSIGN_REG] -> Estado atual: 20 registradores livres. Mapeamentos: {'t1': 'r15', 't2': 'r17', 't3': 'r18', 't6': 'r21', 't8': 'r25', 'high': 'r4'}
[UPDATE_MAP] Mapeando 't9' para o registrador r4 (que contém o valor de origem).
[ASSIGN_REG] Mapeando 't9' para r4.
[ASSIGN_REG] -> Registrador r4 já continha 'high'. Liberando o mapeamento antigo.
[UNASSIGN_REG] Desmapeado r4 de 'high'.
[UNASSIGN_REG] -> Estado atual: 21 registradores livres. Mapeamentos: {'t1': 'r15', 't2': 'r17', 't3': 'r18', 't6': 'r21', 't8': 'r25'}
[TRANSLATE] -> Valor de 'high' agora em r4, mapeado para 't9'.

--- [TRANSLATE] Processando IR: t10 := t8 < t9 ---
[TRANSLATE] -> Detalhes: Destino='t10', Expressão='t8 < t9'
[TRANSLATE] -> Caminho: Comparação (condicional)
[ENSURE] Tentando garantir 't8' em um registrador.
[ENSURE] -> Sucesso! 't8' já está em r25.
[ENSURE] Tentando garantir 't9' em um registrador.
[ENSURE] -> Sucesso! 't9' já está em r4.
[ADD_INSTR] Adicionando instrução para 'minloc': subs: r0 = r25, r4

--- [TRANSLATE] Processando IR: if_false t10 goto L1 ---
[TRANSLATE] -> Caminho: Desvio Condicional (if_false)
[ADD_INSTR] Adicionando instrução para 'minloc': bigteq: L1

--- [TRANSLATE] Processando IR: t11 := *i ---
[TRANSLATE] -> Detalhes: Destino='t11', Expressão='*i'
[TRANSLATE] -> Caminho: Carregar de Ponteiro (*)
[ENSURE] Tentando garantir 'i' em um registrador.
[ENSURE] -> Variável 'i' não está em um registrador. Carregando da memória.
[GET_FREE] -> Encontrado registrador livre: r6. Restantes: 20.
[GET_FREE] -> Encontrado registrador livre: r7. Restantes: 19.
[ADD_INSTR] Adicionando instrução para 'minloc': movi: r7 = 39
[ENSURE] -> Usando r6 para o valor e r7 para o endereço 39.
[ADD_INSTR] Adicionando instrução para 'minloc': load: r6 = [r7]
[ASSIGN_REG] Mapeando 'i' para r6.
[UNASSIGN_REG] r7 já estava desmapeado.
[UNASSIGN_REG] -> Estado atual: 20 registradores livres. Mapeamentos: {'t1': 'r15', 't2': 'r17', 't3': 'r18', 't6': 'r21', 't8': 'r25', 't9': 'r4', 'i': 'r6'}
[UPDATE_MAP] Mapeando 't11' para o registrador r6 (que contém o valor de origem).
[ASSIGN_REG] Mapeando 't11' para r6.
[ASSIGN_REG] -> Registrador r6 já continha 'i'. Liberando o mapeamento antigo.
[UNASSIGN_REG] Desmapeado r6 de 'i'.
[UNASSIGN_REG] -> Estado atual: 21 registradores livres. Mapeamentos: {'t1': 'r15', 't2': 'r17', 't3': 'r18', 't6': 'r21', 't8': 'r25', 't9': 'r4'}
[TRANSLATE] -> Valor de 'i' agora em r6, mapeado para 't11'.

--- [TRANSLATE] Processando IR: t12 := t11 * 4 ---
[TRANSLATE] -> Detalhes: Destino='t12', Expressão='t11 * 4'
[TRANSLATE] -> Caminho: Operação Aritmética
[ENSURE] Tentando garantir 't11' em um registrador.
[ENSURE] -> Sucesso! 't11' já está em r6.
[TRANSLATE] -> Operando 2 é um imediato: 4
[GET_TEMP] Solicitando registrador para o temporário 't12'.
[GET_FREE] -> Encontrado registrador livre: r8. Restantes: 20.
[ASSIGN_REG] Mapeando 't12' para r8.
[GET_TEMP] -> 't12' alocado no registrador r8.
[ADD_INSTR] Adicionando instrução para 'minloc': muli: r8 = r6, 4

--- [TRANSLATE] Processando IR: t13 := &a ---
[TRANSLATE] -> Detalhes: Destino='t13', Expressão='&a'
[TRANSLATE] -> Caminho: Obter Endereço (&)
[GET_TEMP] Solicitando registrador para o temporário 't13'.
[GET_FREE] -> Encontrado registrador livre: r9. Restantes: 19.
[ASSIGN_REG] Mapeando 't13' para r9.
[GET_TEMP] -> 't13' alocado no registrador r9.
[ADD_INSTR] Adicionando instrução para 'minloc': movi: r9 = 33

--- [TRANSLATE] Processando IR: t14 := t13 + t12 ---
[TRANSLATE] -> Detalhes: Destino='t14', Expressão='t13 + t12'
[TRANSLATE] -> Caminho: Operação Aritmética
[ENSURE] Tentando garantir 't13' em um registrador.
[ENSURE] -> Sucesso! 't13' já está em r9.
[ENSURE] Tentando garantir 't12' em um registrador.
[ENSURE] -> Sucesso! 't12' já está em r8.
[GET_TEMP] Solicitando registrador para o temporário 't14'.
[GET_FREE] -> Encontrado registrador livre: r10. Restantes: 18.
[ASSIGN_REG] Mapeando 't14' para r10.
[GET_TEMP] -> 't14' alocado no registrador r10.
[ADD_INSTR] Adicionando instrução para 'minloc': add: r10 = r9, r8

--- [TRANSLATE] Processando IR: t15 := *t14 ---
[TRANSLATE] -> Detalhes: Destino='t15', Expressão='*t14'
[TRANSLATE] -> Caminho: Carregar de Ponteiro (*)
[ENSURE] Tentando garantir 't14' em um registrador.
[ENSURE] -> Sucesso! 't14' já está em r10.
[UPDATE_MAP] Mapeando 't15' para o registrador r10 (que contém o valor de origem).
[ASSIGN_REG] Mapeando 't15' para r10.
[ASSIGN_REG] -> Registrador r10 já continha 't14'. Liberando o mapeamento antigo.
[UNASSIGN_REG] Desmapeado r10 de 't14'.
[UNASSIGN_REG] -> Estado atual: 19 registradores livres. Mapeamentos: {'t1': 'r15', 't2': 'r17', 't3': 'r18', 't6': 'r21', 't8': 'r25', 't9': 'r4', 't11': 'r6', 't12': 'r8', 't13': 'r9'}
[TRANSLATE] -> Valor de 't14' agora em r10, mapeado para 't15'.

--- [TRANSLATE] Processando IR: t16 := *x ---
[TRANSLATE] -> Detalhes: Destino='t16', Expressão='*x'
[TRANSLATE] -> Caminho: Carregar de Ponteiro (*)
[ENSURE] Tentando garantir 'x' em um registrador.
[ENSURE] -> Variável 'x' não está em um registrador. Carregando da memória.
[GET_FREE] -> Encontrado registrador livre: r11. Restantes: 18.
[GET_FREE] -> Encontrado registrador livre: r13. Restantes: 17.
[ADD_INSTR] Adicionando instrução para 'minloc': movi: r13 = 36
[ENSURE] -> Usando r11 para o valor e r13 para o endereço 36.
[ADD_INSTR] Adicionando instrução para 'minloc': load: r11 = [r13]
[ASSIGN_REG] Mapeando 'x' para r11.
[UNASSIGN_REG] r13 já estava desmapeado.
[UNASSIGN_REG] -> Estado atual: 18 registradores livres. Mapeamentos: {'t1': 'r15', 't2': 'r17', 't3': 'r18', 't6': 'r21', 't8': 'r25', 't9': 'r4', 't11': 'r6', 't12': 'r8', 't13': 'r9', 't15': 'r10', 'x': 'r11'}
[UPDATE_MAP] Mapeando 't16' para o registrador r11 (que contém o valor de origem).
[ASSIGN_REG] Mapeando 't16' para r11.
[ASSIGN_REG] -> Registrador r11 já continha 'x'. Liberando o mapeamento antigo.
[UNASSIGN_REG] Desmapeado r11 de 'x'.
[UNASSIGN_REG] -> Estado atual: 19 registradores livres. Mapeamentos: {'t1': 'r15', 't2': 'r17', 't3': 'r18', 't6': 'r21', 't8': 'r25', 't9': 'r4', 't11': 'r6', 't12': 'r8', 't13': 'r9', 't15': 'r10'}
[TRANSLATE] -> Valor de 'x' agora em r11, mapeado para 't16'.

--- [TRANSLATE] Processando IR: t17 := t15 < t16 ---
[TRANSLATE] -> Detalhes: Destino='t17', Expressão='t15 < t16'
[TRANSLATE] -> Caminho: Comparação (condicional)
[ENSURE] Tentando garantir 't15' em um registrador.
[ENSURE] -> Sucesso! 't15' já está em r10.
[ENSURE] Tentando garantir 't16' em um registrador.
[ENSURE] -> Sucesso! 't16' já está em r11.
[ADD_INSTR] Adicionando instrução para 'minloc': subs: r0 = r10, r11

--- [TRANSLATE] Processando IR: if_false t17 goto L2 ---
[TRANSLATE] -> Caminho: Desvio Condicional (if_false)
[ADD_INSTR] Adicionando instrução para 'minloc': bigteq: L2

--- [TRANSLATE] Processando IR: t18 := *i ---
[TRANSLATE] -> Detalhes: Destino='t18', Expressão='*i'
[TRANSLATE] -> Caminho: Carregar de Ponteiro (*)
[ENSURE] Tentando garantir 'i' em um registrador.
[ENSURE] -> Variável 'i' não está em um registrador. Carregando da memória.
[GET_FREE] -> Encontrado registrador livre: r12. Restantes: 18.
[GET_FREE] -> Encontrado registrador livre: r14. Restantes: 17.
[ADD_INSTR] Adicionando instrução para 'minloc': movi: r14 = 39
[ENSURE] -> Usando r12 para o valor e r14 para o endereço 39.
[ADD_INSTR] Adicionando instrução para 'minloc': load: r12 = [r14]
[ASSIGN_REG] Mapeando 'i' para r12.
[UNASSIGN_REG] r14 já estava desmapeado.
[UNASSIGN_REG] -> Estado atual: 18 registradores livres. Mapeamentos: {'t1': 'r15', 't2': 'r17', 't3': 'r18', 't6': 'r21', 't8': 'r25', 't9': 'r4', 't11': 'r6', 't12': 'r8', 't13': 'r9', 't15': 'r10', 't16': 'r11', 'i': 'r12'}
[UPDATE_MAP] Mapeando 't18' para o registrador r12 (que contém o valor de origem).
[ASSIGN_REG] Mapeando 't18' para r12.
[ASSIGN_REG] -> Registrador r12 já continha 'i'. Liberando o mapeamento antigo.
[UNASSIGN_REG] Desmapeado r12 de 'i'.
[UNASSIGN_REG] -> Estado atual: 19 registradores livres. Mapeamentos: {'t1': 'r15', 't2': 'r17', 't3': 'r18', 't6': 'r21', 't8': 'r25', 't9': 'r4', 't11': 'r6', 't12': 'r8', 't13': 'r9', 't15': 'r10', 't16': 'r11'}
[TRANSLATE] -> Valor de 'i' agora em r12, mapeado para 't18'.

--- [TRANSLATE] Processando IR: t19 := t18 * 4 ---
[TRANSLATE] -> Detalhes: Destino='t19', Expressão='t18 * 4'
[TRANSLATE] -> Caminho: Operação Aritmética
[ENSURE] Tentando garantir 't18' em um registrador.
[ENSURE] -> Sucesso! 't18' já está em r12.
[TRANSLATE] -> Operando 2 é um imediato: 4
[GET_TEMP] Solicitando registrador para o temporário 't19'.
[GET_FREE] -> Encontrado registrador livre: r16. Restantes: 18.
[ASSIGN_REG] Mapeando 't19' para r16.
[GET_TEMP] -> 't19' alocado no registrador r16.
[ADD_INSTR] Adicionando instrução para 'minloc': muli: r16 = r12, 4

--- [TRANSLATE] Processando IR: t20 := &a ---
[TRANSLATE] -> Detalhes: Destino='t20', Expressão='&a'
[TRANSLATE] -> Caminho: Obter Endereço (&)
[GET_TEMP] Solicitando registrador para o temporário 't20'.
[GET_FREE] -> Encontrado registrador livre: r15. Restantes: 17.
[ASSIGN_REG] Mapeando 't20' para r15.
[ASSIGN_REG] -> Registrador r15 já continha 't1'. Liberando o mapeamento antigo.
[UNASSIGN_REG] Desmapeado r15 de 't1'.
[UNASSIGN_REG] -> Estado atual: 18 registradores livres. Mapeamentos: {'t2': 'r17', 't3': 'r18', 't6': 'r21', 't8': 'r25', 't9': 'r4', 't11': 'r6', 't12': 'r8', 't13': 'r9', 't15': 'r10', 't16': 'r11', 't18': 'r12', 't19': 'r16'}
[GET_TEMP] -> 't20' alocado no registrador r15.
[ADD_INSTR] Adicionando instrução para 'minloc': movi: r15 = 33

--- [TRANSLATE] Processando IR: t21 := t20 + t19 ---
[TRANSLATE] -> Detalhes: Destino='t21', Expressão='t20 + t19'
[TRANSLATE] -> Caminho: Operação Aritmética
[ENSURE] Tentando garantir 't20' em um registrador.
[ENSURE] -> Sucesso! 't20' já está em r15.
[ENSURE] Tentando garantir 't19' em um registrador.
[ENSURE] -> Sucesso! 't19' já está em r16.
[GET_TEMP] Solicitando registrador para o temporário 't21'.
[GET_FREE] -> Encontrado registrador livre: r19. Restantes: 17.
[ASSIGN_REG] Mapeando 't21' para r19.
[GET_TEMP] -> 't21' alocado no registrador r19.
[ADD_INSTR] Adicionando instrução para 'minloc': add: r19 = r15, r16

--- [TRANSLATE] Processando IR: t22 := *t21 ---
[TRANSLATE] -> Detalhes: Destino='t22', Expressão='*t21'
[TRANSLATE] -> Caminho: Carregar de Ponteiro (*)
[ENSURE] Tentando garantir 't21' em um registrador.
[ENSURE] -> Sucesso! 't21' já está em r19.
[UPDATE_MAP] Mapeando 't22' para o registrador r19 (que contém o valor de origem).
[ASSIGN_REG] Mapeando 't22' para r19.
[ASSIGN_REG] -> Registrador r19 já continha 't21'. Liberando o mapeamento antigo.
[UNASSIGN_REG] Desmapeado r19 de 't21'.
[UNASSIGN_REG] -> Estado atual: 18 registradores livres. Mapeamentos: {'t2': 'r17', 't3': 'r18', 't6': 'r21', 't8': 'r25', 't9': 'r4', 't11': 'r6', 't12': 'r8', 't13': 'r9', 't15': 'r10', 't16': 'r11', 't18': 'r12', 't19': 'r16', 't20': 'r15'}
[TRANSLATE] -> Valor de 't21' agora em r19, mapeado para 't22'.

--- [TRANSLATE] Processando IR: *x := t22 ---
[TRANSLATE] -> Detalhes: Destino='*x', Expressão='t22'
[TRANSLATE] -> Caminho: Armazenar em Ponteiro (*)
[ENSURE] Tentando garantir 't22' em um registrador.
[ENSURE] -> Sucesso! 't22' já está em r19.
[TRANSLATE] -> Endereço de destino é uma variável real. Obtendo endereço em registrador.
[GET_ADDR] Obtendo endereço para 'x'.
[GET_FREE] -> Encontrado registrador livre: r20. Restantes: 17.
[ADD_INSTR] Adicionando instrução para 'minloc': movi: r20 = 36
[GET_ADDR] -> Endereço de 'x' (36) carregado em r20.
[ADD_INSTR] Adicionando instrução para 'minloc': store: [r20] = r19
[FREE_TEMP] Liberando registrador r19 que continha o temporário 't22'.
[UNASSIGN_REG] Desmapeado r19 de 't22'.
[UNASSIGN_REG] -> Estado atual: 17 registradores livres. Mapeamentos: {'t2': 'r17', 't3': 'r18', 't6': 'r21', 't8': 'r25', 't9': 'r4', 't11': 'r6', 't12': 'r8', 't13': 'r9', 't15': 'r10', 't16': 'r11', 't18': 'r12', 't19': 'r16', 't20': 'r15'}
[UNASSIGN_REG] r20 já estava desmapeado.
[UNASSIGN_REG] -> Estado atual: 18 registradores livres. Mapeamentos: {'t2': 'r17', 't3': 'r18', 't6': 'r21', 't8': 'r25', 't9': 'r4', 't11': 'r6', 't12': 'r8', 't13': 'r9', 't15': 'r10', 't16': 'r11', 't18': 'r12', 't19': 'r16', 't20': 'r15'}

--- [TRANSLATE] Processando IR: t23 := *i ---
[TRANSLATE] -> Detalhes: Destino='t23', Expressão='*i'
[TRANSLATE] -> Caminho: Carregar de Ponteiro (*)
[ENSURE] Tentando garantir 'i' em um registrador.
[ENSURE] -> Variável 'i' não está em um registrador. Carregando da memória.
[GET_FREE] -> Encontrado registrador livre: r22. Restantes: 17.
[GET_FREE] -> Encontrado registrador livre: r21. Restantes: 16.
[ADD_INSTR] Adicionando instrução para 'minloc': movi: r21 = 39
[ENSURE] -> Usando r22 para o valor e r21 para o endereço 39.
[ADD_INSTR] Adicionando instrução para 'minloc': load: r22 = [r21]
[ASSIGN_REG] Mapeando 'i' para r22.
[UNASSIGN_REG] Desmapeado r21 de 't6'.
[UNASSIGN_REG] -> Estado atual: 17 registradores livres. Mapeamentos: {'t2': 'r17', 't3': 'r18', 't8': 'r25', 't9': 'r4', 't11': 'r6', 't12': 'r8', 't13': 'r9', 't15': 'r10', 't16': 'r11', 't18': 'r12', 't19': 'r16', 't20': 'r15', 'i': 'r22'}
[UPDATE_MAP] Mapeando 't23' para o registrador r22 (que contém o valor de origem).
[ASSIGN_REG] Mapeando 't23' para r22.
[ASSIGN_REG] -> Registrador r22 já continha 'i'. Liberando o mapeamento antigo.
[UNASSIGN_REG] Desmapeado r22 de 'i'.
[UNASSIGN_REG] -> Estado atual: 18 registradores livres. Mapeamentos: {'t2': 'r17', 't3': 'r18', 't8': 'r25', 't9': 'r4', 't11': 'r6', 't12': 'r8', 't13': 'r9', 't15': 'r10', 't16': 'r11', 't18': 'r12', 't19': 'r16', 't20': 'r15'}
[TRANSLATE] -> Valor de 'i' agora em r22, mapeado para 't23'.

--- [TRANSLATE] Processando IR: *k := t23 ---
[TRANSLATE] -> Detalhes: Destino='*k', Expressão='t23'
[TRANSLATE] -> Caminho: Armazenar em Ponteiro (*)
[ENSURE] Tentando garantir 't23' em um registrador.
[ENSURE] -> Sucesso! 't23' já está em r22.
[TRANSLATE] -> Endereço de destino é uma variável real. Obtendo endereço em registrador.
[GET_ADDR] Obtendo endereço para 'k'.
[GET_FREE] -> Encontrado registrador livre: r23. Restantes: 17.
[ADD_INSTR] Adicionando instrução para 'minloc': movi: r23 = 38
[GET_ADDR] -> Endereço de 'k' (38) carregado em r23.
[ADD_INSTR] Adicionando instrução para 'minloc': store: [r23] = r22
[FREE_TEMP] Liberando registrador r22 que continha o temporário 't23'.
[UNASSIGN_REG] Desmapeado r22 de 't23'.
[UNASSIGN_REG] -> Estado atual: 17 registradores livres. Mapeamentos: {'t2': 'r17', 't3': 'r18', 't8': 'r25', 't9': 'r4', 't11': 'r6', 't12': 'r8', 't13': 'r9', 't15': 'r10', 't16': 'r11', 't18': 'r12', 't19': 'r16', 't20': 'r15'}
[UNASSIGN_REG] r23 já estava desmapeado.
[UNASSIGN_REG] -> Estado atual: 18 registradores livres. Mapeamentos: {'t2': 'r17', 't3': 'r18', 't8': 'r25', 't9': 'r4', 't11': 'r6', 't12': 'r8', 't13': 'r9', 't15': 'r10', 't16': 'r11', 't18': 'r12', 't19': 'r16', 't20': 'r15'}

--- [TRANSLATE] Processando IR: goto L3 ---
[TRANSLATE] -> Desvio incondicional detectado: L3
[SPILL_ALL] Verificando registradores sujos para salvar antes da chamada de função. Sujos: {'r23', 'r17', 'r16', 'r15', 'r10', 'r18', 'r8', 'r9', 'r19'}
[ADD_INSTR] Adicionando instrução para 'minloc': bi: L3

--- [TRANSLATE] Processando IR: L2: ---
[TRANSLATE] -> Rótulo detectado: L2:
[SPILL_ALL] Verificando registradores sujos para salvar antes da chamada de função. Sujos: {'r23', 'r17', 'r16', 'r15', 'r10', 'r18', 'r8', 'r9', 'r19'}
[ADD_INSTR] Adicionando instrução para 'minloc': L2:

--- [TRANSLATE] Processando IR: L3: ---
[TRANSLATE] -> Rótulo detectado: L3:
[SPILL_ALL] Verificando registradores sujos para salvar antes da chamada de função. Sujos: {'r23', 'r17', 'r16', 'r15', 'r10', 'r18', 'r8', 'r9', 'r19'}
[ADD_INSTR] Adicionando instrução para 'minloc': L3:

--- [TRANSLATE] Processando IR: t24 := *i ---
[TRANSLATE] -> Detalhes: Destino='t24', Expressão='*i'
[TRANSLATE] -> Caminho: Carregar de Ponteiro (*)
[ENSURE] Tentando garantir 'i' em um registrador.
[ENSURE] -> Variável 'i' não está em um registrador. Carregando da memória.
[GET_FREE] -> Encontrado registrador livre: r24. Restantes: 17.
[GET_FREE] -> Encontrado registrador livre: r26. Restantes: 16.
[ADD_INSTR] Adicionando instrução para 'minloc': movi: r26 = 39
[ENSURE] -> Usando r24 para o valor e r26 para o endereço 39.
[ADD_INSTR] Adicionando instrução para 'minloc': load: r24 = [r26]
[ASSIGN_REG] Mapeando 'i' para r24.
[UNASSIGN_REG] r26 já estava desmapeado.
[UNASSIGN_REG] -> Estado atual: 17 registradores livres. Mapeamentos: {'t2': 'r17', 't3': 'r18', 't8': 'r25', 't9': 'r4', 't11': 'r6', 't12': 'r8', 't13': 'r9', 't15': 'r10', 't16': 'r11', 't18': 'r12', 't19': 'r16', 't20': 'r15', 'i': 'r24'}
[UPDATE_MAP] Mapeando 't24' para o registrador r24 (que contém o valor de origem).
[ASSIGN_REG] Mapeando 't24' para r24.
[ASSIGN_REG] -> Registrador r24 já continha 'i'. Liberando o mapeamento antigo.
[UNASSIGN_REG] Desmapeado r24 de 'i'.
[UNASSIGN_REG] -> Estado atual: 18 registradores livres. Mapeamentos: {'t2': 'r17', 't3': 'r18', 't8': 'r25', 't9': 'r4', 't11': 'r6', 't12': 'r8', 't13': 'r9', 't15': 'r10', 't16': 'r11', 't18': 'r12', 't19': 'r16', 't20': 'r15'}
[TRANSLATE] -> Valor de 'i' agora em r24, mapeado para 't24'.

--- [TRANSLATE] Processando IR: t25 := t24 + 1 ---
[TRANSLATE] -> Detalhes: Destino='t25', Expressão='t24 + 1'
[TRANSLATE] -> Caminho: Operação Aritmética
[ENSURE] Tentando garantir 't24' em um registrador.
[ENSURE] -> Sucesso! 't24' já está em r24.
[TRANSLATE] -> Operando 2 é um imediato: 1
[GET_TEMP] Solicitando registrador para o temporário 't25'.
[GET_FREE] -> Encontrado registrador livre: r25. Restantes: 17.
[ASSIGN_REG] Mapeando 't25' para r25.
[ASSIGN_REG] -> Registrador r25 já continha 't8'. Liberando o mapeamento antigo.
[UNASSIGN_REG] Desmapeado r25 de 't8'.
[UNASSIGN_REG] -> Estado atual: 18 registradores livres. Mapeamentos: {'t2': 'r17', 't3': 'r18', 't9': 'r4', 't11': 'r6', 't12': 'r8', 't13': 'r9', 't15': 'r10', 't16': 'r11', 't18': 'r12', 't19': 'r16', 't20': 'r15', 't24': 'r24'}
[GET_TEMP] -> 't25' alocado no registrador r25.
[ADD_INSTR] Adicionando instrução para 'minloc': addi: r25 = r24, 1

--- [TRANSLATE] Processando IR: *i := t25 ---
[TRANSLATE] -> Detalhes: Destino='*i', Expressão='t25'
[TRANSLATE] -> Caminho: Armazenar em Ponteiro (*)
[ENSURE] Tentando garantir 't25' em um registrador.
[ENSURE] -> Sucesso! 't25' já está em r25.
[TRANSLATE] -> Endereço de destino é uma variável real. Obtendo endereço em registrador.
[GET_ADDR] Obtendo endereço para 'i'.
[GET_FREE] -> Encontrado registrador livre: r5. Restantes: 17.
[ADD_INSTR] Adicionando instrução para 'minloc': movi: r5 = 39
[GET_ADDR] -> Endereço de 'i' (39) carregado em r5.
[ADD_INSTR] Adicionando instrução para 'minloc': store: [r5] = r25
[FREE_TEMP] Liberando registrador r25 que continha o temporário 't25'.
[UNASSIGN_REG] Desmapeado r25 de 't25'.
[UNASSIGN_REG] -> Estado atual: 17 registradores livres. Mapeamentos: {'t2': 'r17', 't3': 'r18', 't9': 'r4', 't11': 'r6', 't12': 'r8', 't13': 'r9', 't15': 'r10', 't16': 'r11', 't18': 'r12', 't19': 'r16', 't20': 'r15', 't24': 'r24'}
[UNASSIGN_REG] r5 já estava desmapeado.
[UNASSIGN_REG] -> Estado atual: 18 registradores livres. Mapeamentos: {'t2': 'r17', 't3': 'r18', 't9': 'r4', 't11': 'r6', 't12': 'r8', 't13': 'r9', 't15': 'r10', 't16': 'r11', 't18': 'r12', 't19': 'r16', 't20': 'r15', 't24': 'r24'}

--- [TRANSLATE] Processando IR: goto L0 ---
[TRANSLATE] -> Desvio incondicional detectado: L0
[SPILL_ALL] Verificando registradores sujos para salvar antes da chamada de função. Sujos: {'r23', 'r17', 'r16', 'r15', 'r10', 'r18', 'r8', 'r9', 'r19', 'r25'}
[ADD_INSTR] Adicionando instrução para 'minloc': bi: L0

--- [TRANSLATE] Processando IR: L1: ---
[TRANSLATE] -> Rótulo detectado: L1:
[SPILL_ALL] Verificando registradores sujos para salvar antes da chamada de função. Sujos: {'r23', 'r17', 'r16', 'r15', 'r10', 'r18', 'r8', 'r9', 'r19', 'r25'}
[ADD_INSTR] Adicionando instrução para 'minloc': L1:

--- [TRANSLATE] Processando IR: t26 := *k ---
[TRANSLATE] -> Detalhes: Destino='t26', Expressão='*k'
[TRANSLATE] -> Caminho: Carregar de Ponteiro (*)
[ENSURE] Tentando garantir 'k' em um registrador.
[ENSURE] -> Variável 'k' não está em um registrador. Carregando da memória.
[GET_FREE] -> Encontrado registrador livre: r4. Restantes: 17.
[GET_FREE] -> Encontrado registrador livre: r7. Restantes: 16.
[ADD_INSTR] Adicionando instrução para 'minloc': movi: r7 = 38
[ENSURE] -> Usando r4 para o valor e r7 para o endereço 38.
[ADD_INSTR] Adicionando instrução para 'minloc': load: r4 = [r7]
[ASSIGN_REG] Mapeando 'k' para r4.
[ASSIGN_REG] -> Registrador r4 já continha 't9'. Liberando o mapeamento antigo.
[UNASSIGN_REG] Desmapeado r4 de 't9'.
[UNASSIGN_REG] -> Estado atual: 17 registradores livres. Mapeamentos: {'t2': 'r17', 't3': 'r18', 't11': 'r6', 't12': 'r8', 't13': 'r9', 't15': 'r10', 't16': 'r11', 't18': 'r12', 't19': 'r16', 't20': 'r15', 't24': 'r24'}
[UNASSIGN_REG] r7 já estava desmapeado.
[UNASSIGN_REG] -> Estado atual: 18 registradores livres. Mapeamentos: {'t2': 'r17', 't3': 'r18', 't11': 'r6', 't12': 'r8', 't13': 'r9', 't15': 'r10', 't16': 'r11', 't18': 'r12', 't19': 'r16', 't20': 'r15', 't24': 'r24', 'k': 'r4'}
[UPDATE_MAP] Mapeando 't26' para o registrador r4 (que contém o valor de origem).
[ASSIGN_REG] Mapeando 't26' para r4.
[ASSIGN_REG] -> Registrador r4 já continha 'k'. Liberando o mapeamento antigo.
[UNASSIGN_REG] Desmapeado r4 de 'k'.
[UNASSIGN_REG] -> Estado atual: 18 registradores livres. Mapeamentos: {'t2': 'r17', 't3': 'r18', 't11': 'r6', 't12': 'r8', 't13': 'r9', 't15': 'r10', 't16': 'r11', 't18': 'r12', 't19': 'r16', 't20': 'r15', 't24': 'r24'}
[TRANSLATE] -> Valor de 'k' agora em r4, mapeado para 't26'.

--- [TRANSLATE] Processando IR: return t26 ---
[TRANSLATE] -> Caminho: Retorno de Função
[ENSURE] Tentando garantir 't26' em um registrador.
[ENSURE] -> Sucesso! 't26' já está em r4.
[ADD_INSTR] Adicionando instrução para 'minloc': mov: r0 = r4
[SPILL_ALL] Verificando registradores sujos para salvar antes da chamada de função. Sujos: {'r23', 'r17', 'r16', 'r15', 'r10', 'r18', 'r8', 'r9', 'r19', 'r25'}
[ADD_INSTR] Adicionando instrução para 'minloc': bi: minloc_epilogue

--- [TRANSLATE] Processando IR: return _ ---
[TRANSLATE] -> Caminho: Retorno de Função
[SPILL_ALL] Verificando registradores sujos para salvar antes da chamada de função. Sujos: {'r23', 'r17', 'r16', 'r15', 'r10', 'r18', 'r8', 'r9', 'r19', 'r25'}
[ADD_INSTR] Adicionando instrução para 'minloc': bi: minloc_epilogue
-> Finalizando a função 'minloc', fazendo spill de todos os registradores sujos.
[SPILL_ALL] Verificando registradores sujos para salvar antes da chamada de função. Sujos: {'r23', 'r17', 'r16', 'r15', 'r10', 'r18', 'r8', 'r9', 'r19', 'r25'}

[Processando Função] -> 'sort'
-> IR isolado para 'sort' contém 44 instruções.

--- [TRANSLATE] Processando IR: t27 := *low ---
[TRANSLATE] -> Detalhes: Destino='t27', Expressão='*low'
[TRANSLATE] -> Caminho: Carregar de Ponteiro (*)
[ENSURE] Tentando garantir 'low' em um registrador.
[ENSURE] -> Variável 'low' não está em um registrador. Carregando da memória.
[GET_FREE] -> Encontrado registrador livre: r12. Restantes: 22.
[GET_FREE] -> Encontrado registrador livre: r13. Restantes: 21.
[ADD_INSTR] Adicionando instrução para 'sort': movi: r13 = 35
[ENSURE] -> Usando r12 para o valor e r13 para o endereço 35.
[ADD_INSTR] Adicionando instrução para 'sort': load: r12 = [r13]
[ASSIGN_REG] Mapeando 'low' para r12.
[UNASSIGN_REG] r13 já estava desmapeado.
[UNASSIGN_REG] -> Estado atual: 22 registradores livres. Mapeamentos: {'low': 'r12'}
[UPDATE_MAP] Mapeando 't27' para o registrador r12 (que contém o valor de origem).
[ASSIGN_REG] Mapeando 't27' para r12.
[ASSIGN_REG] -> Registrador r12 já continha 'low'. Liberando o mapeamento antigo.
[UNASSIGN_REG] Desmapeado r12 de 'low'.
[UNASSIGN_REG] -> Estado atual: 23 registradores livres. Mapeamentos: {}
[TRANSLATE] -> Valor de 'low' agora em r12, mapeado para 't27'.

--- [TRANSLATE] Processando IR: *i := t27 ---
[TRANSLATE] -> Detalhes: Destino='*i', Expressão='t27'
[TRANSLATE] -> Caminho: Armazenar em Ponteiro (*)
[ENSURE] Tentando garantir 't27' em um registrador.
[ENSURE] -> Sucesso! 't27' já está em r12.
[TRANSLATE] -> Endereço de destino é uma variável real. Obtendo endereço em registrador.
[GET_ADDR] Obtendo endereço para 'i'.
[GET_FREE] -> Encontrado registrador livre: r14. Restantes: 22.
[ADD_INSTR] Adicionando instrução para 'sort': movi: r14 = 39
[GET_ADDR] -> Endereço de 'i' (39) carregado em r14.
[ADD_INSTR] Adicionando instrução para 'sort': store: [r14] = r12
[FREE_TEMP] Liberando registrador r12 que continha o temporário 't27'.
[UNASSIGN_REG] Desmapeado r12 de 't27'.
[UNASSIGN_REG] -> Estado atual: 22 registradores livres. Mapeamentos: {}
[UNASSIGN_REG] r14 já estava desmapeado.
[UNASSIGN_REG] -> Estado atual: 23 registradores livres. Mapeamentos: {}

--- [TRANSLATE] Processando IR: L4: ---
[TRANSLATE] -> Rótulo detectado: L4:
[SPILL_ALL] Verificando registradores sujos para salvar antes da chamada de função. Sujos: set()
[ADD_INSTR] Adicionando instrução para 'sort': L4:

--- [TRANSLATE] Processando IR: t28 := *i ---
[TRANSLATE] -> Detalhes: Destino='t28', Expressão='*i'
[TRANSLATE] -> Caminho: Carregar de Ponteiro (*)
[ENSURE] Tentando garantir 'i' em um registrador.
[ENSURE] -> Variável 'i' não está em um registrador. Carregando da memória.
[GET_FREE] -> Encontrado registrador livre: r15. Restantes: 22.
[GET_FREE] -> Encontrado registrador livre: r16. Restantes: 21.
[ADD_INSTR] Adicionando instrução para 'sort': movi: r16 = 39
[ENSURE] -> Usando r15 para o valor e r16 para o endereço 39.
[ADD_INSTR] Adicionando instrução para 'sort': load: r15 = [r16]
[ASSIGN_REG] Mapeando 'i' para r15.
[UNASSIGN_REG] r16 já estava desmapeado.
[UNASSIGN_REG] -> Estado atual: 22 registradores livres. Mapeamentos: {'i': 'r15'}
[UPDATE_MAP] Mapeando 't28' para o registrador r15 (que contém o valor de origem).
[ASSIGN_REG] Mapeando 't28' para r15.
[ASSIGN_REG] -> Registrador r15 já continha 'i'. Liberando o mapeamento antigo.
[UNASSIGN_REG] Desmapeado r15 de 'i'.
[UNASSIGN_REG] -> Estado atual: 23 registradores livres. Mapeamentos: {}
[TRANSLATE] -> Valor de 'i' agora em r15, mapeado para 't28'.

--- [TRANSLATE] Processando IR: t29 := *high ---
[TRANSLATE] -> Detalhes: Destino='t29', Expressão='*high'
[TRANSLATE] -> Caminho: Carregar de Ponteiro (*)
[ENSURE] Tentando garantir 'high' em um registrador.
[ENSURE] -> Variável 'high' não está em um registrador. Carregando da memória.
[GET_FREE] -> Encontrado registrador livre: r17. Restantes: 22.
[GET_FREE] -> Encontrado registrador livre: r18. Restantes: 21.
[ADD_INSTR] Adicionando instrução para 'sort': movi: r18 = 40
[ENSURE] -> Usando r17 para o valor e r18 para o endereço 40.
[ADD_INSTR] Adicionando instrução para 'sort': load: r17 = [r18]
[ASSIGN_REG] Mapeando 'high' para r17.
[UNASSIGN_REG] r18 já estava desmapeado.
[UNASSIGN_REG] -> Estado atual: 22 registradores livres. Mapeamentos: {'t28': 'r15', 'high': 'r17'}
[UPDATE_MAP] Mapeando 't29' para o registrador r17 (que contém o valor de origem).
[ASSIGN_REG] Mapeando 't29' para r17.
[ASSIGN_REG] -> Registrador r17 já continha 'high'. Liberando o mapeamento antigo.
[UNASSIGN_REG] Desmapeado r17 de 'high'.
[UNASSIGN_REG] -> Estado atual: 23 registradores livres. Mapeamentos: {'t28': 'r15'}
[TRANSLATE] -> Valor de 'high' agora em r17, mapeado para 't29'.

--- [TRANSLATE] Processando IR: t30 := t29 - 1 ---
[TRANSLATE] -> Detalhes: Destino='t30', Expressão='t29 - 1'
[TRANSLATE] -> Caminho: Operação Aritmética
[ENSURE] Tentando garantir 't29' em um registrador.
[ENSURE] -> Sucesso! 't29' já está em r17.
[TRANSLATE] -> Operando 2 é um imediato: 1
[GET_TEMP] Solicitando registrador para o temporário 't30'.
[GET_FREE] -> Encontrado registrador livre: r19. Restantes: 22.
[ASSIGN_REG] Mapeando 't30' para r19.
[GET_TEMP] -> 't30' alocado no registrador r19.
[ADD_INSTR] Adicionando instrução para 'sort': subi: r19 = r17, 1

--- [TRANSLATE] Processando IR: t31 := t28 < t30 ---
[TRANSLATE] -> Detalhes: Destino='t31', Expressão='t28 < t30'
[TRANSLATE] -> Caminho: Comparação (condicional)
[ENSURE] Tentando garantir 't28' em um registrador.
[ENSURE] -> Sucesso! 't28' já está em r15.
[ENSURE] Tentando garantir 't30' em um registrador.
[ENSURE] -> Sucesso! 't30' já está em r19.
[ADD_INSTR] Adicionando instrução para 'sort': subs: r0 = r15, r19

--- [TRANSLATE] Processando IR: if_false t31 goto L5 ---
[TRANSLATE] -> Caminho: Desvio Condicional (if_false)
[ADD_INSTR] Adicionando instrução para 'sort': bigteq: L5

--- [TRANSLATE] Processando IR: t32 := *a ---
[TRANSLATE] -> Detalhes: Destino='t32', Expressão='*a'
[TRANSLATE] -> Caminho: Carregar de Ponteiro (*)
[ENSURE] Tentando garantir 'a' em um registrador.
[ENSURE] -> Variável 'a' não está em um registrador. Carregando da memória.
[GET_FREE] -> Encontrado registrador livre: r20. Restantes: 21.
[GET_FREE] -> Encontrado registrador livre: r21. Restantes: 20.
[ADD_INSTR] Adicionando instrução para 'sort': movi: r21 = 33
[ENSURE] -> Usando r20 para o valor e r21 para o endereço 33.
[ADD_INSTR] Adicionando instrução para 'sort': load: r20 = [r21]
[ASSIGN_REG] Mapeando 'a' para r20.
[UNASSIGN_REG] r21 já estava desmapeado.
[UNASSIGN_REG] -> Estado atual: 21 registradores livres. Mapeamentos: {'t28': 'r15', 't29': 'r17', 't30': 'r19', 'a': 'r20'}
[UPDATE_MAP] Mapeando 't32' para o registrador r20 (que contém o valor de origem).
[ASSIGN_REG] Mapeando 't32' para r20.
[ASSIGN_REG] -> Registrador r20 já continha 'a'. Liberando o mapeamento antigo.
[UNASSIGN_REG] Desmapeado r20 de 'a'.
[UNASSIGN_REG] -> Estado atual: 22 registradores livres. Mapeamentos: {'t28': 'r15', 't29': 'r17', 't30': 'r19'}
[TRANSLATE] -> Valor de 'a' agora em r20, mapeado para 't32'.

--- [TRANSLATE] Processando IR: arg t32 ---
[TRANSLATE] -> Caminho: Passagem de Argumento (arg 1)
[ENSURE] Tentando garantir 't32' em um registrador.
[ENSURE] -> Sucesso! 't32' já está em r20.
[ADD_INSTR] Adicionando instrução para 'sort': mov: r1 = r20

--- [TRANSLATE] Processando IR: t33 := *i ---
[TRANSLATE] -> Detalhes: Destino='t33', Expressão='*i'
[TRANSLATE] -> Caminho: Carregar de Ponteiro (*)
[ENSURE] Tentando garantir 'i' em um registrador.
[ENSURE] -> Variável 'i' não está em um registrador. Carregando da memória.
[GET_FREE] -> Encontrado registrador livre: r22. Restantes: 21.
[GET_FREE] -> Encontrado registrador livre: r23. Restantes: 20.
[ADD_INSTR] Adicionando instrução para 'sort': movi: r23 = 39
[ENSURE] -> Usando r22 para o valor e r23 para o endereço 39.
[ADD_INSTR] Adicionando instrução para 'sort': load: r22 = [r23]
[ASSIGN_REG] Mapeando 'i' para r22.
[UNASSIGN_REG] r23 já estava desmapeado.
[UNASSIGN_REG] -> Estado atual: 21 registradores livres. Mapeamentos: {'t28': 'r15', 't29': 'r17', 't30': 'r19', 't32': 'r20', 'i': 'r22'}
[UPDATE_MAP] Mapeando 't33' para o registrador r22 (que contém o valor de origem).
[ASSIGN_REG] Mapeando 't33' para r22.
[ASSIGN_REG] -> Registrador r22 já continha 'i'. Liberando o mapeamento antigo.
[UNASSIGN_REG] Desmapeado r22 de 'i'.
[UNASSIGN_REG] -> Estado atual: 22 registradores livres. Mapeamentos: {'t28': 'r15', 't29': 'r17', 't30': 'r19', 't32': 'r20'}
[TRANSLATE] -> Valor de 'i' agora em r22, mapeado para 't33'.

--- [TRANSLATE] Processando IR: arg t33 ---
[TRANSLATE] -> Caminho: Passagem de Argumento (arg 2)
[ENSURE] Tentando garantir 't33' em um registrador.
[ENSURE] -> Sucesso! 't33' já está em r22.
[ADD_INSTR] Adicionando instrução para 'sort': mov: r2 = r22

--- [TRANSLATE] Processando IR: t34 := *high ---
[TRANSLATE] -> Detalhes: Destino='t34', Expressão='*high'
[TRANSLATE] -> Caminho: Carregar de Ponteiro (*)
[ENSURE] Tentando garantir 'high' em um registrador.
[ENSURE] -> Variável 'high' não está em um registrador. Carregando da memória.
[GET_FREE] -> Encontrado registrador livre: r24. Restantes: 21.
[GET_FREE] -> Encontrado registrador livre: r25. Restantes: 20.
[ADD_INSTR] Adicionando instrução para 'sort': movi: r25 = 40
[ENSURE] -> Usando r24 para o valor e r25 para o endereço 40.
[ADD_INSTR] Adicionando instrução para 'sort': load: r24 = [r25]
[ASSIGN_REG] Mapeando 'high' para r24.
[UNASSIGN_REG] r25 já estava desmapeado.
[UNASSIGN_REG] -> Estado atual: 21 registradores livres. Mapeamentos: {'t28': 'r15', 't29': 'r17', 't30': 'r19', 't32': 'r20', 't33': 'r22', 'high': 'r24'}
[UPDATE_MAP] Mapeando 't34' para o registrador r24 (que contém o valor de origem).
[ASSIGN_REG] Mapeando 't34' para r24.
[ASSIGN_REG] -> Registrador r24 já continha 'high'. Liberando o mapeamento antigo.
[UNASSIGN_REG] Desmapeado r24 de 'high'.
[UNASSIGN_REG] -> Estado atual: 22 registradores livres. Mapeamentos: {'t28': 'r15', 't29': 'r17', 't30': 'r19', 't32': 'r20', 't33': 'r22'}
[TRANSLATE] -> Valor de 'high' agora em r24, mapeado para 't34'.

--- [TRANSLATE] Processando IR: arg t34 ---
[TRANSLATE] -> Caminho: Passagem de Argumento (arg 3)
[ENSURE] Tentando garantir 't34' em um registrador.
[ENSURE] -> Sucesso! 't34' já está em r24.
[ADD_INSTR] Adicionando instrução para 'sort': mov: r3 = r24

--- [TRANSLATE] Processando IR: t35 := call minloc, 3 ---
[TRANSLATE] -> Detalhes: Destino='t35', Expressão='call minloc, 3'
[TRANSLATE] -> Caminho: Chamada de Função com Retorno
[SPILL_ALL] Verificando registradores sujos para salvar antes da chamada de função. Sujos: {'r19'}
[GET_TEMP] Solicitando registrador para o temporário 't_ret_21'.
[GET_FREE] -> Encontrado registrador livre: r26. Restantes: 21.
[ASSIGN_REG] Mapeando 't_ret_21' para r26.
[GET_TEMP] -> 't_ret_21' alocado no registrador r26.
[GET_ADDR] Obtendo endereço para 'low'.
[GET_FREE] -> Encontrado registrador livre: r4. Restantes: 20.
[ADD_INSTR] Adicionando instrução para 'sort': movi: r4 = 35
[GET_ADDR] -> Endereço de 'low' (35) carregado em r4.
[ADD_INSTR] Adicionando instrução para 'sort': store: [r4] = r1
[UNASSIGN_REG] r4 já estava desmapeado.
[UNASSIGN_REG] -> Estado atual: 21 registradores livres. Mapeamentos: {'t28': 'r15', 't29': 'r17', 't30': 'r19', 't32': 'r20', 't33': 'r22', 't34': 'r24', 't_ret_21': 'r26'}
[GET_ADDR] Obtendo endereço para 'a'.
[GET_FREE] -> Encontrado registrador livre: r5. Restantes: 20.
[ADD_INSTR] Adicionando instrução para 'sort': movi: r5 = 33
[GET_ADDR] -> Endereço de 'a' (33) carregado em r5.
[ADD_INSTR] Adicionando instrução para 'sort': store: [r5] = r2
[UNASSIGN_REG] r5 já estava desmapeado.
[UNASSIGN_REG] -> Estado atual: 21 registradores livres. Mapeamentos: {'t28': 'r15', 't29': 'r17', 't30': 'r19', 't32': 'r20', 't33': 'r22', 't34': 'r24', 't_ret_21': 'r26'}
[GET_ADDR] Obtendo endereço para 'high'.
[GET_FREE] -> Encontrado registrador livre: r6. Restantes: 20.
[ADD_INSTR] Adicionando instrução para 'sort': movi: r6 = 40
[GET_ADDR] -> Endereço de 'high' (40) carregado em r6.
[ADD_INSTR] Adicionando instrução para 'sort': store: [r6] = r3
[UNASSIGN_REG] r6 já estava desmapeado.
[UNASSIGN_REG] -> Estado atual: 21 registradores livres. Mapeamentos: {'t28': 'r15', 't29': 'r17', 't30': 'r19', 't32': 'r20', 't33': 'r22', 't34': 'r24', 't_ret_21': 'r26'}
[ADD_INSTR] Adicionando instrução para 'sort': movi: r26 = sort_Lret0
[ADD_INSTR] Adicionando instrução para 'sort': mov: r28 = r26
[ADD_INSTR] Adicionando instrução para 'sort': bl: minloc
[FREE_TEMP] Liberando registrador r26 que continha o temporário 't_ret_21'.
[UNASSIGN_REG] Desmapeado r26 de 't_ret_21'.
[UNASSIGN_REG] -> Estado atual: 22 registradores livres. Mapeamentos: {'t28': 'r15', 't29': 'r17', 't30': 'r19', 't32': 'r20', 't33': 'r22', 't34': 'r24'}
[ADD_INSTR] Adicionando instrução para 'sort': sort_Lret0:
[GET_TEMP] Solicitando registrador para o temporário 't35'.
[GET_FREE] -> Encontrado registrador livre: r7. Restantes: 21.
[ASSIGN_REG] Mapeando 't35' para r7.
[GET_TEMP] -> 't35' alocado no registrador r7.
[ADD_INSTR] Adicionando instrução para 'sort': mov: r7 = r0
[UNASSIGN_REG] Desmapeado r20 de 't32'.
[UNASSIGN_REG] -> Estado atual: 21 registradores livres. Mapeamentos: {'t28': 'r15', 't29': 'r17', 't30': 'r19', 't33': 'r22', 't34': 'r24', 't35': 'r7'}
[UNASSIGN_REG] Desmapeado r22 de 't33'.
[UNASSIGN_REG] -> Estado atual: 21 registradores livres. Mapeamentos: {'t28': 'r15', 't29': 'r17', 't30': 'r19', 't34': 'r24', 't35': 'r7'}
[UNASSIGN_REG] Desmapeado r24 de 't34'.
[UNASSIGN_REG] -> Estado atual: 21 registradores livres. Mapeamentos: {'t28': 'r15', 't29': 'r17', 't30': 'r19', 't35': 'r7'}

--- [TRANSLATE] Processando IR: *k := t35 ---
[TRANSLATE] -> Detalhes: Destino='*k', Expressão='t35'
[TRANSLATE] -> Caminho: Armazenar em Ponteiro (*)
[ENSURE] Tentando garantir 't35' em um registrador.
[ENSURE] -> Sucesso! 't35' já está em r7.
[TRANSLATE] -> Endereço de destino é uma variável real. Obtendo endereço em registrador.
[GET_ADDR] Obtendo endereço para 'k'.
[GET_FREE] -> Encontrado registrador livre: r8. Restantes: 20.
[ADD_INSTR] Adicionando instrução para 'sort': movi: r8 = 38
[GET_ADDR] -> Endereço de 'k' (38) carregado em r8.
[ADD_INSTR] Adicionando instrução para 'sort': store: [r8] = r7
[FREE_TEMP] Liberando registrador r7 que continha o temporário 't35'.
[UNASSIGN_REG] Desmapeado r7 de 't35'.
[UNASSIGN_REG] -> Estado atual: 21 registradores livres. Mapeamentos: {'t28': 'r15', 't29': 'r17', 't30': 'r19'}
[UNASSIGN_REG] r8 já estava desmapeado.
[UNASSIGN_REG] -> Estado atual: 22 registradores livres. Mapeamentos: {'t28': 'r15', 't29': 'r17', 't30': 'r19'}

--- [TRANSLATE] Processando IR: t36 := *k ---
[TRANSLATE] -> Detalhes: Destino='t36', Expressão='*k'
[TRANSLATE] -> Caminho: Carregar de Ponteiro (*)
[ENSURE] Tentando garantir 'k' em um registrador.
[ENSURE] -> Variável 'k' não está em um registrador. Carregando da memória.
[GET_FREE] -> Encontrado registrador livre: r9. Restantes: 21.
[GET_FREE] -> Encontrado registrador livre: r10. Restantes: 20.
[ADD_INSTR] Adicionando instrução para 'sort': movi: r10 = 38
[ENSURE] -> Usando r9 para o valor e r10 para o endereço 38.
[ADD_INSTR] Adicionando instrução para 'sort': load: r9 = [r10]
[ASSIGN_REG] Mapeando 'k' para r9.
[UNASSIGN_REG] r10 já estava desmapeado.
[UNASSIGN_REG] -> Estado atual: 21 registradores livres. Mapeamentos: {'t28': 'r15', 't29': 'r17', 't30': 'r19', 'k': 'r9'}
[UPDATE_MAP] Mapeando 't36' para o registrador r9 (que contém o valor de origem).
[ASSIGN_REG] Mapeando 't36' para r9.
[ASSIGN_REG] -> Registrador r9 já continha 'k'. Liberando o mapeamento antigo.
[UNASSIGN_REG] Desmapeado r9 de 'k'.
[UNASSIGN_REG] -> Estado atual: 22 registradores livres. Mapeamentos: {'t28': 'r15', 't29': 'r17', 't30': 'r19'}
[TRANSLATE] -> Valor de 'k' agora em r9, mapeado para 't36'.

--- [TRANSLATE] Processando IR: t37 := t36 * 4 ---
[TRANSLATE] -> Detalhes: Destino='t37', Expressão='t36 * 4'
[TRANSLATE] -> Caminho: Operação Aritmética
[ENSURE] Tentando garantir 't36' em um registrador.
[ENSURE] -> Sucesso! 't36' já está em r9.
[TRANSLATE] -> Operando 2 é um imediato: 4
[GET_TEMP] Solicitando registrador para o temporário 't37'.
[GET_FREE] -> Encontrado registrador livre: r11. Restantes: 21.
[ASSIGN_REG] Mapeando 't37' para r11.
[GET_TEMP] -> 't37' alocado no registrador r11.
[ADD_INSTR] Adicionando instrução para 'sort': muli: r11 = r9, 4

--- [TRANSLATE] Processando IR: t38 := &a ---
[TRANSLATE] -> Detalhes: Destino='t38', Expressão='&a'
[TRANSLATE] -> Caminho: Obter Endereço (&)
[GET_TEMP] Solicitando registrador para o temporário 't38'.
[GET_FREE] -> Encontrado registrador livre: r13. Restantes: 20.
[ASSIGN_REG] Mapeando 't38' para r13.
[GET_TEMP] -> 't38' alocado no registrador r13.
[ADD_INSTR] Adicionando instrução para 'sort': movi: r13 = 33

--- [TRANSLATE] Processando IR: t39 := t38 + t37 ---
[TRANSLATE] -> Detalhes: Destino='t39', Expressão='t38 + t37'
[TRANSLATE] -> Caminho: Operação Aritmética
[ENSURE] Tentando garantir 't38' em um registrador.
[ENSURE] -> Sucesso! 't38' já está em r13.
[ENSURE] Tentando garantir 't37' em um registrador.
[ENSURE] -> Sucesso! 't37' já está em r11.
[GET_TEMP] Solicitando registrador para o temporário 't39'.
[GET_FREE] -> Encontrado registrador livre: r12. Restantes: 19.
[ASSIGN_REG] Mapeando 't39' para r12.
[GET_TEMP] -> 't39' alocado no registrador r12.
[ADD_INSTR] Adicionando instrução para 'sort': add: r12 = r13, r11

--- [TRANSLATE] Processando IR: t40 := *t39 ---
[TRANSLATE] -> Detalhes: Destino='t40', Expressão='*t39'
[TRANSLATE] -> Caminho: Carregar de Ponteiro (*)
[ENSURE] Tentando garantir 't39' em um registrador.
[ENSURE] -> Sucesso! 't39' já está em r12.
[UPDATE_MAP] Mapeando 't40' para o registrador r12 (que contém o valor de origem).
[ASSIGN_REG] Mapeando 't40' para r12.
[ASSIGN_REG] -> Registrador r12 já continha 't39'. Liberando o mapeamento antigo.
[UNASSIGN_REG] Desmapeado r12 de 't39'.
[UNASSIGN_REG] -> Estado atual: 20 registradores livres. Mapeamentos: {'t28': 'r15', 't29': 'r17', 't30': 'r19', 't36': 'r9', 't37': 'r11', 't38': 'r13'}
[TRANSLATE] -> Valor de 't39' agora em r12, mapeado para 't40'.

--- [TRANSLATE] Processando IR: *t := t40 ---
[TRANSLATE] -> Detalhes: Destino='*t', Expressão='t40'
[TRANSLATE] -> Caminho: Armazenar em Ponteiro (*)
[ENSURE] Tentando garantir 't40' em um registrador.
[ENSURE] -> Sucesso! 't40' já está em r12.
[TRANSLATE] -> Endereço de destino é uma variável temporária. Usando registrador temporário.
[ENSURE] Tentando garantir 't' em um registrador.
[GET_TEMP] Solicitando registrador para o temporário 't'.
[GET_FREE] -> Encontrado registrador livre: r14. Restantes: 19.
[ASSIGN_REG] Mapeando 't' para r14.
[GET_TEMP] -> 't' alocado no registrador r14.
[ENSURE] -> Variável temporária 't' alocada em r14.
[ADD_INSTR] Adicionando instrução para 'sort': store: [r14] = r12
[FREE_TEMP] Liberando registrador r12 que continha o temporário 't40'.
[UNASSIGN_REG] Desmapeado r12 de 't40'.
[UNASSIGN_REG] -> Estado atual: 19 registradores livres. Mapeamentos: {'t28': 'r15', 't29': 'r17', 't30': 'r19', 't36': 'r9', 't37': 'r11', 't38': 'r13', 't': 'r14'}
[UNASSIGN_REG] Desmapeado r14 de 't'.
[UNASSIGN_REG] -> Estado atual: 20 registradores livres. Mapeamentos: {'t28': 'r15', 't29': 'r17', 't30': 'r19', 't36': 'r9', 't37': 'r11', 't38': 'r13'}

--- [TRANSLATE] Processando IR: t41 := *i ---
[TRANSLATE] -> Detalhes: Destino='t41', Expressão='*i'
[TRANSLATE] -> Caminho: Carregar de Ponteiro (*)
[ENSURE] Tentando garantir 'i' em um registrador.
[ENSURE] -> Variável 'i' não está em um registrador. Carregando da memória.
[GET_FREE] -> Encontrado registrador livre: r16. Restantes: 19.
[GET_FREE] -> Encontrado registrador livre: r15. Restantes: 18.
[ADD_INSTR] Adicionando instrução para 'sort': movi: r15 = 39
[ENSURE] -> Usando r16 para o valor e r15 para o endereço 39.
[ADD_INSTR] Adicionando instrução para 'sort': load: r16 = [r15]
[ASSIGN_REG] Mapeando 'i' para r16.
[UNASSIGN_REG] Desmapeado r15 de 't28'.
[UNASSIGN_REG] -> Estado atual: 19 registradores livres. Mapeamentos: {'t29': 'r17', 't30': 'r19', 't36': 'r9', 't37': 'r11', 't38': 'r13', 'i': 'r16'}
[UPDATE_MAP] Mapeando 't41' para o registrador r16 (que contém o valor de origem).
[ASSIGN_REG] Mapeando 't41' para r16.
[ASSIGN_REG] -> Registrador r16 já continha 'i'. Liberando o mapeamento antigo.
[UNASSIGN_REG] Desmapeado r16 de 'i'.
[UNASSIGN_REG] -> Estado atual: 20 registradores livres. Mapeamentos: {'t29': 'r17', 't30': 'r19', 't36': 'r9', 't37': 'r11', 't38': 'r13'}
[TRANSLATE] -> Valor de 'i' agora em r16, mapeado para 't41'.

--- [TRANSLATE] Processando IR: t42 := t41 * 4 ---
[TRANSLATE] -> Detalhes: Destino='t42', Expressão='t41 * 4'
[TRANSLATE] -> Caminho: Operação Aritmética
[ENSURE] Tentando garantir 't41' em um registrador.
[ENSURE] -> Sucesso! 't41' já está em r16.
[TRANSLATE] -> Operando 2 é um imediato: 4
[GET_TEMP] Solicitando registrador para o temporário 't42'.
[GET_FREE] -> Encontrado registrador livre: r18. Restantes: 19.
[ASSIGN_REG] Mapeando 't42' para r18.
[GET_TEMP] -> 't42' alocado no registrador r18.
[ADD_INSTR] Adicionando instrução para 'sort': muli: r18 = r16, 4

--- [TRANSLATE] Processando IR: t43 := &a ---
[TRANSLATE] -> Detalhes: Destino='t43', Expressão='&a'
[TRANSLATE] -> Caminho: Obter Endereço (&)
[GET_TEMP] Solicitando registrador para o temporário 't43'.
[GET_FREE] -> Encontrado registrador livre: r17. Restantes: 18.
[ASSIGN_REG] Mapeando 't43' para r17.
[ASSIGN_REG] -> Registrador r17 já continha 't29'. Liberando o mapeamento antigo.
[UNASSIGN_REG] Desmapeado r17 de 't29'.
[UNASSIGN_REG] -> Estado atual: 19 registradores livres. Mapeamentos: {'t30': 'r19', 't36': 'r9', 't37': 'r11', 't38': 'r13', 't41': 'r16', 't42': 'r18'}
[GET_TEMP] -> 't43' alocado no registrador r17.
[ADD_INSTR] Adicionando instrução para 'sort': movi: r17 = 33

--- [TRANSLATE] Processando IR: t44 := t43 + t42 ---
[TRANSLATE] -> Detalhes: Destino='t44', Expressão='t43 + t42'
[TRANSLATE] -> Caminho: Operação Aritmética
[ENSURE] Tentando garantir 't43' em um registrador.
[ENSURE] -> Sucesso! 't43' já está em r17.
[ENSURE] Tentando garantir 't42' em um registrador.
[ENSURE] -> Sucesso! 't42' já está em r18.
[GET_TEMP] Solicitando registrador para o temporário 't44'.
[GET_FREE] -> Encontrado registrador livre: r21. Restantes: 18.
[ASSIGN_REG] Mapeando 't44' para r21.
[GET_TEMP] -> 't44' alocado no registrador r21.
[ADD_INSTR] Adicionando instrução para 'sort': add: r21 = r17, r18

--- [TRANSLATE] Processando IR: t45 := *t44 ---
[TRANSLATE] -> Detalhes: Destino='t45', Expressão='*t44'
[TRANSLATE] -> Caminho: Carregar de Ponteiro (*)
[ENSURE] Tentando garantir 't44' em um registrador.
[ENSURE] -> Sucesso! 't44' já está em r21.
[UPDATE_MAP] Mapeando 't45' para o registrador r21 (que contém o valor de origem).
[ASSIGN_REG] Mapeando 't45' para r21.
[ASSIGN_REG] -> Registrador r21 já continha 't44'. Liberando o mapeamento antigo.
[UNASSIGN_REG] Desmapeado r21 de 't44'.
[UNASSIGN_REG] -> Estado atual: 19 registradores livres. Mapeamentos: {'t30': 'r19', 't36': 'r9', 't37': 'r11', 't38': 'r13', 't41': 'r16', 't42': 'r18', 't43': 'r17'}
[TRANSLATE] -> Valor de 't44' agora em r21, mapeado para 't45'.

--- [TRANSLATE] Processando IR: t46 := *k ---
[TRANSLATE] -> Detalhes: Destino='t46', Expressão='*k'
[TRANSLATE] -> Caminho: Carregar de Ponteiro (*)
[ENSURE] Tentando garantir 'k' em um registrador.
[ENSURE] -> Variável 'k' não está em um registrador. Carregando da memória.
[GET_FREE] -> Encontrado registrador livre: r20. Restantes: 18.
[GET_FREE] -> Encontrado registrador livre: r23. Restantes: 17.
[ADD_INSTR] Adicionando instrução para 'sort': movi: r23 = 38
[ENSURE] -> Usando r20 para o valor e r23 para o endereço 38.
[ADD_INSTR] Adicionando instrução para 'sort': load: r20 = [r23]
[ASSIGN_REG] Mapeando 'k' para r20.
[UNASSIGN_REG] r23 já estava desmapeado.
[UNASSIGN_REG] -> Estado atual: 18 registradores livres. Mapeamentos: {'t30': 'r19', 't36': 'r9', 't37': 'r11', 't38': 'r13', 't41': 'r16', 't42': 'r18', 't43': 'r17', 't45': 'r21', 'k': 'r20'}
[UPDATE_MAP] Mapeando 't46' para o registrador r20 (que contém o valor de origem).
[ASSIGN_REG] Mapeando 't46' para r20.
[ASSIGN_REG] -> Registrador r20 já continha 'k'. Liberando o mapeamento antigo.
[UNASSIGN_REG] Desmapeado r20 de 'k'.
[UNASSIGN_REG] -> Estado atual: 19 registradores livres. Mapeamentos: {'t30': 'r19', 't36': 'r9', 't37': 'r11', 't38': 'r13', 't41': 'r16', 't42': 'r18', 't43': 'r17', 't45': 'r21'}
[TRANSLATE] -> Valor de 'k' agora em r20, mapeado para 't46'.

--- [TRANSLATE] Processando IR: t47 := t46 * 4 ---
[TRANSLATE] -> Detalhes: Destino='t47', Expressão='t46 * 4'
[TRANSLATE] -> Caminho: Operação Aritmética
[ENSURE] Tentando garantir 't46' em um registrador.
[ENSURE] -> Sucesso! 't46' já está em r20.
[TRANSLATE] -> Operando 2 é um imediato: 4
[GET_TEMP] Solicitando registrador para o temporário 't47'.
[GET_FREE] -> Encontrado registrador livre: r22. Restantes: 18.
[ASSIGN_REG] Mapeando 't47' para r22.
[GET_TEMP] -> 't47' alocado no registrador r22.
[ADD_INSTR] Adicionando instrução para 'sort': muli: r22 = r20, 4

--- [TRANSLATE] Processando IR: t48 := &a ---
[TRANSLATE] -> Detalhes: Destino='t48', Expressão='&a'
[TRANSLATE] -> Caminho: Obter Endereço (&)
[GET_TEMP] Solicitando registrador para o temporário 't48'.
[GET_FREE] -> Encontrado registrador livre: r25. Restantes: 17.
[ASSIGN_REG] Mapeando 't48' para r25.
[GET_TEMP] -> 't48' alocado no registrador r25.
[ADD_INSTR] Adicionando instrução para 'sort': movi: r25 = 33

--- [TRANSLATE] Processando IR: t49 := t48 + t47 ---
[TRANSLATE] -> Detalhes: Destino='t49', Expressão='t48 + t47'
[TRANSLATE] -> Caminho: Operação Aritmética
[ENSURE] Tentando garantir 't48' em um registrador.
[ENSURE] -> Sucesso! 't48' já está em r25.
[ENSURE] Tentando garantir 't47' em um registrador.
[ENSURE] -> Sucesso! 't47' já está em r22.
[GET_TEMP] Solicitando registrador para o temporário 't49'.
[GET_FREE] -> Encontrado registrador livre: r24. Restantes: 16.
[ASSIGN_REG] Mapeando 't49' para r24.
[GET_TEMP] -> 't49' alocado no registrador r24.
[ADD_INSTR] Adicionando instrução para 'sort': add: r24 = r25, r22

--- [TRANSLATE] Processando IR: *t49 := t45 ---
[TRANSLATE] -> Detalhes: Destino='*t49', Expressão='t45'
[TRANSLATE] -> Caminho: Armazenar em Ponteiro (*)
[ENSURE] Tentando garantir 't45' em um registrador.
[ENSURE] -> Sucesso! 't45' já está em r21.
[TRANSLATE] -> Endereço de destino é uma variável temporária. Usando registrador temporário.
[ENSURE] Tentando garantir 't49' em um registrador.
[ENSURE] -> Sucesso! 't49' já está em r24.
[ADD_INSTR] Adicionando instrução para 'sort': store: [r24] = r21
[FREE_TEMP] Liberando registrador r21 que continha o temporário 't45'.
[UNASSIGN_REG] Desmapeado r21 de 't45'.
[UNASSIGN_REG] -> Estado atual: 16 registradores livres. Mapeamentos: {'t30': 'r19', 't36': 'r9', 't37': 'r11', 't38': 'r13', 't41': 'r16', 't42': 'r18', 't43': 'r17', 't46': 'r20', 't47': 'r22', 't48': 'r25', 't49': 'r24'}
[UNASSIGN_REG] Desmapeado r24 de 't49'.
[UNASSIGN_REG] -> Estado atual: 17 registradores livres. Mapeamentos: {'t30': 'r19', 't36': 'r9', 't37': 'r11', 't38': 'r13', 't41': 'r16', 't42': 'r18', 't43': 'r17', 't46': 'r20', 't47': 'r22', 't48': 'r25'}

--- [TRANSLATE] Processando IR: t50 := *t ---
[TRANSLATE] -> Detalhes: Destino='t50', Expressão='*t'
[TRANSLATE] -> Caminho: Carregar de Ponteiro (*)
[ENSURE] Tentando garantir 't' em um registrador.
[GET_TEMP] Solicitando registrador para o temporário 't'.
[GET_FREE] -> Encontrado registrador livre: r4. Restantes: 16.
[ASSIGN_REG] Mapeando 't' para r4.
[GET_TEMP] -> 't' alocado no registrador r4.
[ENSURE] -> Variável temporária 't' alocada em r4.
[UPDATE_MAP] Mapeando 't50' para o registrador r4 (que contém o valor de origem).
[ASSIGN_REG] Mapeando 't50' para r4.
[ASSIGN_REG] -> Registrador r4 já continha 't'. Liberando o mapeamento antigo.
[UNASSIGN_REG] Desmapeado r4 de 't'.
[UNASSIGN_REG] -> Estado atual: 17 registradores livres. Mapeamentos: {'t30': 'r19', 't36': 'r9', 't37': 'r11', 't38': 'r13', 't41': 'r16', 't42': 'r18', 't43': 'r17', 't46': 'r20', 't47': 'r22', 't48': 'r25'}
[TRANSLATE] -> Valor de 't' agora em r4, mapeado para 't50'.

--- [TRANSLATE] Processando IR: t51 := *i ---
[TRANSLATE] -> Detalhes: Destino='t51', Expressão='*i'
[TRANSLATE] -> Caminho: Carregar de Ponteiro (*)
[ENSURE] Tentando garantir 'i' em um registrador.
[ENSURE] -> Variável 'i' não está em um registrador. Carregando da memória.
[GET_FREE] -> Encontrado registrador livre: r5. Restantes: 16.
[GET_FREE] -> Encontrado registrador livre: r6. Restantes: 15.
[ADD_INSTR] Adicionando instrução para 'sort': movi: r6 = 39
[ENSURE] -> Usando r5 para o valor e r6 para o endereço 39.
[ADD_INSTR] Adicionando instrução para 'sort': load: r5 = [r6]
[ASSIGN_REG] Mapeando 'i' para r5.
[UNASSIGN_REG] r6 já estava desmapeado.
[UNASSIGN_REG] -> Estado atual: 16 registradores livres. Mapeamentos: {'t30': 'r19', 't36': 'r9', 't37': 'r11', 't38': 'r13', 't41': 'r16', 't42': 'r18', 't43': 'r17', 't46': 'r20', 't47': 'r22', 't48': 'r25', 't50': 'r4', 'i': 'r5'}
[UPDATE_MAP] Mapeando 't51' para o registrador r5 (que contém o valor de origem).
[ASSIGN_REG] Mapeando 't51' para r5.
[ASSIGN_REG] -> Registrador r5 já continha 'i'. Liberando o mapeamento antigo.
[UNASSIGN_REG] Desmapeado r5 de 'i'.
[UNASSIGN_REG] -> Estado atual: 17 registradores livres. Mapeamentos: {'t30': 'r19', 't36': 'r9', 't37': 'r11', 't38': 'r13', 't41': 'r16', 't42': 'r18', 't43': 'r17', 't46': 'r20', 't47': 'r22', 't48': 'r25', 't50': 'r4'}
[TRANSLATE] -> Valor de 'i' agora em r5, mapeado para 't51'.

--- [TRANSLATE] Processando IR: t52 := t51 * 4 ---
[TRANSLATE] -> Detalhes: Destino='t52', Expressão='t51 * 4'
[TRANSLATE] -> Caminho: Operação Aritmética
[ENSURE] Tentando garantir 't51' em um registrador.
[ENSURE] -> Sucesso! 't51' já está em r5.
[TRANSLATE] -> Operando 2 é um imediato: 4
[GET_TEMP] Solicitando registrador para o temporário 't52'.
[GET_FREE] -> Encontrado registrador livre: r26. Restantes: 16.
[ASSIGN_REG] Mapeando 't52' para r26.
[GET_TEMP] -> 't52' alocado no registrador r26.
[ADD_INSTR] Adicionando instrução para 'sort': muli: r26 = r5, 4

--- [TRANSLATE] Processando IR: t53 := &a ---
[TRANSLATE] -> Detalhes: Destino='t53', Expressão='&a'
[TRANSLATE] -> Caminho: Obter Endereço (&)
[GET_TEMP] Solicitando registrador para o temporário 't53'.
[GET_FREE] -> Encontrado registrador livre: r7. Restantes: 15.
[ASSIGN_REG] Mapeando 't53' para r7.
[GET_TEMP] -> 't53' alocado no registrador r7.
[ADD_INSTR] Adicionando instrução para 'sort': movi: r7 = 33

--- [TRANSLATE] Processando IR: t54 := t53 + t52 ---
[TRANSLATE] -> Detalhes: Destino='t54', Expressão='t53 + t52'
[TRANSLATE] -> Caminho: Operação Aritmética
[ENSURE] Tentando garantir 't53' em um registrador.
[ENSURE] -> Sucesso! 't53' já está em r7.
[ENSURE] Tentando garantir 't52' em um registrador.
[ENSURE] -> Sucesso! 't52' já está em r26.
[GET_TEMP] Solicitando registrador para o temporário 't54'.
[GET_FREE] -> Encontrado registrador livre: r8. Restantes: 14.
[ASSIGN_REG] Mapeando 't54' para r8.
[GET_TEMP] -> 't54' alocado no registrador r8.
[ADD_INSTR] Adicionando instrução para 'sort': add: r8 = r7, r26

--- [TRANSLATE] Processando IR: *t54 := t50 ---
[TRANSLATE] -> Detalhes: Destino='*t54', Expressão='t50'
[TRANSLATE] -> Caminho: Armazenar em Ponteiro (*)
[ENSURE] Tentando garantir 't50' em um registrador.
[ENSURE] -> Sucesso! 't50' já está em r4.
[TRANSLATE] -> Endereço de destino é uma variável temporária. Usando registrador temporário.
[ENSURE] Tentando garantir 't54' em um registrador.
[ENSURE] -> Sucesso! 't54' já está em r8.
[ADD_INSTR] Adicionando instrução para 'sort': store: [r8] = r4
[FREE_TEMP] Liberando registrador r4 que continha o temporário 't50'.
[UNASSIGN_REG] Desmapeado r4 de 't50'.
[UNASSIGN_REG] -> Estado atual: 14 registradores livres. Mapeamentos: {'t30': 'r19', 't36': 'r9', 't37': 'r11', 't38': 'r13', 't41': 'r16', 't42': 'r18', 't43': 'r17', 't46': 'r20', 't47': 'r22', 't48': 'r25', 't51': 'r5', 't52': 'r26', 't53': 'r7', 't54': 'r8'}
[UNASSIGN_REG] Desmapeado r8 de 't54'.
[UNASSIGN_REG] -> Estado atual: 15 registradores livres. Mapeamentos: {'t30': 'r19', 't36': 'r9', 't37': 'r11', 't38': 'r13', 't41': 'r16', 't42': 'r18', 't43': 'r17', 't46': 'r20', 't47': 'r22', 't48': 'r25', 't51': 'r5', 't52': 'r26', 't53': 'r7'}

--- [TRANSLATE] Processando IR: t55 := *i ---
[TRANSLATE] -> Detalhes: Destino='t55', Expressão='*i'
[TRANSLATE] -> Caminho: Carregar de Ponteiro (*)
[ENSURE] Tentando garantir 'i' em um registrador.
[ENSURE] -> Variável 'i' não está em um registrador. Carregando da memória.
[GET_FREE] -> Encontrado registrador livre: r10. Restantes: 14.
[GET_FREE] -> Encontrado registrador livre: r9. Restantes: 13.
[ADD_INSTR] Adicionando instrução para 'sort': movi: r9 = 39
[ENSURE] -> Usando r10 para o valor e r9 para o endereço 39.
[ADD_INSTR] Adicionando instrução para 'sort': load: r10 = [r9]
[ASSIGN_REG] Mapeando 'i' para r10.
[UNASSIGN_REG] Desmapeado r9 de 't36'.
[UNASSIGN_REG] -> Estado atual: 14 registradores livres. Mapeamentos: {'t30': 'r19', 't37': 'r11', 't38': 'r13', 't41': 'r16', 't42': 'r18', 't43': 'r17', 't46': 'r20', 't47': 'r22', 't48': 'r25', 't51': 'r5', 't52': 'r26', 't53': 'r7', 'i': 'r10'}
[UPDATE_MAP] Mapeando 't55' para o registrador r10 (que contém o valor de origem).
[ASSIGN_REG] Mapeando 't55' para r10.
[ASSIGN_REG] -> Registrador r10 já continha 'i'. Liberando o mapeamento antigo.
[UNASSIGN_REG] Desmapeado r10 de 'i'.
[UNASSIGN_REG] -> Estado atual: 15 registradores livres. Mapeamentos: {'t30': 'r19', 't37': 'r11', 't38': 'r13', 't41': 'r16', 't42': 'r18', 't43': 'r17', 't46': 'r20', 't47': 'r22', 't48': 'r25', 't51': 'r5', 't52': 'r26', 't53': 'r7'}
[TRANSLATE] -> Valor de 'i' agora em r10, mapeado para 't55'.

--- [TRANSLATE] Processando IR: t56 := t55 + 1 ---
[TRANSLATE] -> Detalhes: Destino='t56', Expressão='t55 + 1'
[TRANSLATE] -> Caminho: Operação Aritmética
[ENSURE] Tentando garantir 't55' em um registrador.
[ENSURE] -> Sucesso! 't55' já está em r10.
[TRANSLATE] -> Operando 2 é um imediato: 1
[GET_TEMP] Solicitando registrador para o temporário 't56'.
[GET_FREE] -> Encontrado registrador livre: r12. Restantes: 14.
[ASSIGN_REG] Mapeando 't56' para r12.
[GET_TEMP] -> 't56' alocado no registrador r12.
[ADD_INSTR] Adicionando instrução para 'sort': addi: r12 = r10, 1

--- [TRANSLATE] Processando IR: *i := t56 ---
[TRANSLATE] -> Detalhes: Destino='*i', Expressão='t56'
[TRANSLATE] -> Caminho: Armazenar em Ponteiro (*)
[ENSURE] Tentando garantir 't56' em um registrador.
[ENSURE] -> Sucesso! 't56' já está em r12.
[TRANSLATE] -> Endereço de destino é uma variável real. Obtendo endereço em registrador.
[GET_ADDR] Obtendo endereço para 'i'.
[GET_FREE] -> Encontrado registrador livre: r14. Restantes: 13.
[ADD_INSTR] Adicionando instrução para 'sort': movi: r14 = 39
[GET_ADDR] -> Endereço de 'i' (39) carregado em r14.
[ADD_INSTR] Adicionando instrução para 'sort': store: [r14] = r12
[FREE_TEMP] Liberando registrador r12 que continha o temporário 't56'.
[UNASSIGN_REG] Desmapeado r12 de 't56'.
[UNASSIGN_REG] -> Estado atual: 14 registradores livres. Mapeamentos: {'t30': 'r19', 't37': 'r11', 't38': 'r13', 't41': 'r16', 't42': 'r18', 't43': 'r17', 't46': 'r20', 't47': 'r22', 't48': 'r25', 't51': 'r5', 't52': 'r26', 't53': 'r7', 't55': 'r10'}
[UNASSIGN_REG] r14 já estava desmapeado.
[UNASSIGN_REG] -> Estado atual: 15 registradores livres. Mapeamentos: {'t30': 'r19', 't37': 'r11', 't38': 'r13', 't41': 'r16', 't42': 'r18', 't43': 'r17', 't46': 'r20', 't47': 'r22', 't48': 'r25', 't51': 'r5', 't52': 'r26', 't53': 'r7', 't55': 'r10'}

--- [TRANSLATE] Processando IR: goto L4 ---
[TRANSLATE] -> Desvio incondicional detectado: L4
[SPILL_ALL] Verificando registradores sujos para salvar antes da chamada de função. Sujos: {'r14', 'r21', 'r22', 'r17', 'r7', 'r13', 'r24', 'r11', 'r18', 'r26', 'r12', 'r4', 'r8', 'r19', 'r25'}
[ADD_INSTR] Adicionando instrução para 'sort': bi: L4

--- [TRANSLATE] Processando IR: L5: ---
[TRANSLATE] -> Rótulo detectado: L5:
[SPILL_ALL] Verificando registradores sujos para salvar antes da chamada de função. Sujos: {'r14', 'r21', 'r22', 'r17', 'r7', 'r13', 'r24', 'r11', 'r18', 'r26', 'r12', 'r4', 'r8', 'r19', 'r25'}
[ADD_INSTR] Adicionando instrução para 'sort': L5:

--- [TRANSLATE] Processando IR: return _ ---
[TRANSLATE] -> Caminho: Retorno de Função
[SPILL_ALL] Verificando registradores sujos para salvar antes da chamada de função. Sujos: {'r14', 'r21', 'r22', 'r17', 'r7', 'r13', 'r24', 'r11', 'r18', 'r26', 'r12', 'r4', 'r8', 'r19', 'r25'}
[ADD_INSTR] Adicionando instrução para 'sort': bi: sort_epilogue
-> Finalizando a função 'sort', fazendo spill de todos os registradores sujos.
[SPILL_ALL] Verificando registradores sujos para salvar antes da chamada de função. Sujos: {'r14', 'r21', 'r22', 'r17', 'r7', 'r13', 'r24', 'r11', 'r18', 'r26', 'r12', 'r4', 'r8', 'r19', 'r25'}

[Processando Função] -> 'main'
-> IR isolado para 'main' contém 39 instruções.

--- [TRANSLATE] Processando IR: *i := 0 ---
[TRANSLATE] -> Detalhes: Destino='*i', Expressão='0'
[TRANSLATE] -> Caminho: Armazenar em Ponteiro (*)
[ENSURE] Tentando garantir '0' em um registrador.
[GET_FREE] -> Encontrado registrador livre: r12. Restantes: 22.
[ENSURE] -> Alocando r12 para a constante '0'.
[ADD_INSTR] Adicionando instrução para 'main': movi: r12 = 0
[TRANSLATE] -> Endereço de destino é uma variável real. Obtendo endereço em registrador.
[GET_ADDR] Obtendo endereço para 'i'.
[GET_FREE] -> Encontrado registrador livre: r13. Restantes: 21.
[ADD_INSTR] Adicionando instrução para 'main': movi: r13 = 39
[GET_ADDR] -> Endereço de 'i' (39) carregado em r13.
[ADD_INSTR] Adicionando instrução para 'main': store: [r13] = r12
[UNASSIGN_REG] r13 já estava desmapeado.
[UNASSIGN_REG] -> Estado atual: 22 registradores livres. Mapeamentos: {}

--- [TRANSLATE] Processando IR: L6: ---
[TRANSLATE] -> Rótulo detectado: L6:
[SPILL_ALL] Verificando registradores sujos para salvar antes da chamada de função. Sujos: set()
[ADD_INSTR] Adicionando instrução para 'main': L6:

--- [TRANSLATE] Processando IR: t57 := *i ---
[TRANSLATE] -> Detalhes: Destino='t57', Expressão='*i'
[TRANSLATE] -> Caminho: Carregar de Ponteiro (*)
[ENSURE] Tentando garantir 'i' em um registrador.
[ENSURE] -> Variável 'i' não está em um registrador. Carregando da memória.
[GET_FREE] -> Encontrado registrador livre: r14. Restantes: 21.
[GET_FREE] -> Encontrado registrador livre: r15. Restantes: 20.
[ADD_INSTR] Adicionando instrução para 'main': movi: r15 = 39
[ENSURE] -> Usando r14 para o valor e r15 para o endereço 39.
[ADD_INSTR] Adicionando instrução para 'main': load: r14 = [r15]
[ASSIGN_REG] Mapeando 'i' para r14.
[UNASSIGN_REG] r15 já estava desmapeado.
[UNASSIGN_REG] -> Estado atual: 21 registradores livres. Mapeamentos: {'i': 'r14'}
[UPDATE_MAP] Mapeando 't57' para o registrador r14 (que contém o valor de origem).
[ASSIGN_REG] Mapeando 't57' para r14.
[ASSIGN_REG] -> Registrador r14 já continha 'i'. Liberando o mapeamento antigo.
[UNASSIGN_REG] Desmapeado r14 de 'i'.
[UNASSIGN_REG] -> Estado atual: 22 registradores livres. Mapeamentos: {}
[TRANSLATE] -> Valor de 'i' agora em r14, mapeado para 't57'.

--- [TRANSLATE] Processando IR: t58 := t57 < 10 ---
[TRANSLATE] -> Detalhes: Destino='t58', Expressão='t57 < 10'
[TRANSLATE] -> Caminho: Comparação (condicional)
[ENSURE] Tentando garantir 't57' em um registrador.
[ENSURE] -> Sucesso! 't57' já está em r14.
[ENSURE] Tentando garantir '10' em um registrador.
[GET_FREE] -> Encontrado registrador livre: r16. Restantes: 21.
[ENSURE] -> Alocando r16 para a constante '10'.
[ADD_INSTR] Adicionando instrução para 'main': movi: r16 = 10
[ADD_INSTR] Adicionando instrução para 'main': subs: r0 = r14, r16

--- [TRANSLATE] Processando IR: if_false t58 goto L7 ---
[TRANSLATE] -> Caminho: Desvio Condicional (if_false)
[ADD_INSTR] Adicionando instrução para 'main': bigteq: L7

--- [TRANSLATE] Processando IR: t59 := call input, 0 ---
[TRANSLATE] -> Detalhes: Destino='t59', Expressão='call input, 0'
[TRANSLATE] -> Caminho: Chamada de Função com Retorno
[SPILL_ALL] Verificando registradores sujos para salvar antes da chamada de função. Sujos: set()
[GET_TEMP] Solicitando registrador para o temporário 't59'.
[GET_FREE] -> Encontrado registrador livre: r17. Restantes: 20.
[ASSIGN_REG] Mapeando 't59' para r17.
[GET_TEMP] -> 't59' alocado no registrador r17.
[ADD_INSTR] Adicionando instrução para 'main': in: r17

--- [TRANSLATE] Processando IR: t60 := *i ---
[TRANSLATE] -> Detalhes: Destino='t60', Expressão='*i'
[TRANSLATE] -> Caminho: Carregar de Ponteiro (*)
[ENSURE] Tentando garantir 'i' em um registrador.
[ENSURE] -> Variável 'i' não está em um registrador. Carregando da memória.
[GET_FREE] -> Encontrado registrador livre: r18. Restantes: 19.
[GET_FREE] -> Encontrado registrador livre: r19. Restantes: 18.
[ADD_INSTR] Adicionando instrução para 'main': movi: r19 = 39
[ENSURE] -> Usando r18 para o valor e r19 para o endereço 39.
[ADD_INSTR] Adicionando instrução para 'main': load: r18 = [r19]
[ASSIGN_REG] Mapeando 'i' para r18.
[UNASSIGN_REG] r19 já estava desmapeado.
[UNASSIGN_REG] -> Estado atual: 19 registradores livres. Mapeamentos: {'t57': 'r14', 't59': 'r17', 'i': 'r18'}
[UPDATE_MAP] Mapeando 't60' para o registrador r18 (que contém o valor de origem).
[ASSIGN_REG] Mapeando 't60' para r18.
[ASSIGN_REG] -> Registrador r18 já continha 'i'. Liberando o mapeamento antigo.
[UNASSIGN_REG] Desmapeado r18 de 'i'.
[UNASSIGN_REG] -> Estado atual: 20 registradores livres. Mapeamentos: {'t57': 'r14', 't59': 'r17'}
[TRANSLATE] -> Valor de 'i' agora em r18, mapeado para 't60'.

--- [TRANSLATE] Processando IR: t61 := t60 * 4 ---
[TRANSLATE] -> Detalhes: Destino='t61', Expressão='t60 * 4'
[TRANSLATE] -> Caminho: Operação Aritmética
[ENSURE] Tentando garantir 't60' em um registrador.
[ENSURE] -> Sucesso! 't60' já está em r18.
[TRANSLATE] -> Operando 2 é um imediato: 4
[GET_TEMP] Solicitando registrador para o temporário 't61'.
[GET_FREE] -> Encontrado registrador livre: r20. Restantes: 19.
[ASSIGN_REG] Mapeando 't61' para r20.
[GET_TEMP] -> 't61' alocado no registrador r20.
[ADD_INSTR] Adicionando instrução para 'main': muli: r20 = r18, 4

--- [TRANSLATE] Processando IR: t62 := &vet ---
[TRANSLATE] -> Detalhes: Destino='t62', Expressão='&vet'
[TRANSLATE] -> Caminho: Obter Endereço (&)
[GET_TEMP] Solicitando registrador para o temporário 't62'.
[GET_FREE] -> Encontrado registrador livre: r21. Restantes: 18.
[ASSIGN_REG] Mapeando 't62' para r21.
[GET_TEMP] -> 't62' alocado no registrador r21.
[ADD_INSTR] Adicionando instrução para 'main': movi: r21 = 34

--- [TRANSLATE] Processando IR: t63 := t62 + t61 ---
[TRANSLATE] -> Detalhes: Destino='t63', Expressão='t62 + t61'
[TRANSLATE] -> Caminho: Operação Aritmética
[ENSURE] Tentando garantir 't62' em um registrador.
[ENSURE] -> Sucesso! 't62' já está em r21.
[ENSURE] Tentando garantir 't61' em um registrador.
[ENSURE] -> Sucesso! 't61' já está em r20.
[GET_TEMP] Solicitando registrador para o temporário 't63'.
[GET_FREE] -> Encontrado registrador livre: r22. Restantes: 17.
[ASSIGN_REG] Mapeando 't63' para r22.
[GET_TEMP] -> 't63' alocado no registrador r22.
[ADD_INSTR] Adicionando instrução para 'main': add: r22 = r21, r20

--- [TRANSLATE] Processando IR: *t63 := t59 ---
[TRANSLATE] -> Detalhes: Destino='*t63', Expressão='t59'
[TRANSLATE] -> Caminho: Armazenar em Ponteiro (*)
[ENSURE] Tentando garantir 't59' em um registrador.
[ENSURE] -> Sucesso! 't59' já está em r17.
[TRANSLATE] -> Endereço de destino é uma variável temporária. Usando registrador temporário.
[ENSURE] Tentando garantir 't63' em um registrador.
[ENSURE] -> Sucesso! 't63' já está em r22.
[ADD_INSTR] Adicionando instrução para 'main': store: [r22] = r17
[FREE_TEMP] Liberando registrador r17 que continha o temporário 't59'.
[UNASSIGN_REG] Desmapeado r17 de 't59'.
[UNASSIGN_REG] -> Estado atual: 18 registradores livres. Mapeamentos: {'t57': 'r14', 't60': 'r18', 't61': 'r20', 't62': 'r21', 't63': 'r22'}
[UNASSIGN_REG] Desmapeado r22 de 't63'.
[UNASSIGN_REG] -> Estado atual: 19 registradores livres. Mapeamentos: {'t57': 'r14', 't60': 'r18', 't61': 'r20', 't62': 'r21'}

--- [TRANSLATE] Processando IR: t64 := *i ---
[TRANSLATE] -> Detalhes: Destino='t64', Expressão='*i'
[TRANSLATE] -> Caminho: Carregar de Ponteiro (*)
[ENSURE] Tentando garantir 'i' em um registrador.
[ENSURE] -> Variável 'i' não está em um registrador. Carregando da memória.
[GET_FREE] -> Encontrado registrador livre: r23. Restantes: 18.
[GET_FREE] -> Encontrado registrador livre: r24. Restantes: 17.
[ADD_INSTR] Adicionando instrução para 'main': movi: r24 = 39
[ENSURE] -> Usando r23 para o valor e r24 para o endereço 39.
[ADD_INSTR] Adicionando instrução para 'main': load: r23 = [r24]
[ASSIGN_REG] Mapeando 'i' para r23.
[UNASSIGN_REG] r24 já estava desmapeado.
[UNASSIGN_REG] -> Estado atual: 18 registradores livres. Mapeamentos: {'t57': 'r14', 't60': 'r18', 't61': 'r20', 't62': 'r21', 'i': 'r23'}
[UPDATE_MAP] Mapeando 't64' para o registrador r23 (que contém o valor de origem).
[ASSIGN_REG] Mapeando 't64' para r23.
[ASSIGN_REG] -> Registrador r23 já continha 'i'. Liberando o mapeamento antigo.
[UNASSIGN_REG] Desmapeado r23 de 'i'.
[UNASSIGN_REG] -> Estado atual: 19 registradores livres. Mapeamentos: {'t57': 'r14', 't60': 'r18', 't61': 'r20', 't62': 'r21'}
[TRANSLATE] -> Valor de 'i' agora em r23, mapeado para 't64'.

--- [TRANSLATE] Processando IR: t65 := t64 + 1 ---
[TRANSLATE] -> Detalhes: Destino='t65', Expressão='t64 + 1'
[TRANSLATE] -> Caminho: Operação Aritmética
[ENSURE] Tentando garantir 't64' em um registrador.
[ENSURE] -> Sucesso! 't64' já está em r23.
[TRANSLATE] -> Operando 2 é um imediato: 1
[GET_TEMP] Solicitando registrador para o temporário 't65'.
[GET_FREE] -> Encontrado registrador livre: r25. Restantes: 18.
[ASSIGN_REG] Mapeando 't65' para r25.
[GET_TEMP] -> 't65' alocado no registrador r25.
[ADD_INSTR] Adicionando instrução para 'main': addi: r25 = r23, 1

--- [TRANSLATE] Processando IR: *i := t65 ---
[TRANSLATE] -> Detalhes: Destino='*i', Expressão='t65'
[TRANSLATE] -> Caminho: Armazenar em Ponteiro (*)
[ENSURE] Tentando garantir 't65' em um registrador.
[ENSURE] -> Sucesso! 't65' já está em r25.
[TRANSLATE] -> Endereço de destino é uma variável real. Obtendo endereço em registrador.
[GET_ADDR] Obtendo endereço para 'i'.
[GET_FREE] -> Encontrado registrador livre: r26. Restantes: 17.
[ADD_INSTR] Adicionando instrução para 'main': movi: r26 = 39
[GET_ADDR] -> Endereço de 'i' (39) carregado em r26.
[ADD_INSTR] Adicionando instrução para 'main': store: [r26] = r25
[FREE_TEMP] Liberando registrador r25 que continha o temporário 't65'.
[UNASSIGN_REG] Desmapeado r25 de 't65'.
[UNASSIGN_REG] -> Estado atual: 18 registradores livres. Mapeamentos: {'t57': 'r14', 't60': 'r18', 't61': 'r20', 't62': 'r21', 't64': 'r23'}
[UNASSIGN_REG] r26 já estava desmapeado.
[UNASSIGN_REG] -> Estado atual: 19 registradores livres. Mapeamentos: {'t57': 'r14', 't60': 'r18', 't61': 'r20', 't62': 'r21', 't64': 'r23'}

--- [TRANSLATE] Processando IR: goto L6 ---
[TRANSLATE] -> Desvio incondicional detectado: L6
[SPILL_ALL] Verificando registradores sujos para salvar antes da chamada de função. Sujos: {'r21', 'r22', 'r17', 'r20', 'r25'}
[ADD_INSTR] Adicionando instrução para 'main': bi: L6

--- [TRANSLATE] Processando IR: L7: ---
[TRANSLATE] -> Rótulo detectado: L7:
[SPILL_ALL] Verificando registradores sujos para salvar antes da chamada de função. Sujos: {'r21', 'r22', 'r17', 'r20', 'r25'}
[ADD_INSTR] Adicionando instrução para 'main': L7:

--- [TRANSLATE] Processando IR: t66 := *vet ---
[TRANSLATE] -> Detalhes: Destino='t66', Expressão='*vet'
[TRANSLATE] -> Caminho: Carregar de Ponteiro (*)
[ENSURE] Tentando garantir 'vet' em um registrador.
[ENSURE] -> Variável 'vet' não está em um registrador. Carregando da memória.
[GET_FREE] -> Encontrado registrador livre: r4. Restantes: 18.
[GET_FREE] -> Encontrado registrador livre: r5. Restantes: 17.
[ADD_INSTR] Adicionando instrução para 'main': movi: r5 = 34
[ENSURE] -> Usando r4 para o valor e r5 para o endereço 34.
[ADD_INSTR] Adicionando instrução para 'main': load: r4 = [r5]
[ASSIGN_REG] Mapeando 'vet' para r4.
[UNASSIGN_REG] r5 já estava desmapeado.
[UNASSIGN_REG] -> Estado atual: 18 registradores livres. Mapeamentos: {'t57': 'r14', 't60': 'r18', 't61': 'r20', 't62': 'r21', 't64': 'r23', 'vet': 'r4'}
[UPDATE_MAP] Mapeando 't66' para o registrador r4 (que contém o valor de origem).
[ASSIGN_REG] Mapeando 't66' para r4.
[ASSIGN_REG] -> Registrador r4 já continha 'vet'. Liberando o mapeamento antigo.
[UNASSIGN_REG] Desmapeado r4 de 'vet'.
[UNASSIGN_REG] -> Estado atual: 19 registradores livres. Mapeamentos: {'t57': 'r14', 't60': 'r18', 't61': 'r20', 't62': 'r21', 't64': 'r23'}
[TRANSLATE] -> Valor de 'vet' agora em r4, mapeado para 't66'.

--- [TRANSLATE] Processando IR: arg t66 ---
[TRANSLATE] -> Caminho: Passagem de Argumento (arg 1)
[ENSURE] Tentando garantir 't66' em um registrador.
[ENSURE] -> Sucesso! 't66' já está em r4.
[ADD_INSTR] Adicionando instrução para 'main': mov: r1 = r4

--- [TRANSLATE] Processando IR: arg 0 ---
[TRANSLATE] -> Caminho: Passagem de Argumento (arg 2)
[ENSURE] Tentando garantir '0' em um registrador.
[GET_FREE] -> Encontrado registrador livre: r6. Restantes: 18.
[ENSURE] -> Alocando r6 para a constante '0'.
[ADD_INSTR] Adicionando instrução para 'main': movi: r6 = 0
[ADD_INSTR] Adicionando instrução para 'main': mov: r2 = r6

--- [TRANSLATE] Processando IR: arg 10 ---
[TRANSLATE] -> Caminho: Passagem de Argumento (arg 3)
[ENSURE] Tentando garantir '10' em um registrador.
[GET_FREE] -> Encontrado registrador livre: r7. Restantes: 17.
[ENSURE] -> Alocando r7 para a constante '10'.
[ADD_INSTR] Adicionando instrução para 'main': movi: r7 = 10
[ADD_INSTR] Adicionando instrução para 'main': mov: r3 = r7

--- [TRANSLATE] Processando IR: call sort, 3 ---
[TRANSLATE] -> Caminho: Chamada de Procedimento
[GET_ADDR] Obtendo endereço para 'low'.
[GET_FREE] -> Encontrado registrador livre: r8. Restantes: 16.
[ADD_INSTR] Adicionando instrução para 'main': movi: r8 = 35
[GET_ADDR] -> Endereço de 'low' (35) carregado em r8.
[ADD_INSTR] Adicionando instrução para 'main': store: [r8] = r1
[UNASSIGN_REG] r8 já estava desmapeado.
[UNASSIGN_REG] -> Estado atual: 17 registradores livres. Mapeamentos: {'t57': 'r14', 't60': 'r18', 't61': 'r20', 't62': 'r21', 't64': 'r23', 't66': 'r4'}
[GET_ADDR] Obtendo endereço para 'high'.
[GET_FREE] -> Encontrado registrador livre: r9. Restantes: 16.
[ADD_INSTR] Adicionando instrução para 'main': movi: r9 = 40
[GET_ADDR] -> Endereço de 'high' (40) carregado em r9.
[ADD_INSTR] Adicionando instrução para 'main': store: [r9] = r2
[UNASSIGN_REG] r9 já estava desmapeado.
[UNASSIGN_REG] -> Estado atual: 17 registradores livres. Mapeamentos: {'t57': 'r14', 't60': 'r18', 't61': 'r20', 't62': 'r21', 't64': 'r23', 't66': 'r4'}
[GET_ADDR] Obtendo endereço para 'a'.
[GET_FREE] -> Encontrado registrador livre: r10. Restantes: 16.
[ADD_INSTR] Adicionando instrução para 'main': movi: r10 = 33
[GET_ADDR] -> Endereço de 'a' (33) carregado em r10.
[ADD_INSTR] Adicionando instrução para 'main': store: [r10] = r3
[UNASSIGN_REG] r10 já estava desmapeado.
[UNASSIGN_REG] -> Estado atual: 17 registradores livres. Mapeamentos: {'t57': 'r14', 't60': 'r18', 't61': 'r20', 't62': 'r21', 't64': 'r23', 't66': 'r4'}
[SPILL_ALL] Verificando registradores sujos para salvar antes da chamada de função. Sujos: {'r21', 'r22', 'r17', 'r20', 'r25'}
[ADD_INSTR] Adicionando instrução para 'main': movi: r28 = main_Lret0
[ADD_INSTR] Adicionando instrução para 'main': bl: sort
[ADD_INSTR] Adicionando instrução para 'main': main_Lret0:
[UNASSIGN_REG] Desmapeado r4 de 't66'.
[UNASSIGN_REG] -> Estado atual: 17 registradores livres. Mapeamentos: {'t57': 'r14', 't60': 'r18', 't61': 'r20', 't62': 'r21', 't64': 'r23'}

--- [TRANSLATE] Processando IR: *i := 0 ---
[TRANSLATE] -> Detalhes: Destino='*i', Expressão='0'
[TRANSLATE] -> Caminho: Armazenar em Ponteiro (*)
[ENSURE] Tentando garantir '0' em um registrador.
[GET_FREE] -> Encontrado registrador livre: r11. Restantes: 16.
[ENSURE] -> Alocando r11 para a constante '0'.
[ADD_INSTR] Adicionando instrução para 'main': movi: r11 = 0
[TRANSLATE] -> Endereço de destino é uma variável real. Obtendo endereço em registrador.
[GET_ADDR] Obtendo endereço para 'i'.
[GET_FREE] -> Encontrado registrador livre: r13. Restantes: 15.
[ADD_INSTR] Adicionando instrução para 'main': movi: r13 = 39
[GET_ADDR] -> Endereço de 'i' (39) carregado em r13.
[ADD_INSTR] Adicionando instrução para 'main': store: [r13] = r11
[UNASSIGN_REG] r13 já estava desmapeado.
[UNASSIGN_REG] -> Estado atual: 16 registradores livres. Mapeamentos: {'t57': 'r14', 't60': 'r18', 't61': 'r20', 't62': 'r21', 't64': 'r23'}

--- [TRANSLATE] Processando IR: L8: ---
[TRANSLATE] -> Rótulo detectado: L8:
[SPILL_ALL] Verificando registradores sujos para salvar antes da chamada de função. Sujos: {'r21', 'r22', 'r17', 'r20', 'r25'}
[ADD_INSTR] Adicionando instrução para 'main': L8:

--- [TRANSLATE] Processando IR: t67 := *i ---
[TRANSLATE] -> Detalhes: Destino='t67', Expressão='*i'
[TRANSLATE] -> Caminho: Carregar de Ponteiro (*)
[ENSURE] Tentando garantir 'i' em um registrador.
[ENSURE] -> Variável 'i' não está em um registrador. Carregando da memória.
[GET_FREE] -> Encontrado registrador livre: r15. Restantes: 15.
[GET_FREE] -> Encontrado registrador livre: r14. Restantes: 14.
[ADD_INSTR] Adicionando instrução para 'main': movi: r14 = 39
[ENSURE] -> Usando r15 para o valor e r14 para o endereço 39.
[ADD_INSTR] Adicionando instrução para 'main': load: r15 = [r14]
[ASSIGN_REG] Mapeando 'i' para r15.
[UNASSIGN_REG] Desmapeado r14 de 't57'.
[UNASSIGN_REG] -> Estado atual: 15 registradores livres. Mapeamentos: {'t60': 'r18', 't61': 'r20', 't62': 'r21', 't64': 'r23', 'i': 'r15'}
[UPDATE_MAP] Mapeando 't67' para o registrador r15 (que contém o valor de origem).
[ASSIGN_REG] Mapeando 't67' para r15.
[ASSIGN_REG] -> Registrador r15 já continha 'i'. Liberando o mapeamento antigo.
[UNASSIGN_REG] Desmapeado r15 de 'i'.
[UNASSIGN_REG] -> Estado atual: 16 registradores livres. Mapeamentos: {'t60': 'r18', 't61': 'r20', 't62': 'r21', 't64': 'r23'}
[TRANSLATE] -> Valor de 'i' agora em r15, mapeado para 't67'.

--- [TRANSLATE] Processando IR: t68 := t67 < 10 ---
[TRANSLATE] -> Detalhes: Destino='t68', Expressão='t67 < 10'
[TRANSLATE] -> Caminho: Comparação (condicional)
[ENSURE] Tentando garantir 't67' em um registrador.
[ENSURE] -> Sucesso! 't67' já está em r15.
[ENSURE] Tentando garantir '10' em um registrador.
[GET_FREE] -> Encontrado registrador livre: r19. Restantes: 15.
[ENSURE] -> Alocando r19 para a constante '10'.
[ADD_INSTR] Adicionando instrução para 'main': movi: r19 = 10
[ADD_INSTR] Adicionando instrução para 'main': subs: r0 = r15, r19

--- [TRANSLATE] Processando IR: if_false t68 goto L9 ---
[TRANSLATE] -> Caminho: Desvio Condicional (if_false)
[ADD_INSTR] Adicionando instrução para 'main': bigteq: L9

--- [TRANSLATE] Processando IR: t69 := *i ---
[TRANSLATE] -> Detalhes: Destino='t69', Expressão='*i'
[TRANSLATE] -> Caminho: Carregar de Ponteiro (*)
[ENSURE] Tentando garantir 'i' em um registrador.
[ENSURE] -> Variável 'i' não está em um registrador. Carregando da memória.
[GET_FREE] -> Encontrado registrador livre: r18. Restantes: 14.
[GET_FREE] -> Encontrado registrador livre: r17. Restantes: 13.
[ADD_INSTR] Adicionando instrução para 'main': movi: r17 = 39
[ENSURE] -> Usando r18 para o valor e r17 para o endereço 39.
[ADD_INSTR] Adicionando instrução para 'main': load: r18 = [r17]
[ASSIGN_REG] Mapeando 'i' para r18.
[ASSIGN_REG] -> Registrador r18 já continha 't60'. Liberando o mapeamento antigo.
[UNASSIGN_REG] Desmapeado r18 de 't60'.
[UNASSIGN_REG] -> Estado atual: 14 registradores livres. Mapeamentos: {'t61': 'r20', 't62': 'r21', 't64': 'r23', 't67': 'r15'}
[UNASSIGN_REG] r17 já estava desmapeado.
[UNASSIGN_REG] -> Estado atual: 15 registradores livres. Mapeamentos: {'t61': 'r20', 't62': 'r21', 't64': 'r23', 't67': 'r15', 'i': 'r18'}
[UPDATE_MAP] Mapeando 't69' para o registrador r18 (que contém o valor de origem).
[ASSIGN_REG] Mapeando 't69' para r18.
[ASSIGN_REG] -> Registrador r18 já continha 'i'. Liberando o mapeamento antigo.
[UNASSIGN_REG] Desmapeado r18 de 'i'.
[UNASSIGN_REG] -> Estado atual: 15 registradores livres. Mapeamentos: {'t61': 'r20', 't62': 'r21', 't64': 'r23', 't67': 'r15'}
[TRANSLATE] -> Valor de 'i' agora em r18, mapeado para 't69'.

--- [TRANSLATE] Processando IR: t70 := t69 * 4 ---
[TRANSLATE] -> Detalhes: Destino='t70', Expressão='t69 * 4'
[TRANSLATE] -> Caminho: Operação Aritmética
[ENSURE] Tentando garantir 't69' em um registrador.
[ENSURE] -> Sucesso! 't69' já está em r18.
[TRANSLATE] -> Operando 2 é um imediato: 4
[GET_TEMP] Solicitando registrador para o temporário 't70'.
[GET_FREE] -> Encontrado registrador livre: r22. Restantes: 14.
[ASSIGN_REG] Mapeando 't70' para r22.
[GET_TEMP] -> 't70' alocado no registrador r22.
[ADD_INSTR] Adicionando instrução para 'main': muli: r22 = r18, 4

--- [TRANSLATE] Processando IR: t71 := &vet ---
[TRANSLATE] -> Detalhes: Destino='t71', Expressão='&vet'
[TRANSLATE] -> Caminho: Obter Endereço (&)
[GET_TEMP] Solicitando registrador para o temporário 't71'.
[GET_FREE] -> Encontrado registrador livre: r24. Restantes: 13.
[ASSIGN_REG] Mapeando 't71' para r24.
[GET_TEMP] -> 't71' alocado no registrador r24.
[ADD_INSTR] Adicionando instrução para 'main': movi: r24 = 34

--- [TRANSLATE] Processando IR: t72 := t71 + t70 ---
[TRANSLATE] -> Detalhes: Destino='t72', Expressão='t71 + t70'
[TRANSLATE] -> Caminho: Operação Aritmética
[ENSURE] Tentando garantir 't71' em um registrador.
[ENSURE] -> Sucesso! 't71' já está em r24.
[ENSURE] Tentando garantir 't70' em um registrador.
[ENSURE] -> Sucesso! 't70' já está em r22.
[GET_TEMP] Solicitando registrador para o temporário 't72'.
[GET_FREE] -> Encontrado registrador livre: r23. Restantes: 12.
[ASSIGN_REG] Mapeando 't72' para r23.
[ASSIGN_REG] -> Registrador r23 já continha 't64'. Liberando o mapeamento antigo.
[UNASSIGN_REG] Desmapeado r23 de 't64'.
[UNASSIGN_REG] -> Estado atual: 13 registradores livres. Mapeamentos: {'t61': 'r20', 't62': 'r21', 't67': 'r15', 't69': 'r18', 't70': 'r22', 't71': 'r24'}
[GET_TEMP] -> 't72' alocado no registrador r23.
[ADD_INSTR] Adicionando instrução para 'main': add: r23 = r24, r22

--- [TRANSLATE] Processando IR: t73 := *t72 ---
[TRANSLATE] -> Detalhes: Destino='t73', Expressão='*t72'
[TRANSLATE] -> Caminho: Carregar de Ponteiro (*)
[ENSURE] Tentando garantir 't72' em um registrador.
[ENSURE] -> Sucesso! 't72' já está em r23.
[UPDATE_MAP] Mapeando 't73' para o registrador r23 (que contém o valor de origem).
[ASSIGN_REG] Mapeando 't73' para r23.
[ASSIGN_REG] -> Registrador r23 já continha 't72'. Liberando o mapeamento antigo.
[UNASSIGN_REG] Desmapeado r23 de 't72'.
[UNASSIGN_REG] -> Estado atual: 13 registradores livres. Mapeamentos: {'t61': 'r20', 't62': 'r21', 't67': 'r15', 't69': 'r18', 't70': 'r22', 't71': 'r24'}
[TRANSLATE] -> Valor de 't72' agora em r23, mapeado para 't73'.

--- [TRANSLATE] Processando IR: arg t73 ---
[TRANSLATE] -> Caminho: Passagem de Argumento (arg 1)
[ENSURE] Tentando garantir 't73' em um registrador.
[ENSURE] -> Sucesso! 't73' já está em r23.
[ADD_INSTR] Adicionando instrução para 'main': mov: r1 = r23

--- [TRANSLATE] Processando IR: call output, 1 ---
[TRANSLATE] -> Caminho: Chamada de Procedimento
[SPILL_ALL] Verificando registradores sujos para salvar antes da chamada de função. Sujos: {'r21', 'r22', 'r23', 'r17', 'r24', 'r20', 'r25'}
[ADD_INSTR] Adicionando instrução para 'main': out: r1
[UNASSIGN_REG] Desmapeado r23 de 't73'.
[UNASSIGN_REG] -> Estado atual: 13 registradores livres. Mapeamentos: {'t61': 'r20', 't62': 'r21', 't67': 'r15', 't69': 'r18', 't70': 'r22', 't71': 'r24'}

--- [TRANSLATE] Processando IR: t74 := *i ---
[TRANSLATE] -> Detalhes: Destino='t74', Expressão='*i'
[TRANSLATE] -> Caminho: Carregar de Ponteiro (*)
[ENSURE] Tentando garantir 'i' em um registrador.
[ENSURE] -> Variável 'i' não está em um registrador. Carregando da memória.
[GET_FREE] -> Encontrado registrador livre: r25. Restantes: 12.
[GET_FREE] -> Encontrado registrador livre: r26. Restantes: 11.
[ADD_INSTR] Adicionando instrução para 'main': movi: r26 = 39
[ENSURE] -> Usando r25 para o valor e r26 para o endereço 39.
[ADD_INSTR] Adicionando instrução para 'main': load: r25 = [r26]
[ASSIGN_REG] Mapeando 'i' para r25.
[UNASSIGN_REG] r26 já estava desmapeado.
[UNASSIGN_REG] -> Estado atual: 12 registradores livres. Mapeamentos: {'t61': 'r20', 't62': 'r21', 't67': 'r15', 't69': 'r18', 't70': 'r22', 't71': 'r24', 'i': 'r25'}
[UPDATE_MAP] Mapeando 't74' para o registrador r25 (que contém o valor de origem).
[ASSIGN_REG] Mapeando 't74' para r25.
[ASSIGN_REG] -> Registrador r25 já continha 'i'. Liberando o mapeamento antigo.
[UNASSIGN_REG] Desmapeado r25 de 'i'.
[UNASSIGN_REG] -> Estado atual: 13 registradores livres. Mapeamentos: {'t61': 'r20', 't62': 'r21', 't67': 'r15', 't69': 'r18', 't70': 'r22', 't71': 'r24'}
[TRANSLATE] -> Valor de 'i' agora em r25, mapeado para 't74'.

--- [TRANSLATE] Processando IR: t75 := t74 + 1 ---
[TRANSLATE] -> Detalhes: Destino='t75', Expressão='t74 + 1'
[TRANSLATE] -> Caminho: Operação Aritmética
[ENSURE] Tentando garantir 't74' em um registrador.
[ENSURE] -> Sucesso! 't74' já está em r25.
[TRANSLATE] -> Operando 2 é um imediato: 1
[GET_TEMP] Solicitando registrador para o temporário 't75'.
[GET_FREE] -> Encontrado registrador livre: r5. Restantes: 12.
[ASSIGN_REG] Mapeando 't75' para r5.
[GET_TEMP] -> 't75' alocado no registrador r5.
[ADD_INSTR] Adicionando instrução para 'main': addi: r5 = r25, 1

--- [TRANSLATE] Processando IR: *i := t75 ---
[TRANSLATE] -> Detalhes: Destino='*i', Expressão='t75'
[TRANSLATE] -> Caminho: Armazenar em Ponteiro (*)
[ENSURE] Tentando garantir 't75' em um registrador.
[ENSURE] -> Sucesso! 't75' já está em r5.
[TRANSLATE] -> Endereço de destino é uma variável real. Obtendo endereço em registrador.
[GET_ADDR] Obtendo endereço para 'i'.
[GET_FREE] -> Encontrado registrador livre: r4. Restantes: 11.
[ADD_INSTR] Adicionando instrução para 'main': movi: r4 = 39
[GET_ADDR] -> Endereço de 'i' (39) carregado em r4.
[ADD_INSTR] Adicionando instrução para 'main': store: [r4] = r5
[FREE_TEMP] Liberando registrador r5 que continha o temporário 't75'.
[UNASSIGN_REG] Desmapeado r5 de 't75'.
[UNASSIGN_REG] -> Estado atual: 12 registradores livres. Mapeamentos: {'t61': 'r20', 't62': 'r21', 't67': 'r15', 't69': 'r18', 't70': 'r22', 't71': 'r24', 't74': 'r25'}
[UNASSIGN_REG] r4 já estava desmapeado.
[UNASSIGN_REG] -> Estado atual: 13 registradores livres. Mapeamentos: {'t61': 'r20', 't62': 'r21', 't67': 'r15', 't69': 'r18', 't70': 'r22', 't71': 'r24', 't74': 'r25'}

--- [TRANSLATE] Processando IR: goto L8 ---
[TRANSLATE] -> Desvio incondicional detectado: L8
[SPILL_ALL] Verificando registradores sujos para salvar antes da chamada de função. Sujos: {'r21', 'r22', 'r17', 'r24', 'r20', 'r5', 'r25'}
[ADD_INSTR] Adicionando instrução para 'main': bi: L8

--- [TRANSLATE] Processando IR: L9: ---
[TRANSLATE] -> Rótulo detectado: L9:
[SPILL_ALL] Verificando registradores sujos para salvar antes da chamada de função. Sujos: {'r21', 'r22', 'r17', 'r24', 'r20', 'r5', 'r25'}
[ADD_INSTR] Adicionando instrução para 'main': L9:

--- [TRANSLATE] Processando IR: return _ ---
[TRANSLATE] -> Caminho: Retorno de Função
[SPILL_ALL] Verificando registradores sujos para salvar antes da chamada de função. Sujos: {'r21', 'r22', 'r17', 'r24', 'r20', 'r5', 'r25'}
[ADD_INSTR] Adicionando instrução para 'main': bi: main_epilogue
-> Finalizando a função 'main', fazendo spill de todos os registradores sujos.
[SPILL_ALL] Verificando registradores sujos para salvar antes da chamada de função. Sujos: {'r21', 'r22', 'r17', 'r24', 'r20', 'r5', 'r25'}
--- Fim da Passagem 2 ---

--- Montagem Final: Construindo o arquivo assembly completo ---
[Montagem] Processando função 'minloc' com 58 instruções.
[Montagem] Adicionando código de inicialização (ida para a função 'main').
[Montagem] Adicionando código para a função 'minloc'.
[Montagem] Processando função 'sort' com 65 instruções.
[Montagem] Adicionando código para a função 'sort'.
[Montagem] Processando função 'main' com 63 instruções.
[Montagem] Adicionando código para a função 'main'.
[Montagem] Adicionando a seção .data.
[Montagem] -> Variáveis a serem declaradas: ['_', 'a', 'vet', 'low', 'x', 't', 'k', 'i', 'high']
=== GERAÇÃO DE ASSEMBLY CONCLUÍDA ===
--- ASSEMBLY CODE READY FOR YOUR ASSEMBLER ---
.text
.global main

	bi: main
minloc:
	subi: r29 = r29, 1
	store: [r29] = r28
	subi: r29 = r29, 1
	store: [r29] = r31
	mov: r31 = r29
	movi: r13 = 35
	load: r12 = [r13]
	movi: r14 = 38
	store: [r14] = r12
	movi: r16 = 35
	load: r15 = [r16]
	muli: r17 = r15, 4
	movi: r18 = 33
	add: r19 = r18, r17
	movi: r20 = 36
	store: [r20] = r19
	movi: r22 = 35
	load: r21 = [r22]
	addi: r23 = r21, 1
	movi: r24 = 39
	store: [r24] = r23
L0:
	movi: r26 = 39
	load: r25 = [r26]
	movi: r5 = 40
	load: r4 = [r5]
	subs: r0 = r25, r4
	bigteq: L1
	movi: r7 = 39
	load: r6 = [r7]
	muli: r8 = r6, 4
	movi: r9 = 33
	add: r10 = r9, r8
	movi: r13 = 36
	load: r11 = [r13]
	subs: r0 = r10, r11
	bigteq: L2
	movi: r14 = 39
	load: r12 = [r14]
	muli: r16 = r12, 4
	movi: r15 = 33
	add: r19 = r15, r16
	movi: r20 = 36
	store: [r20] = r19
	movi: r21 = 39
	load: r22 = [r21]
	movi: r23 = 38
	store: [r23] = r22
	bi: L3
L2:
L3:
	movi: r26 = 39
	load: r24 = [r26]
	addi: r25 = r24, 1
	movi: r5 = 39
	store: [r5] = r25
	bi: L0
L1:
	movi: r7 = 38
	load: r4 = [r7]
	mov: r0 = r4
	bi: minloc_epilogue
	bi: minloc_epilogue
minloc_epilogue:
	mov: r29 = r31
	load: r31 = [r29]
	addi: r29 = r29, 1
	load: r28 = [r29]
	addi: r29 = r29, 1
	b: r28

sort:
	subi: r29 = r29, 1
	store: [r29] = r28
	subi: r29 = r29, 1
	store: [r29] = r31
	mov: r31 = r29
	movi: r13 = 35
	load: r12 = [r13]
	movi: r14 = 39
	store: [r14] = r12
L4:
	movi: r16 = 39
	load: r15 = [r16]
	movi: r18 = 40
	load: r17 = [r18]
	subi: r19 = r17, 1
	subs: r0 = r15, r19
	bigteq: L5
	movi: r21 = 33
	load: r20 = [r21]
	mov: r1 = r20
	movi: r23 = 39
	load: r22 = [r23]
	mov: r2 = r22
	movi: r25 = 40
	load: r24 = [r25]
	mov: r3 = r24
	movi: r4 = 35
	store: [r4] = r1
	movi: r5 = 33
	store: [r5] = r2
	movi: r6 = 40
	store: [r6] = r3
	movi: r26 = sort_Lret0
	mov: r28 = r26
	bl: minloc
sort_Lret0:
	mov: r7 = r0
	movi: r8 = 38
	store: [r8] = r7
	movi: r10 = 38
	load: r9 = [r10]
	muli: r11 = r9, 4
	movi: r13 = 33
	add: r12 = r13, r11
	store: [r14] = r12
	movi: r15 = 39
	load: r16 = [r15]
	muli: r18 = r16, 4
	movi: r17 = 33
	add: r21 = r17, r18
	movi: r23 = 38
	load: r20 = [r23]
	muli: r22 = r20, 4
	movi: r25 = 33
	add: r24 = r25, r22
	store: [r24] = r21
	movi: r6 = 39
	load: r5 = [r6]
	muli: r26 = r5, 4
	movi: r7 = 33
	add: r8 = r7, r26
	store: [r8] = r4
	movi: r9 = 39
	load: r10 = [r9]
	addi: r12 = r10, 1
	movi: r14 = 39
	store: [r14] = r12
	bi: L4
L5:
	bi: sort_epilogue
sort_epilogue:
	mov: r29 = r31
	load: r31 = [r29]
	addi: r29 = r29, 1
	load: r28 = [r29]
	addi: r29 = r29, 1
	b: r28

main:
	movi: r29 = stack_space
	mov: r31 = r29
	movi: r12 = 0
	movi: r13 = 39
	store: [r13] = r12
L6:
	movi: r15 = 39
	load: r14 = [r15]
	movi: r16 = 10
	subs: r0 = r14, r16
	bigteq: L7
	in: r17
	movi: r19 = 39
	load: r18 = [r19]
	muli: r20 = r18, 4
	movi: r21 = 34
	add: r22 = r21, r20
	store: [r22] = r17
	movi: r24 = 39
	load: r23 = [r24]
	addi: r25 = r23, 1
	movi: r26 = 39
	store: [r26] = r25
	bi: L6
L7:
	movi: r5 = 34
	load: r4 = [r5]
	mov: r1 = r4
	movi: r6 = 0
	mov: r2 = r6
	movi: r7 = 10
	mov: r3 = r7
	movi: r8 = 35
	store: [r8] = r1
	movi: r9 = 40
	store: [r9] = r2
	movi: r10 = 33
	store: [r10] = r3
	movi: r28 = main_Lret0
	bl: sort
main_Lret0:
	movi: r11 = 0
	movi: r13 = 39
	store: [r13] = r11
L8:
	movi: r14 = 39
	load: r15 = [r14]
	movi: r19 = 10
	subs: r0 = r15, r19
	bigteq: L9
	movi: r17 = 39
	load: r18 = [r17]
	muli: r22 = r18, 4
	movi: r24 = 34
	add: r23 = r24, r22
	mov: r1 = r23
	out: r1
	movi: r26 = 39
	load: r25 = [r26]
	addi: r5 = r25, 1
	movi: r4 = 39
	store: [r4] = r5
	bi: L8
L9:
	bi: main_epilogue
main_epilogue:
	mov: r29 = r31
	load: r31 = [r29]
	addi: r29 = r29, 1
	load: r28 = [r29]
	addi: r29 = r29, 1
	ret:

.data
stack_space: .space 64
var__: .word 32
var_a: .word 33
var_vet: .word 34
var_low: .word 35
var_x: .word 36
var_t: .word 37
var_k: .word 38
var_i: .word 39
var_high: .word 40
---------------------------------------------


=== INICIANDO PROCESSO DE MONTAGEM (FullCode) ===
[INIT] Executando a primeira passagem para construir a tabela de símbolos...

--- [PASS 1] Iniciando a Primeira Passagem ---
[PASS 1] Etapa 1: Prevendo o tamanho de cada instrução na seção .text...

[DEBUG PASS 1] Tabela de Símbolos Final:
{
  "output": 1
}
--- Fim do Debug ---


[PASS 1] Etapa 2: Mapeando os rótulos de código para endereços...
[PASS 1] -> Rótulo 'minloc' mapeado para o endereço 1.
[PASS 1] -> Rótulo 'L0' mapeado para o endereço 22.
[PASS 1] -> Rótulo 'L2' mapeado para o endereço 49.
[PASS 1] -> Rótulo 'L3' mapeado para o endereço 49.
[PASS 1] -> Rótulo 'L1' mapeado para o endereço 55.
[PASS 1] -> Rótulo 'minloc_epilogue' mapeado para o endereço 60.
[PASS 1] -> Rótulo 'sort' mapeado para o endereço 66.
[PASS 1] -> Rótulo 'L4' mapeado para o endereço 75.
[PASS 1] -> Rótulo 'sort_Lret0' mapeado para o endereço 100.
[PASS 1] -> Rótulo 'L5' mapeado para o endereço 132.
[PASS 1] -> Rótulo 'sort_epilogue' mapeado para o endereço 133.
[PASS 1] -> Rótulo 'main' mapeado para o endereço 139.
[PASS 1] -> Rótulo 'L6' mapeado para o endereço 144.
[PASS 1] -> Rótulo 'L7' mapeado para o endereço 162.
[PASS 1] -> Rótulo 'main_Lret0' mapeado para o endereço 177.
[PASS 1] -> Rótulo 'L8' mapeado para o endereço 180.
[PASS 1] -> Rótulo 'L9' mapeado para o endereço 198.
[PASS 1] -> Rótulo 'main_epilogue' mapeado para o endereço 199.

[PASS 1] Etapa 3: A seção de código termina no endereço 204. A seção .data começará em 205.

[PASS 1] Etapa 4: Mapeando os rótulos da seção .data...
[PASS 1] -> Rótulo de dados 'stack_space' mapeado para o endereço 205.
[PASS 1] -> Rótulo de dados 'var__' mapeado para o endereço 205.
[PASS 1] -> Rótulo de dados 'var_a' mapeado para o endereço 206.
[PASS 1] -> Rótulo de dados 'var_vet' mapeado para o endereço 207.
[PASS 1] -> Rótulo de dados 'var_low' mapeado para o endereço 208.
[PASS 1] -> Rótulo de dados 'var_x' mapeado para o endereço 209.
[PASS 1] -> Rótulo de dados 'var_t' mapeado para o endereço 210.
[PASS 1] -> Rótulo de dados 'var_k' mapeado para o endereço 211.
[PASS 1] -> Rótulo de dados 'var_i' mapeado para o endereço 212.
[PASS 1] -> Rótulo de dados 'var_high' mapeado para o endereço 213.
--- Fim da Primeira Passagem ---
[INIT] Tabela de símbolos após a primeira passagem: {'output': 1, 'minloc': 1, 'L0': 22, 'L2': 49, 'L3': 49, 'L1': 55, 'minloc_epilogue': 60, 'sort': 66, 'L4': 75, 'sort_Lret0': 100, 'L5': 132, 'sort_epilogue': 133, 'main': 139, 'L6': 144, 'L7': 162, 'main_Lret0': 177, 'L8': 180, 'L9': 198, 'main_epilogue': 199, 'stack_space': 205, 'var__': 205, 'var_a': 206, 'var_vet': 207, 'var_low': 208, 'var_x': 209, 'var_t': 210, 'var_k': 211, 'var_i': 212, 'var_high': 213}
[INIT] Executando a segunda passagem para codificar as instruções...

--- [PASS 2] Iniciando a Segunda Passagem ---
[PASS 2] Etapa 1: Coletando literais grandes e atribuindo endereços a eles...
[PASS 2] -> Linha 9 ('mov: r31 = r29') é uma instrução 'mov' sem imediato. Ignorando para literais.
[PASS 2] -> Linha 65 ('mov: r0 = r4') é uma instrução 'mov' sem imediato. Ignorando para literais.
[PASS 2] -> Linha 69 ('mov: r29 = r31') é uma instrução 'mov' sem imediato. Ignorando para literais.
[PASS 2] -> Linha 80 ('mov: r31 = r29') é uma instrução 'mov' sem imediato. Ignorando para literais.
[PASS 2] -> Linha 95 ('mov: r1 = r20') é uma instrução 'mov' sem imediato. Ignorando para literais.
[PASS 2] -> Linha 98 ('mov: r2 = r22') é uma instrução 'mov' sem imediato. Ignorando para literais.
[PASS 2] -> Linha 101 ('mov: r3 = r24') é uma instrução 'mov' sem imediato. Ignorando para literais.
[PASS 2] -> Linha 109 ('mov: r28 = r26') é uma instrução 'mov' sem imediato. Ignorando para literais.
[PASS 2] -> Linha 112 ('mov: r7 = r0') é uma instrução 'mov' sem imediato. Ignorando para literais.
[PASS 2] -> Linha 147 ('mov: r29 = r31') é uma instrução 'mov' sem imediato. Ignorando para literais.
[PASS 2] -> Linha 155 ('mov: r31 = r29') é uma instrução 'mov' sem imediato. Ignorando para literais.
[PASS 2] -> Linha 181 ('mov: r1 = r4') é uma instrução 'mov' sem imediato. Ignorando para literais.
[PASS 2] -> Linha 183 ('mov: r2 = r6') é uma instrução 'mov' sem imediato. Ignorando para literais.
[PASS 2] -> Linha 185 ('mov: r3 = r7') é uma instrução 'mov' sem imediato. Ignorando para literais.
[PASS 2] -> Linha 209 ('mov: r1 = r23') é uma instrução 'mov' sem imediato. Ignorando para literais.
[PASS 2] -> Linha 210 ('out: r1') é uma instrução 'out'. Ignorando para literais.
[PASS 2] -> Linha 220 ('mov: r29 = r31') é uma instrução 'mov' sem imediato. Ignorando para literais.
[PASS 2] -> Nenhum literal grande encontrado.

[PASS 2] Etapa 2: Codificando cada linha de instrução para binário...

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'bi: main' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'bi: main'
[DISASSEMBLE] -> Parte do opcode: 'bi', Parte dos operandos: 'main'
[DISASSEMBLE] -> Instrução de branch identificada: 'bi'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'i', 'opcode': 'b', 'type': '11', 'op2': 'main'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'b', 'type': '11', 'op2': 'main'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'b', 'type': '11', 'op2': 'main'}
[ENCODE] -> Instrução de branch detectada: b com condição do
[ENCODE] -> Próximo endereço de instrução: 1
[INSTRUCTION] -> Codificação concluída. Binário: 00001110000000000000000010001010

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'subi: r29 = r29, 1' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'subi: r29 = r29, 1'
[DISASSEMBLE] -> Parte do opcode: 'subi', Parte dos operandos: 'r29 = r29, 1'
[DISASSEMBLE] -> Sufixo de suporte encontrado: 'i'. Opcode final é 'sub'
[DISASSEMBLE] -> Opcode final: 'sub', Tipo: 00
[DISASSEMBLE] -> Instrução com atribuição. Destino: 'r29', Origem: 'r29, 1'
[DISASSEMBLE] -> Operandos finais: Rd='r29', Rh='r29', Op2='1'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'i', 'opcode': 'sub', 'type': '00', 'rd': 'r29', 'rh': 'r29', 'op2': '1'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'sub', 'type': '00', 'rd': 'r29', 'rh': 'r29', 'op2': '1'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'sub', 'type': '00', 'rd': 'r29', 'rh': 'r29', 'op2': '1'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000010000111101111010000000001

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'store: [r29] = r28' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'store: [r29] = r28'
[DISASSEMBLE] -> Parte do opcode: 'store', Parte dos operandos: '[r29] = r28'
[DISASSEMBLE] -> Opcode final: 'store', Tipo: 01
[DISASSEMBLE] -> Instrução Store com endereçamento por registrador. Dest detectado: [r29]. Source detectado: 'r28'
[DISASSEMBLE] -> Instrução Load/Store com endereçamento por registrador.
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'na', 'opcode': 'store', 'type': '01', 'rd': 'r0', 'op2': 'r29', 'rh': 'r28'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'store', 'type': '01', 'rd': 'r0', 'op2': 'r29', 'rh': 'r28'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'store', 'type': '01', 'rd': 'r0', 'op2': 'r29', 'rh': 'r28'}
[ENCODE] -> Instrução Store detectada.
[ENCODE] -> rd_bin, rh_bin calculados: Rd(r0)=:00000 e Rh(r28)=:11100
[ENCODE] -> Op2 é um registrador: r29, convertido para binário: 1110100000
[INSTRUCTION] -> Codificação concluída. Binário: 00000100000000000111001110100000

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'subi: r29 = r29, 1' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'subi: r29 = r29, 1'
[DISASSEMBLE] -> Parte do opcode: 'subi', Parte dos operandos: 'r29 = r29, 1'
[DISASSEMBLE] -> Sufixo de suporte encontrado: 'i'. Opcode final é 'sub'
[DISASSEMBLE] -> Opcode final: 'sub', Tipo: 00
[DISASSEMBLE] -> Instrução com atribuição. Destino: 'r29', Origem: 'r29, 1'
[DISASSEMBLE] -> Operandos finais: Rd='r29', Rh='r29', Op2='1'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'i', 'opcode': 'sub', 'type': '00', 'rd': 'r29', 'rh': 'r29', 'op2': '1'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'sub', 'type': '00', 'rd': 'r29', 'rh': 'r29', 'op2': '1'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'sub', 'type': '00', 'rd': 'r29', 'rh': 'r29', 'op2': '1'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000010000111101111010000000001

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'store: [r29] = r31' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'store: [r29] = r31'
[DISASSEMBLE] -> Parte do opcode: 'store', Parte dos operandos: '[r29] = r31'
[DISASSEMBLE] -> Opcode final: 'store', Tipo: 01
[DISASSEMBLE] -> Instrução Store com endereçamento por registrador. Dest detectado: [r29]. Source detectado: 'r31'
[DISASSEMBLE] -> Instrução Load/Store com endereçamento por registrador.
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'na', 'opcode': 'store', 'type': '01', 'rd': 'r0', 'op2': 'r29', 'rh': 'r31'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'store', 'type': '01', 'rd': 'r0', 'op2': 'r29', 'rh': 'r31'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'store', 'type': '01', 'rd': 'r0', 'op2': 'r29', 'rh': 'r31'}
[ENCODE] -> Instrução Store detectada.
[ENCODE] -> rd_bin, rh_bin calculados: Rd(r0)=:00000 e Rh(r31)=:11111
[ENCODE] -> Op2 é um registrador: r29, convertido para binário: 1110100000
[INSTRUCTION] -> Codificação concluída. Binário: 00000100000000000111111110100000

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'mov: r31 = r29' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'mov: r31 = r29'
[DISASSEMBLE] -> Parte do opcode: 'mov', Parte dos operandos: 'r31 = r29'
[DISASSEMBLE] -> Opcode final: 'mov', Tipo: 00
[DISASSEMBLE] -> Instrução 'mov' identificada. Destino: 'r31', Origem: 'r29'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'na', 'opcode': 'mov', 'type': '00', 'rd': 'r31', 'rh': 'r0', 'op2': 'r29'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'mov', 'type': '00', 'rd': 'r31', 'rh': 'r0', 'op2': 'r29'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'mov', 'type': '00', 'rd': 'r31', 'rh': 'r0', 'op2': 'r29'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000000100011111000001110100000

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'movi: r13 = 35' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'movi: r13 = 35'
[DISASSEMBLE] -> Parte do opcode: 'movi', Parte dos operandos: 'r13 = 35'
[DISASSEMBLE] -> Sufixo de suporte encontrado: 'i'. Opcode final é 'mov'
[DISASSEMBLE] -> Opcode final: 'mov', Tipo: 00
[DISASSEMBLE] -> Instrução 'mov' identificada. Destino: 'r13', Origem: '35'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'i', 'opcode': 'mov', 'type': '00', 'rd': 'r13', 'rh': 'r0', 'op2': '35'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'mov', 'type': '00', 'rd': 'r13', 'rh': 'r0', 'op2': '35'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'mov', 'type': '00', 'rd': 'r13', 'rh': 'r0', 'op2': '35'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000010100001101000000000100011

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'load: r12 = [r13]' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'load: r12 = [r13]'
[DISASSEMBLE] -> Parte do opcode: 'load', Parte dos operandos: 'r12 = [r13]'
[DISASSEMBLE] -> Opcode final: 'load', Tipo: 01
[DISASSEMBLE] -> Instrução Load/Store com endereçamento por registrador.
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'na', 'opcode': 'load', 'type': '01', 'rd': 'r12', 'rh': 'r0', 'op2': 'r13'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'load', 'type': '01', 'rd': 'r12', 'rh': 'r0', 'op2': 'r13'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'load', 'type': '01', 'rd': 'r12', 'rh': 'r0', 'op2': 'r13'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000100000101100000000110100000

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'movi: r14 = 38' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'movi: r14 = 38'
[DISASSEMBLE] -> Parte do opcode: 'movi', Parte dos operandos: 'r14 = 38'
[DISASSEMBLE] -> Sufixo de suporte encontrado: 'i'. Opcode final é 'mov'
[DISASSEMBLE] -> Opcode final: 'mov', Tipo: 00
[DISASSEMBLE] -> Instrução 'mov' identificada. Destino: 'r14', Origem: '38'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'i', 'opcode': 'mov', 'type': '00', 'rd': 'r14', 'rh': 'r0', 'op2': '38'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'mov', 'type': '00', 'rd': 'r14', 'rh': 'r0', 'op2': '38'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'mov', 'type': '00', 'rd': 'r14', 'rh': 'r0', 'op2': '38'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000010100001110000000000100110

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'store: [r14] = r12' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'store: [r14] = r12'
[DISASSEMBLE] -> Parte do opcode: 'store', Parte dos operandos: '[r14] = r12'
[DISASSEMBLE] -> Opcode final: 'store', Tipo: 01
[DISASSEMBLE] -> Instrução Store com endereçamento por registrador. Dest detectado: [r14]. Source detectado: 'r12'
[DISASSEMBLE] -> Instrução Load/Store com endereçamento por registrador.
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'na', 'opcode': 'store', 'type': '01', 'rd': 'r0', 'op2': 'r14', 'rh': 'r12'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'store', 'type': '01', 'rd': 'r0', 'op2': 'r14', 'rh': 'r12'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'store', 'type': '01', 'rd': 'r0', 'op2': 'r14', 'rh': 'r12'}
[ENCODE] -> Instrução Store detectada.
[ENCODE] -> rd_bin, rh_bin calculados: Rd(r0)=:00000 e Rh(r12)=:01100
[ENCODE] -> Op2 é um registrador: r14, convertido para binário: 0111000000
[INSTRUCTION] -> Codificação concluída. Binário: 00000100000000000011000111000000

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'movi: r16 = 35' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'movi: r16 = 35'
[DISASSEMBLE] -> Parte do opcode: 'movi', Parte dos operandos: 'r16 = 35'
[DISASSEMBLE] -> Sufixo de suporte encontrado: 'i'. Opcode final é 'mov'
[DISASSEMBLE] -> Opcode final: 'mov', Tipo: 00
[DISASSEMBLE] -> Instrução 'mov' identificada. Destino: 'r16', Origem: '35'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'i', 'opcode': 'mov', 'type': '00', 'rd': 'r16', 'rh': 'r0', 'op2': '35'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'mov', 'type': '00', 'rd': 'r16', 'rh': 'r0', 'op2': '35'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'mov', 'type': '00', 'rd': 'r16', 'rh': 'r0', 'op2': '35'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000010100010000000000000100011

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'load: r15 = [r16]' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'load: r15 = [r16]'
[DISASSEMBLE] -> Parte do opcode: 'load', Parte dos operandos: 'r15 = [r16]'
[DISASSEMBLE] -> Opcode final: 'load', Tipo: 01
[DISASSEMBLE] -> Instrução Load/Store com endereçamento por registrador.
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'na', 'opcode': 'load', 'type': '01', 'rd': 'r15', 'rh': 'r0', 'op2': 'r16'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'load', 'type': '01', 'rd': 'r15', 'rh': 'r0', 'op2': 'r16'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'load', 'type': '01', 'rd': 'r15', 'rh': 'r0', 'op2': 'r16'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000100000101111000001000000000

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'muli: r17 = r15, 4' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'muli: r17 = r15, 4'
[DISASSEMBLE] -> Parte do opcode: 'muli', Parte dos operandos: 'r17 = r15, 4'
[DISASSEMBLE] -> Sufixo de suporte encontrado: 'i'. Opcode final é 'mul'
[DISASSEMBLE] -> Opcode final: 'mul', Tipo: 00
[DISASSEMBLE] -> Instrução com atribuição. Destino: 'r17', Origem: 'r15, 4'
[DISASSEMBLE] -> Operandos finais: Rd='r17', Rh='r15', Op2='4'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'i', 'opcode': 'mul', 'type': '00', 'rd': 'r17', 'rh': 'r15', 'op2': '4'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'mul', 'type': '00', 'rd': 'r17', 'rh': 'r15', 'op2': '4'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'mul', 'type': '00', 'rd': 'r17', 'rh': 'r15', 'op2': '4'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000010001010001011110000000100

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'movi: r18 = 33' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'movi: r18 = 33'
[DISASSEMBLE] -> Parte do opcode: 'movi', Parte dos operandos: 'r18 = 33'
[DISASSEMBLE] -> Sufixo de suporte encontrado: 'i'. Opcode final é 'mov'
[DISASSEMBLE] -> Opcode final: 'mov', Tipo: 00
[DISASSEMBLE] -> Instrução 'mov' identificada. Destino: 'r18', Origem: '33'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'i', 'opcode': 'mov', 'type': '00', 'rd': 'r18', 'rh': 'r0', 'op2': '33'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'mov', 'type': '00', 'rd': 'r18', 'rh': 'r0', 'op2': '33'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'mov', 'type': '00', 'rd': 'r18', 'rh': 'r0', 'op2': '33'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000010100010010000000000100001

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'add: r19 = r18, r17' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'add: r19 = r18, r17'
[DISASSEMBLE] -> Parte do opcode: 'add', Parte dos operandos: 'r19 = r18, r17'
[DISASSEMBLE] -> Opcode final: 'add', Tipo: 00
[DISASSEMBLE] -> Instrução com atribuição. Destino: 'r19', Origem: 'r18, r17'
[DISASSEMBLE] -> Operandos finais: Rd='r19', Rh='r18', Op2='r17'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'na', 'opcode': 'add', 'type': '00', 'rd': 'r19', 'rh': 'r18', 'op2': 'r17'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'add', 'type': '00', 'rd': 'r19', 'rh': 'r18', 'op2': 'r17'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'add', 'type': '00', 'rd': 'r19', 'rh': 'r18', 'op2': 'r17'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000000000010011100101000100000

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'movi: r20 = 36' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'movi: r20 = 36'
[DISASSEMBLE] -> Parte do opcode: 'movi', Parte dos operandos: 'r20 = 36'
[DISASSEMBLE] -> Sufixo de suporte encontrado: 'i'. Opcode final é 'mov'
[DISASSEMBLE] -> Opcode final: 'mov', Tipo: 00
[DISASSEMBLE] -> Instrução 'mov' identificada. Destino: 'r20', Origem: '36'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'i', 'opcode': 'mov', 'type': '00', 'rd': 'r20', 'rh': 'r0', 'op2': '36'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'mov', 'type': '00', 'rd': 'r20', 'rh': 'r0', 'op2': '36'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'mov', 'type': '00', 'rd': 'r20', 'rh': 'r0', 'op2': '36'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000010100010100000000000100100

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'store: [r20] = r19' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'store: [r20] = r19'
[DISASSEMBLE] -> Parte do opcode: 'store', Parte dos operandos: '[r20] = r19'
[DISASSEMBLE] -> Opcode final: 'store', Tipo: 01
[DISASSEMBLE] -> Instrução Store com endereçamento por registrador. Dest detectado: [r20]. Source detectado: 'r19'
[DISASSEMBLE] -> Instrução Load/Store com endereçamento por registrador.
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'na', 'opcode': 'store', 'type': '01', 'rd': 'r0', 'op2': 'r20', 'rh': 'r19'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'store', 'type': '01', 'rd': 'r0', 'op2': 'r20', 'rh': 'r19'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'store', 'type': '01', 'rd': 'r0', 'op2': 'r20', 'rh': 'r19'}
[ENCODE] -> Instrução Store detectada.
[ENCODE] -> rd_bin, rh_bin calculados: Rd(r0)=:00000 e Rh(r19)=:10011
[ENCODE] -> Op2 é um registrador: r20, convertido para binário: 1010000000
[INSTRUCTION] -> Codificação concluída. Binário: 00000100000000000100111010000000

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'movi: r22 = 35' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'movi: r22 = 35'
[DISASSEMBLE] -> Parte do opcode: 'movi', Parte dos operandos: 'r22 = 35'
[DISASSEMBLE] -> Sufixo de suporte encontrado: 'i'. Opcode final é 'mov'
[DISASSEMBLE] -> Opcode final: 'mov', Tipo: 00
[DISASSEMBLE] -> Instrução 'mov' identificada. Destino: 'r22', Origem: '35'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'i', 'opcode': 'mov', 'type': '00', 'rd': 'r22', 'rh': 'r0', 'op2': '35'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'mov', 'type': '00', 'rd': 'r22', 'rh': 'r0', 'op2': '35'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'mov', 'type': '00', 'rd': 'r22', 'rh': 'r0', 'op2': '35'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000010100010110000000000100011

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'load: r21 = [r22]' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'load: r21 = [r22]'
[DISASSEMBLE] -> Parte do opcode: 'load', Parte dos operandos: 'r21 = [r22]'
[DISASSEMBLE] -> Opcode final: 'load', Tipo: 01
[DISASSEMBLE] -> Instrução Load/Store com endereçamento por registrador.
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'na', 'opcode': 'load', 'type': '01', 'rd': 'r21', 'rh': 'r0', 'op2': 'r22'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'load', 'type': '01', 'rd': 'r21', 'rh': 'r0', 'op2': 'r22'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'load', 'type': '01', 'rd': 'r21', 'rh': 'r0', 'op2': 'r22'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000100000110101000001011000000

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'addi: r23 = r21, 1' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'addi: r23 = r21, 1'
[DISASSEMBLE] -> Parte do opcode: 'addi', Parte dos operandos: 'r23 = r21, 1'
[DISASSEMBLE] -> Sufixo de suporte encontrado: 'i'. Opcode final é 'add'
[DISASSEMBLE] -> Opcode final: 'add', Tipo: 00
[DISASSEMBLE] -> Instrução com atribuição. Destino: 'r23', Origem: 'r21, 1'
[DISASSEMBLE] -> Operandos finais: Rd='r23', Rh='r21', Op2='1'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'i', 'opcode': 'add', 'type': '00', 'rd': 'r23', 'rh': 'r21', 'op2': '1'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'add', 'type': '00', 'rd': 'r23', 'rh': 'r21', 'op2': '1'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'add', 'type': '00', 'rd': 'r23', 'rh': 'r21', 'op2': '1'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000010000010111101010000000001

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'movi: r24 = 39' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'movi: r24 = 39'
[DISASSEMBLE] -> Parte do opcode: 'movi', Parte dos operandos: 'r24 = 39'
[DISASSEMBLE] -> Sufixo de suporte encontrado: 'i'. Opcode final é 'mov'
[DISASSEMBLE] -> Opcode final: 'mov', Tipo: 00
[DISASSEMBLE] -> Instrução 'mov' identificada. Destino: 'r24', Origem: '39'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'i', 'opcode': 'mov', 'type': '00', 'rd': 'r24', 'rh': 'r0', 'op2': '39'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'mov', 'type': '00', 'rd': 'r24', 'rh': 'r0', 'op2': '39'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'mov', 'type': '00', 'rd': 'r24', 'rh': 'r0', 'op2': '39'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000010100011000000000000100111

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'store: [r24] = r23' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'store: [r24] = r23'
[DISASSEMBLE] -> Parte do opcode: 'store', Parte dos operandos: '[r24] = r23'
[DISASSEMBLE] -> Opcode final: 'store', Tipo: 01
[DISASSEMBLE] -> Instrução Store com endereçamento por registrador. Dest detectado: [r24]. Source detectado: 'r23'
[DISASSEMBLE] -> Instrução Load/Store com endereçamento por registrador.
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'na', 'opcode': 'store', 'type': '01', 'rd': 'r0', 'op2': 'r24', 'rh': 'r23'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'store', 'type': '01', 'rd': 'r0', 'op2': 'r24', 'rh': 'r23'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'store', 'type': '01', 'rd': 'r0', 'op2': 'r24', 'rh': 'r23'}
[ENCODE] -> Instrução Store detectada.
[ENCODE] -> rd_bin, rh_bin calculados: Rd(r0)=:00000 e Rh(r23)=:10111
[ENCODE] -> Op2 é um registrador: r24, convertido para binário: 1100000000
[INSTRUCTION] -> Codificação concluída. Binário: 00000100000000000101111100000000

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'movi: r26 = 39' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'movi: r26 = 39'
[DISASSEMBLE] -> Parte do opcode: 'movi', Parte dos operandos: 'r26 = 39'
[DISASSEMBLE] -> Sufixo de suporte encontrado: 'i'. Opcode final é 'mov'
[DISASSEMBLE] -> Opcode final: 'mov', Tipo: 00
[DISASSEMBLE] -> Instrução 'mov' identificada. Destino: 'r26', Origem: '39'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'i', 'opcode': 'mov', 'type': '00', 'rd': 'r26', 'rh': 'r0', 'op2': '39'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'mov', 'type': '00', 'rd': 'r26', 'rh': 'r0', 'op2': '39'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'mov', 'type': '00', 'rd': 'r26', 'rh': 'r0', 'op2': '39'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000010100011010000000000100111

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'load: r25 = [r26]' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'load: r25 = [r26]'
[DISASSEMBLE] -> Parte do opcode: 'load', Parte dos operandos: 'r25 = [r26]'
[DISASSEMBLE] -> Opcode final: 'load', Tipo: 01
[DISASSEMBLE] -> Instrução Load/Store com endereçamento por registrador.
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'na', 'opcode': 'load', 'type': '01', 'rd': 'r25', 'rh': 'r0', 'op2': 'r26'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'load', 'type': '01', 'rd': 'r25', 'rh': 'r0', 'op2': 'r26'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'load', 'type': '01', 'rd': 'r25', 'rh': 'r0', 'op2': 'r26'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000100000111001000001101000000

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'movi: r5 = 40' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'movi: r5 = 40'
[DISASSEMBLE] -> Parte do opcode: 'movi', Parte dos operandos: 'r5 = 40'
[DISASSEMBLE] -> Sufixo de suporte encontrado: 'i'. Opcode final é 'mov'
[DISASSEMBLE] -> Opcode final: 'mov', Tipo: 00
[DISASSEMBLE] -> Instrução 'mov' identificada. Destino: 'r5', Origem: '40'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'i', 'opcode': 'mov', 'type': '00', 'rd': 'r5', 'rh': 'r0', 'op2': '40'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'mov', 'type': '00', 'rd': 'r5', 'rh': 'r0', 'op2': '40'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'mov', 'type': '00', 'rd': 'r5', 'rh': 'r0', 'op2': '40'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000010100000101000000000101000

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'load: r4 = [r5]' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'load: r4 = [r5]'
[DISASSEMBLE] -> Parte do opcode: 'load', Parte dos operandos: 'r4 = [r5]'
[DISASSEMBLE] -> Opcode final: 'load', Tipo: 01
[DISASSEMBLE] -> Instrução Load/Store com endereçamento por registrador.
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'na', 'opcode': 'load', 'type': '01', 'rd': 'r4', 'rh': 'r0', 'op2': 'r5'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'load', 'type': '01', 'rd': 'r4', 'rh': 'r0', 'op2': 'r5'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'load', 'type': '01', 'rd': 'r4', 'rh': 'r0', 'op2': 'r5'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000100000100100000000010100000

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'subs: r0 = r25, r4' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'subs: r0 = r25, r4'
[DISASSEMBLE] -> Parte do opcode: 'subs', Parte dos operandos: 'r0 = r25, r4'
[DISASSEMBLE] -> Sufixo de suporte encontrado: 's'. Opcode final é 'sub'
[DISASSEMBLE] -> Opcode final: 'sub', Tipo: 00
[DISASSEMBLE] -> Instrução com atribuição. Destino: 'r0', Origem: 'r25, r4'
[DISASSEMBLE] -> Operandos finais: Rd='r0', Rh='r25', Op2='r4'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 's', 'opcode': 'sub', 'type': '00', 'rd': 'r0', 'rh': 'r25', 'op2': 'r4'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 's', 'opcode': 'sub', 'type': '00', 'rd': 'r0', 'rh': 'r25', 'op2': 'r4'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 's', 'opcode': 'sub', 'type': '00', 'rd': 'r0', 'rh': 'r25', 'op2': 'r4'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000001000100000110010010000000

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'bigteq: L1' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'bigteq: L1'
[DISASSEMBLE] -> Parte do opcode: 'bigteq', Parte dos operandos: 'L1'
[DISASSEMBLE] -> Instrução de branch identificada: 'bigteq'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'gteq', 'supp': 'i', 'opcode': 'b', 'type': '11', 'op2': 'L1'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'gteq', 'supp': 'i', 'opcode': 'b', 'type': '11', 'op2': 'L1'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'gteq', 'supp': 'i', 'opcode': 'b', 'type': '11', 'op2': 'L1'}
[ENCODE] -> Instrução de branch detectada: b com condição gteq
[ENCODE] -> Próximo endereço de instrução: 28
[INSTRUCTION] -> Codificação concluída. Binário: 01001110000000000000000000011011

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'movi: r7 = 39' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'movi: r7 = 39'
[DISASSEMBLE] -> Parte do opcode: 'movi', Parte dos operandos: 'r7 = 39'
[DISASSEMBLE] -> Sufixo de suporte encontrado: 'i'. Opcode final é 'mov'
[DISASSEMBLE] -> Opcode final: 'mov', Tipo: 00
[DISASSEMBLE] -> Instrução 'mov' identificada. Destino: 'r7', Origem: '39'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'i', 'opcode': 'mov', 'type': '00', 'rd': 'r7', 'rh': 'r0', 'op2': '39'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'mov', 'type': '00', 'rd': 'r7', 'rh': 'r0', 'op2': '39'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'mov', 'type': '00', 'rd': 'r7', 'rh': 'r0', 'op2': '39'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000010100000111000000000100111

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'load: r6 = [r7]' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'load: r6 = [r7]'
[DISASSEMBLE] -> Parte do opcode: 'load', Parte dos operandos: 'r6 = [r7]'
[DISASSEMBLE] -> Opcode final: 'load', Tipo: 01
[DISASSEMBLE] -> Instrução Load/Store com endereçamento por registrador.
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'na', 'opcode': 'load', 'type': '01', 'rd': 'r6', 'rh': 'r0', 'op2': 'r7'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'load', 'type': '01', 'rd': 'r6', 'rh': 'r0', 'op2': 'r7'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'load', 'type': '01', 'rd': 'r6', 'rh': 'r0', 'op2': 'r7'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000100000100110000000011100000

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'muli: r8 = r6, 4' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'muli: r8 = r6, 4'
[DISASSEMBLE] -> Parte do opcode: 'muli', Parte dos operandos: 'r8 = r6, 4'
[DISASSEMBLE] -> Sufixo de suporte encontrado: 'i'. Opcode final é 'mul'
[DISASSEMBLE] -> Opcode final: 'mul', Tipo: 00
[DISASSEMBLE] -> Instrução com atribuição. Destino: 'r8', Origem: 'r6, 4'
[DISASSEMBLE] -> Operandos finais: Rd='r8', Rh='r6', Op2='4'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'i', 'opcode': 'mul', 'type': '00', 'rd': 'r8', 'rh': 'r6', 'op2': '4'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'mul', 'type': '00', 'rd': 'r8', 'rh': 'r6', 'op2': '4'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'mul', 'type': '00', 'rd': 'r8', 'rh': 'r6', 'op2': '4'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000010001001000001100000000100

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'movi: r9 = 33' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'movi: r9 = 33'
[DISASSEMBLE] -> Parte do opcode: 'movi', Parte dos operandos: 'r9 = 33'
[DISASSEMBLE] -> Sufixo de suporte encontrado: 'i'. Opcode final é 'mov'
[DISASSEMBLE] -> Opcode final: 'mov', Tipo: 00
[DISASSEMBLE] -> Instrução 'mov' identificada. Destino: 'r9', Origem: '33'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'i', 'opcode': 'mov', 'type': '00', 'rd': 'r9', 'rh': 'r0', 'op2': '33'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'mov', 'type': '00', 'rd': 'r9', 'rh': 'r0', 'op2': '33'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'mov', 'type': '00', 'rd': 'r9', 'rh': 'r0', 'op2': '33'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000010100001001000000000100001

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'add: r10 = r9, r8' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'add: r10 = r9, r8'
[DISASSEMBLE] -> Parte do opcode: 'add', Parte dos operandos: 'r10 = r9, r8'
[DISASSEMBLE] -> Opcode final: 'add', Tipo: 00
[DISASSEMBLE] -> Instrução com atribuição. Destino: 'r10', Origem: 'r9, r8'
[DISASSEMBLE] -> Operandos finais: Rd='r10', Rh='r9', Op2='r8'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'na', 'opcode': 'add', 'type': '00', 'rd': 'r10', 'rh': 'r9', 'op2': 'r8'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'add', 'type': '00', 'rd': 'r10', 'rh': 'r9', 'op2': 'r8'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'add', 'type': '00', 'rd': 'r10', 'rh': 'r9', 'op2': 'r8'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000000000001010010010100000000

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'movi: r13 = 36' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'movi: r13 = 36'
[DISASSEMBLE] -> Parte do opcode: 'movi', Parte dos operandos: 'r13 = 36'
[DISASSEMBLE] -> Sufixo de suporte encontrado: 'i'. Opcode final é 'mov'
[DISASSEMBLE] -> Opcode final: 'mov', Tipo: 00
[DISASSEMBLE] -> Instrução 'mov' identificada. Destino: 'r13', Origem: '36'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'i', 'opcode': 'mov', 'type': '00', 'rd': 'r13', 'rh': 'r0', 'op2': '36'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'mov', 'type': '00', 'rd': 'r13', 'rh': 'r0', 'op2': '36'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'mov', 'type': '00', 'rd': 'r13', 'rh': 'r0', 'op2': '36'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000010100001101000000000100100

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'load: r11 = [r13]' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'load: r11 = [r13]'
[DISASSEMBLE] -> Parte do opcode: 'load', Parte dos operandos: 'r11 = [r13]'
[DISASSEMBLE] -> Opcode final: 'load', Tipo: 01
[DISASSEMBLE] -> Instrução Load/Store com endereçamento por registrador.
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'na', 'opcode': 'load', 'type': '01', 'rd': 'r11', 'rh': 'r0', 'op2': 'r13'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'load', 'type': '01', 'rd': 'r11', 'rh': 'r0', 'op2': 'r13'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'load', 'type': '01', 'rd': 'r11', 'rh': 'r0', 'op2': 'r13'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000100000101011000000110100000

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'subs: r0 = r10, r11' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'subs: r0 = r10, r11'
[DISASSEMBLE] -> Parte do opcode: 'subs', Parte dos operandos: 'r0 = r10, r11'
[DISASSEMBLE] -> Sufixo de suporte encontrado: 's'. Opcode final é 'sub'
[DISASSEMBLE] -> Opcode final: 'sub', Tipo: 00
[DISASSEMBLE] -> Instrução com atribuição. Destino: 'r0', Origem: 'r10, r11'
[DISASSEMBLE] -> Operandos finais: Rd='r0', Rh='r10', Op2='r11'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 's', 'opcode': 'sub', 'type': '00', 'rd': 'r0', 'rh': 'r10', 'op2': 'r11'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 's', 'opcode': 'sub', 'type': '00', 'rd': 'r0', 'rh': 'r10', 'op2': 'r11'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 's', 'opcode': 'sub', 'type': '00', 'rd': 'r0', 'rh': 'r10', 'op2': 'r11'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000001000100000010100101100000

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'bigteq: L2' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'bigteq: L2'
[DISASSEMBLE] -> Parte do opcode: 'bigteq', Parte dos operandos: 'L2'
[DISASSEMBLE] -> Instrução de branch identificada: 'bigteq'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'gteq', 'supp': 'i', 'opcode': 'b', 'type': '11', 'op2': 'L2'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'gteq', 'supp': 'i', 'opcode': 'b', 'type': '11', 'op2': 'L2'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'gteq', 'supp': 'i', 'opcode': 'b', 'type': '11', 'op2': 'L2'}
[ENCODE] -> Instrução de branch detectada: b com condição gteq
[ENCODE] -> Próximo endereço de instrução: 37
[INSTRUCTION] -> Codificação concluída. Binário: 01001110000000000000000000001100

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'movi: r14 = 39' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'movi: r14 = 39'
[DISASSEMBLE] -> Parte do opcode: 'movi', Parte dos operandos: 'r14 = 39'
[DISASSEMBLE] -> Sufixo de suporte encontrado: 'i'. Opcode final é 'mov'
[DISASSEMBLE] -> Opcode final: 'mov', Tipo: 00
[DISASSEMBLE] -> Instrução 'mov' identificada. Destino: 'r14', Origem: '39'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'i', 'opcode': 'mov', 'type': '00', 'rd': 'r14', 'rh': 'r0', 'op2': '39'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'mov', 'type': '00', 'rd': 'r14', 'rh': 'r0', 'op2': '39'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'mov', 'type': '00', 'rd': 'r14', 'rh': 'r0', 'op2': '39'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000010100001110000000000100111

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'load: r12 = [r14]' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'load: r12 = [r14]'
[DISASSEMBLE] -> Parte do opcode: 'load', Parte dos operandos: 'r12 = [r14]'
[DISASSEMBLE] -> Opcode final: 'load', Tipo: 01
[DISASSEMBLE] -> Instrução Load/Store com endereçamento por registrador.
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'na', 'opcode': 'load', 'type': '01', 'rd': 'r12', 'rh': 'r0', 'op2': 'r14'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'load', 'type': '01', 'rd': 'r12', 'rh': 'r0', 'op2': 'r14'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'load', 'type': '01', 'rd': 'r12', 'rh': 'r0', 'op2': 'r14'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000100000101100000000111000000

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'muli: r16 = r12, 4' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'muli: r16 = r12, 4'
[DISASSEMBLE] -> Parte do opcode: 'muli', Parte dos operandos: 'r16 = r12, 4'
[DISASSEMBLE] -> Sufixo de suporte encontrado: 'i'. Opcode final é 'mul'
[DISASSEMBLE] -> Opcode final: 'mul', Tipo: 00
[DISASSEMBLE] -> Instrução com atribuição. Destino: 'r16', Origem: 'r12, 4'
[DISASSEMBLE] -> Operandos finais: Rd='r16', Rh='r12', Op2='4'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'i', 'opcode': 'mul', 'type': '00', 'rd': 'r16', 'rh': 'r12', 'op2': '4'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'mul', 'type': '00', 'rd': 'r16', 'rh': 'r12', 'op2': '4'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'mul', 'type': '00', 'rd': 'r16', 'rh': 'r12', 'op2': '4'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000010001010000011000000000100

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'movi: r15 = 33' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'movi: r15 = 33'
[DISASSEMBLE] -> Parte do opcode: 'movi', Parte dos operandos: 'r15 = 33'
[DISASSEMBLE] -> Sufixo de suporte encontrado: 'i'. Opcode final é 'mov'
[DISASSEMBLE] -> Opcode final: 'mov', Tipo: 00
[DISASSEMBLE] -> Instrução 'mov' identificada. Destino: 'r15', Origem: '33'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'i', 'opcode': 'mov', 'type': '00', 'rd': 'r15', 'rh': 'r0', 'op2': '33'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'mov', 'type': '00', 'rd': 'r15', 'rh': 'r0', 'op2': '33'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'mov', 'type': '00', 'rd': 'r15', 'rh': 'r0', 'op2': '33'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000010100001111000000000100001

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'add: r19 = r15, r16' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'add: r19 = r15, r16'
[DISASSEMBLE] -> Parte do opcode: 'add', Parte dos operandos: 'r19 = r15, r16'
[DISASSEMBLE] -> Opcode final: 'add', Tipo: 00
[DISASSEMBLE] -> Instrução com atribuição. Destino: 'r19', Origem: 'r15, r16'
[DISASSEMBLE] -> Operandos finais: Rd='r19', Rh='r15', Op2='r16'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'na', 'opcode': 'add', 'type': '00', 'rd': 'r19', 'rh': 'r15', 'op2': 'r16'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'add', 'type': '00', 'rd': 'r19', 'rh': 'r15', 'op2': 'r16'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'add', 'type': '00', 'rd': 'r19', 'rh': 'r15', 'op2': 'r16'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000000000010011011111000000000

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'movi: r20 = 36' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'movi: r20 = 36'
[DISASSEMBLE] -> Parte do opcode: 'movi', Parte dos operandos: 'r20 = 36'
[DISASSEMBLE] -> Sufixo de suporte encontrado: 'i'. Opcode final é 'mov'
[DISASSEMBLE] -> Opcode final: 'mov', Tipo: 00
[DISASSEMBLE] -> Instrução 'mov' identificada. Destino: 'r20', Origem: '36'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'i', 'opcode': 'mov', 'type': '00', 'rd': 'r20', 'rh': 'r0', 'op2': '36'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'mov', 'type': '00', 'rd': 'r20', 'rh': 'r0', 'op2': '36'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'mov', 'type': '00', 'rd': 'r20', 'rh': 'r0', 'op2': '36'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000010100010100000000000100100

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'store: [r20] = r19' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'store: [r20] = r19'
[DISASSEMBLE] -> Parte do opcode: 'store', Parte dos operandos: '[r20] = r19'
[DISASSEMBLE] -> Opcode final: 'store', Tipo: 01
[DISASSEMBLE] -> Instrução Store com endereçamento por registrador. Dest detectado: [r20]. Source detectado: 'r19'
[DISASSEMBLE] -> Instrução Load/Store com endereçamento por registrador.
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'na', 'opcode': 'store', 'type': '01', 'rd': 'r0', 'op2': 'r20', 'rh': 'r19'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'store', 'type': '01', 'rd': 'r0', 'op2': 'r20', 'rh': 'r19'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'store', 'type': '01', 'rd': 'r0', 'op2': 'r20', 'rh': 'r19'}
[ENCODE] -> Instrução Store detectada.
[ENCODE] -> rd_bin, rh_bin calculados: Rd(r0)=:00000 e Rh(r19)=:10011
[ENCODE] -> Op2 é um registrador: r20, convertido para binário: 1010000000
[INSTRUCTION] -> Codificação concluída. Binário: 00000100000000000100111010000000

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'movi: r21 = 39' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'movi: r21 = 39'
[DISASSEMBLE] -> Parte do opcode: 'movi', Parte dos operandos: 'r21 = 39'
[DISASSEMBLE] -> Sufixo de suporte encontrado: 'i'. Opcode final é 'mov'
[DISASSEMBLE] -> Opcode final: 'mov', Tipo: 00
[DISASSEMBLE] -> Instrução 'mov' identificada. Destino: 'r21', Origem: '39'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'i', 'opcode': 'mov', 'type': '00', 'rd': 'r21', 'rh': 'r0', 'op2': '39'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'mov', 'type': '00', 'rd': 'r21', 'rh': 'r0', 'op2': '39'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'mov', 'type': '00', 'rd': 'r21', 'rh': 'r0', 'op2': '39'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000010100010101000000000100111

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'load: r22 = [r21]' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'load: r22 = [r21]'
[DISASSEMBLE] -> Parte do opcode: 'load', Parte dos operandos: 'r22 = [r21]'
[DISASSEMBLE] -> Opcode final: 'load', Tipo: 01
[DISASSEMBLE] -> Instrução Load/Store com endereçamento por registrador.
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'na', 'opcode': 'load', 'type': '01', 'rd': 'r22', 'rh': 'r0', 'op2': 'r21'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'load', 'type': '01', 'rd': 'r22', 'rh': 'r0', 'op2': 'r21'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'load', 'type': '01', 'rd': 'r22', 'rh': 'r0', 'op2': 'r21'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000100000110110000001010100000

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'movi: r23 = 38' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'movi: r23 = 38'
[DISASSEMBLE] -> Parte do opcode: 'movi', Parte dos operandos: 'r23 = 38'
[DISASSEMBLE] -> Sufixo de suporte encontrado: 'i'. Opcode final é 'mov'
[DISASSEMBLE] -> Opcode final: 'mov', Tipo: 00
[DISASSEMBLE] -> Instrução 'mov' identificada. Destino: 'r23', Origem: '38'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'i', 'opcode': 'mov', 'type': '00', 'rd': 'r23', 'rh': 'r0', 'op2': '38'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'mov', 'type': '00', 'rd': 'r23', 'rh': 'r0', 'op2': '38'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'mov', 'type': '00', 'rd': 'r23', 'rh': 'r0', 'op2': '38'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000010100010111000000000100110

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'store: [r23] = r22' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'store: [r23] = r22'
[DISASSEMBLE] -> Parte do opcode: 'store', Parte dos operandos: '[r23] = r22'
[DISASSEMBLE] -> Opcode final: 'store', Tipo: 01
[DISASSEMBLE] -> Instrução Store com endereçamento por registrador. Dest detectado: [r23]. Source detectado: 'r22'
[DISASSEMBLE] -> Instrução Load/Store com endereçamento por registrador.
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'na', 'opcode': 'store', 'type': '01', 'rd': 'r0', 'op2': 'r23', 'rh': 'r22'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'store', 'type': '01', 'rd': 'r0', 'op2': 'r23', 'rh': 'r22'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'store', 'type': '01', 'rd': 'r0', 'op2': 'r23', 'rh': 'r22'}
[ENCODE] -> Instrução Store detectada.
[ENCODE] -> rd_bin, rh_bin calculados: Rd(r0)=:00000 e Rh(r22)=:10110
[ENCODE] -> Op2 é um registrador: r23, convertido para binário: 1011100000
[INSTRUCTION] -> Codificação concluída. Binário: 00000100000000000101101011100000

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'bi: L3' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'bi: L3'
[DISASSEMBLE] -> Parte do opcode: 'bi', Parte dos operandos: 'L3'
[DISASSEMBLE] -> Instrução de branch identificada: 'bi'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'i', 'opcode': 'b', 'type': '11', 'op2': 'L3'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'b', 'type': '11', 'op2': 'L3'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'b', 'type': '11', 'op2': 'L3'}
[ENCODE] -> Instrução de branch detectada: b com condição do
[ENCODE] -> Próximo endereço de instrução: 49
[INSTRUCTION] -> Codificação concluída. Binário: 00001110000000000000000000000000

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'movi: r26 = 39' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'movi: r26 = 39'
[DISASSEMBLE] -> Parte do opcode: 'movi', Parte dos operandos: 'r26 = 39'
[DISASSEMBLE] -> Sufixo de suporte encontrado: 'i'. Opcode final é 'mov'
[DISASSEMBLE] -> Opcode final: 'mov', Tipo: 00
[DISASSEMBLE] -> Instrução 'mov' identificada. Destino: 'r26', Origem: '39'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'i', 'opcode': 'mov', 'type': '00', 'rd': 'r26', 'rh': 'r0', 'op2': '39'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'mov', 'type': '00', 'rd': 'r26', 'rh': 'r0', 'op2': '39'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'mov', 'type': '00', 'rd': 'r26', 'rh': 'r0', 'op2': '39'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000010100011010000000000100111

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'load: r24 = [r26]' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'load: r24 = [r26]'
[DISASSEMBLE] -> Parte do opcode: 'load', Parte dos operandos: 'r24 = [r26]'
[DISASSEMBLE] -> Opcode final: 'load', Tipo: 01
[DISASSEMBLE] -> Instrução Load/Store com endereçamento por registrador.
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'na', 'opcode': 'load', 'type': '01', 'rd': 'r24', 'rh': 'r0', 'op2': 'r26'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'load', 'type': '01', 'rd': 'r24', 'rh': 'r0', 'op2': 'r26'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'load', 'type': '01', 'rd': 'r24', 'rh': 'r0', 'op2': 'r26'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000100000111000000001101000000

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'addi: r25 = r24, 1' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'addi: r25 = r24, 1'
[DISASSEMBLE] -> Parte do opcode: 'addi', Parte dos operandos: 'r25 = r24, 1'
[DISASSEMBLE] -> Sufixo de suporte encontrado: 'i'. Opcode final é 'add'
[DISASSEMBLE] -> Opcode final: 'add', Tipo: 00
[DISASSEMBLE] -> Instrução com atribuição. Destino: 'r25', Origem: 'r24, 1'
[DISASSEMBLE] -> Operandos finais: Rd='r25', Rh='r24', Op2='1'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'i', 'opcode': 'add', 'type': '00', 'rd': 'r25', 'rh': 'r24', 'op2': '1'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'add', 'type': '00', 'rd': 'r25', 'rh': 'r24', 'op2': '1'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'add', 'type': '00', 'rd': 'r25', 'rh': 'r24', 'op2': '1'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000010000011001110000000000001

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'movi: r5 = 39' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'movi: r5 = 39'
[DISASSEMBLE] -> Parte do opcode: 'movi', Parte dos operandos: 'r5 = 39'
[DISASSEMBLE] -> Sufixo de suporte encontrado: 'i'. Opcode final é 'mov'
[DISASSEMBLE] -> Opcode final: 'mov', Tipo: 00
[DISASSEMBLE] -> Instrução 'mov' identificada. Destino: 'r5', Origem: '39'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'i', 'opcode': 'mov', 'type': '00', 'rd': 'r5', 'rh': 'r0', 'op2': '39'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'mov', 'type': '00', 'rd': 'r5', 'rh': 'r0', 'op2': '39'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'mov', 'type': '00', 'rd': 'r5', 'rh': 'r0', 'op2': '39'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000010100000101000000000100111

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'store: [r5] = r25' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'store: [r5] = r25'
[DISASSEMBLE] -> Parte do opcode: 'store', Parte dos operandos: '[r5] = r25'
[DISASSEMBLE] -> Opcode final: 'store', Tipo: 01
[DISASSEMBLE] -> Instrução Store com endereçamento por registrador. Dest detectado: [r5]. Source detectado: 'r25'
[DISASSEMBLE] -> Instrução Load/Store com endereçamento por registrador.
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'na', 'opcode': 'store', 'type': '01', 'rd': 'r0', 'op2': 'r5', 'rh': 'r25'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'store', 'type': '01', 'rd': 'r0', 'op2': 'r5', 'rh': 'r25'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'store', 'type': '01', 'rd': 'r0', 'op2': 'r5', 'rh': 'r25'}
[ENCODE] -> Instrução Store detectada.
[ENCODE] -> rd_bin, rh_bin calculados: Rd(r0)=:00000 e Rh(r25)=:11001
[ENCODE] -> Op2 é um registrador: r5, convertido para binário: 0010100000
[INSTRUCTION] -> Codificação concluída. Binário: 00000100000000000110010010100000

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'bi: L0' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'bi: L0'
[DISASSEMBLE] -> Parte do opcode: 'bi', Parte dos operandos: 'L0'
[DISASSEMBLE] -> Instrução de branch identificada: 'bi'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'i', 'opcode': 'b', 'type': '11', 'op2': 'L0'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'b', 'type': '11', 'op2': 'L0'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'b', 'type': '11', 'op2': 'L0'}
[ENCODE] -> Instrução de branch detectada: b com condição do
[ENCODE] -> Próximo endereço de instrução: 55
[INSTRUCTION] -> Codificação concluída. Binário: 00001110000011111111111111011111

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'movi: r7 = 38' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'movi: r7 = 38'
[DISASSEMBLE] -> Parte do opcode: 'movi', Parte dos operandos: 'r7 = 38'
[DISASSEMBLE] -> Sufixo de suporte encontrado: 'i'. Opcode final é 'mov'
[DISASSEMBLE] -> Opcode final: 'mov', Tipo: 00
[DISASSEMBLE] -> Instrução 'mov' identificada. Destino: 'r7', Origem: '38'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'i', 'opcode': 'mov', 'type': '00', 'rd': 'r7', 'rh': 'r0', 'op2': '38'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'mov', 'type': '00', 'rd': 'r7', 'rh': 'r0', 'op2': '38'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'mov', 'type': '00', 'rd': 'r7', 'rh': 'r0', 'op2': '38'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000010100000111000000000100110

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'load: r4 = [r7]' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'load: r4 = [r7]'
[DISASSEMBLE] -> Parte do opcode: 'load', Parte dos operandos: 'r4 = [r7]'
[DISASSEMBLE] -> Opcode final: 'load', Tipo: 01
[DISASSEMBLE] -> Instrução Load/Store com endereçamento por registrador.
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'na', 'opcode': 'load', 'type': '01', 'rd': 'r4', 'rh': 'r0', 'op2': 'r7'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'load', 'type': '01', 'rd': 'r4', 'rh': 'r0', 'op2': 'r7'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'load', 'type': '01', 'rd': 'r4', 'rh': 'r0', 'op2': 'r7'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000100000100100000000011100000

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'mov: r0 = r4' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'mov: r0 = r4'
[DISASSEMBLE] -> Parte do opcode: 'mov', Parte dos operandos: 'r0 = r4'
[DISASSEMBLE] -> Opcode final: 'mov', Tipo: 00
[DISASSEMBLE] -> Instrução 'mov' identificada. Destino: 'r0', Origem: 'r4'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'na', 'opcode': 'mov', 'type': '00', 'rd': 'r0', 'rh': 'r0', 'op2': 'r4'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'mov', 'type': '00', 'rd': 'r0', 'rh': 'r0', 'op2': 'r4'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'mov', 'type': '00', 'rd': 'r0', 'rh': 'r0', 'op2': 'r4'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000000100000000000000010000000

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'bi: minloc_epilogue' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'bi: minloc_epilogue'
[DISASSEMBLE] -> Parte do opcode: 'bi', Parte dos operandos: 'minloc_epilogue'
[DISASSEMBLE] -> Instrução de branch identificada: 'bi'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'i', 'opcode': 'b', 'type': '11', 'op2': 'minloc_epilogue'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'b', 'type': '11', 'op2': 'minloc_epilogue'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'b', 'type': '11', 'op2': 'minloc_epilogue'}
[ENCODE] -> Instrução de branch detectada: b com condição do
[ENCODE] -> Próximo endereço de instrução: 59
[INSTRUCTION] -> Codificação concluída. Binário: 00001110000000000000000000000001

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'bi: minloc_epilogue' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'bi: minloc_epilogue'
[DISASSEMBLE] -> Parte do opcode: 'bi', Parte dos operandos: 'minloc_epilogue'
[DISASSEMBLE] -> Instrução de branch identificada: 'bi'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'i', 'opcode': 'b', 'type': '11', 'op2': 'minloc_epilogue'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'b', 'type': '11', 'op2': 'minloc_epilogue'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'b', 'type': '11', 'op2': 'minloc_epilogue'}
[ENCODE] -> Instrução de branch detectada: b com condição do
[ENCODE] -> Próximo endereço de instrução: 60
[INSTRUCTION] -> Codificação concluída. Binário: 00001110000000000000000000000000

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'mov: r29 = r31' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'mov: r29 = r31'
[DISASSEMBLE] -> Parte do opcode: 'mov', Parte dos operandos: 'r29 = r31'
[DISASSEMBLE] -> Opcode final: 'mov', Tipo: 00
[DISASSEMBLE] -> Instrução 'mov' identificada. Destino: 'r29', Origem: 'r31'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'na', 'opcode': 'mov', 'type': '00', 'rd': 'r29', 'rh': 'r0', 'op2': 'r31'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'mov', 'type': '00', 'rd': 'r29', 'rh': 'r0', 'op2': 'r31'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'mov', 'type': '00', 'rd': 'r29', 'rh': 'r0', 'op2': 'r31'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000000100011101000001111100000

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'load: r31 = [r29]' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'load: r31 = [r29]'
[DISASSEMBLE] -> Parte do opcode: 'load', Parte dos operandos: 'r31 = [r29]'
[DISASSEMBLE] -> Opcode final: 'load', Tipo: 01
[DISASSEMBLE] -> Instrução Load/Store com endereçamento por registrador.
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'na', 'opcode': 'load', 'type': '01', 'rd': 'r31', 'rh': 'r0', 'op2': 'r29'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'load', 'type': '01', 'rd': 'r31', 'rh': 'r0', 'op2': 'r29'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'load', 'type': '01', 'rd': 'r31', 'rh': 'r0', 'op2': 'r29'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000100000111111000001110100000

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'addi: r29 = r29, 1' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'addi: r29 = r29, 1'
[DISASSEMBLE] -> Parte do opcode: 'addi', Parte dos operandos: 'r29 = r29, 1'
[DISASSEMBLE] -> Sufixo de suporte encontrado: 'i'. Opcode final é 'add'
[DISASSEMBLE] -> Opcode final: 'add', Tipo: 00
[DISASSEMBLE] -> Instrução com atribuição. Destino: 'r29', Origem: 'r29, 1'
[DISASSEMBLE] -> Operandos finais: Rd='r29', Rh='r29', Op2='1'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'i', 'opcode': 'add', 'type': '00', 'rd': 'r29', 'rh': 'r29', 'op2': '1'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'add', 'type': '00', 'rd': 'r29', 'rh': 'r29', 'op2': '1'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'add', 'type': '00', 'rd': 'r29', 'rh': 'r29', 'op2': '1'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000010000011101111010000000001

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'load: r28 = [r29]' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'load: r28 = [r29]'
[DISASSEMBLE] -> Parte do opcode: 'load', Parte dos operandos: 'r28 = [r29]'
[DISASSEMBLE] -> Opcode final: 'load', Tipo: 01
[DISASSEMBLE] -> Instrução Load/Store com endereçamento por registrador.
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'na', 'opcode': 'load', 'type': '01', 'rd': 'r28', 'rh': 'r0', 'op2': 'r29'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'load', 'type': '01', 'rd': 'r28', 'rh': 'r0', 'op2': 'r29'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'load', 'type': '01', 'rd': 'r28', 'rh': 'r0', 'op2': 'r29'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000100000111100000001110100000

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'addi: r29 = r29, 1' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'addi: r29 = r29, 1'
[DISASSEMBLE] -> Parte do opcode: 'addi', Parte dos operandos: 'r29 = r29, 1'
[DISASSEMBLE] -> Sufixo de suporte encontrado: 'i'. Opcode final é 'add'
[DISASSEMBLE] -> Opcode final: 'add', Tipo: 00
[DISASSEMBLE] -> Instrução com atribuição. Destino: 'r29', Origem: 'r29, 1'
[DISASSEMBLE] -> Operandos finais: Rd='r29', Rh='r29', Op2='1'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'i', 'opcode': 'add', 'type': '00', 'rd': 'r29', 'rh': 'r29', 'op2': '1'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'add', 'type': '00', 'rd': 'r29', 'rh': 'r29', 'op2': '1'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'add', 'type': '00', 'rd': 'r29', 'rh': 'r29', 'op2': '1'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000010000011101111010000000001

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'b: r28' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'b: r28'
[DISASSEMBLE] -> Parte do opcode: 'b', Parte dos operandos: 'r28'
[DISASSEMBLE] -> Instrução de branch identificada: 'b'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'na', 'opcode': 'b', 'type': '11', 'op2': 'r28'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'b', 'type': '11', 'op2': 'r28'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'b', 'type': '11', 'op2': 'r28'}
[ENCODE] -> Instrução de branch detectada: b com condição do
[ENCODE] -> Próximo endereço de instrução: 66
[INSTRUCTION] -> Codificação concluída. Binário: 00001100000000000000000000011100

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'subi: r29 = r29, 1' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'subi: r29 = r29, 1'
[DISASSEMBLE] -> Parte do opcode: 'subi', Parte dos operandos: 'r29 = r29, 1'
[DISASSEMBLE] -> Sufixo de suporte encontrado: 'i'. Opcode final é 'sub'
[DISASSEMBLE] -> Opcode final: 'sub', Tipo: 00
[DISASSEMBLE] -> Instrução com atribuição. Destino: 'r29', Origem: 'r29, 1'
[DISASSEMBLE] -> Operandos finais: Rd='r29', Rh='r29', Op2='1'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'i', 'opcode': 'sub', 'type': '00', 'rd': 'r29', 'rh': 'r29', 'op2': '1'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'sub', 'type': '00', 'rd': 'r29', 'rh': 'r29', 'op2': '1'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'sub', 'type': '00', 'rd': 'r29', 'rh': 'r29', 'op2': '1'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000010000111101111010000000001

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'store: [r29] = r28' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'store: [r29] = r28'
[DISASSEMBLE] -> Parte do opcode: 'store', Parte dos operandos: '[r29] = r28'
[DISASSEMBLE] -> Opcode final: 'store', Tipo: 01
[DISASSEMBLE] -> Instrução Store com endereçamento por registrador. Dest detectado: [r29]. Source detectado: 'r28'
[DISASSEMBLE] -> Instrução Load/Store com endereçamento por registrador.
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'na', 'opcode': 'store', 'type': '01', 'rd': 'r0', 'op2': 'r29', 'rh': 'r28'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'store', 'type': '01', 'rd': 'r0', 'op2': 'r29', 'rh': 'r28'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'store', 'type': '01', 'rd': 'r0', 'op2': 'r29', 'rh': 'r28'}
[ENCODE] -> Instrução Store detectada.
[ENCODE] -> rd_bin, rh_bin calculados: Rd(r0)=:00000 e Rh(r28)=:11100
[ENCODE] -> Op2 é um registrador: r29, convertido para binário: 1110100000
[INSTRUCTION] -> Codificação concluída. Binário: 00000100000000000111001110100000

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'subi: r29 = r29, 1' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'subi: r29 = r29, 1'
[DISASSEMBLE] -> Parte do opcode: 'subi', Parte dos operandos: 'r29 = r29, 1'
[DISASSEMBLE] -> Sufixo de suporte encontrado: 'i'. Opcode final é 'sub'
[DISASSEMBLE] -> Opcode final: 'sub', Tipo: 00
[DISASSEMBLE] -> Instrução com atribuição. Destino: 'r29', Origem: 'r29, 1'
[DISASSEMBLE] -> Operandos finais: Rd='r29', Rh='r29', Op2='1'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'i', 'opcode': 'sub', 'type': '00', 'rd': 'r29', 'rh': 'r29', 'op2': '1'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'sub', 'type': '00', 'rd': 'r29', 'rh': 'r29', 'op2': '1'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'sub', 'type': '00', 'rd': 'r29', 'rh': 'r29', 'op2': '1'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000010000111101111010000000001

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'store: [r29] = r31' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'store: [r29] = r31'
[DISASSEMBLE] -> Parte do opcode: 'store', Parte dos operandos: '[r29] = r31'
[DISASSEMBLE] -> Opcode final: 'store', Tipo: 01
[DISASSEMBLE] -> Instrução Store com endereçamento por registrador. Dest detectado: [r29]. Source detectado: 'r31'
[DISASSEMBLE] -> Instrução Load/Store com endereçamento por registrador.
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'na', 'opcode': 'store', 'type': '01', 'rd': 'r0', 'op2': 'r29', 'rh': 'r31'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'store', 'type': '01', 'rd': 'r0', 'op2': 'r29', 'rh': 'r31'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'store', 'type': '01', 'rd': 'r0', 'op2': 'r29', 'rh': 'r31'}
[ENCODE] -> Instrução Store detectada.
[ENCODE] -> rd_bin, rh_bin calculados: Rd(r0)=:00000 e Rh(r31)=:11111
[ENCODE] -> Op2 é um registrador: r29, convertido para binário: 1110100000
[INSTRUCTION] -> Codificação concluída. Binário: 00000100000000000111111110100000

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'mov: r31 = r29' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'mov: r31 = r29'
[DISASSEMBLE] -> Parte do opcode: 'mov', Parte dos operandos: 'r31 = r29'
[DISASSEMBLE] -> Opcode final: 'mov', Tipo: 00
[DISASSEMBLE] -> Instrução 'mov' identificada. Destino: 'r31', Origem: 'r29'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'na', 'opcode': 'mov', 'type': '00', 'rd': 'r31', 'rh': 'r0', 'op2': 'r29'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'mov', 'type': '00', 'rd': 'r31', 'rh': 'r0', 'op2': 'r29'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'mov', 'type': '00', 'rd': 'r31', 'rh': 'r0', 'op2': 'r29'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000000100011111000001110100000

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'movi: r13 = 35' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'movi: r13 = 35'
[DISASSEMBLE] -> Parte do opcode: 'movi', Parte dos operandos: 'r13 = 35'
[DISASSEMBLE] -> Sufixo de suporte encontrado: 'i'. Opcode final é 'mov'
[DISASSEMBLE] -> Opcode final: 'mov', Tipo: 00
[DISASSEMBLE] -> Instrução 'mov' identificada. Destino: 'r13', Origem: '35'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'i', 'opcode': 'mov', 'type': '00', 'rd': 'r13', 'rh': 'r0', 'op2': '35'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'mov', 'type': '00', 'rd': 'r13', 'rh': 'r0', 'op2': '35'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'mov', 'type': '00', 'rd': 'r13', 'rh': 'r0', 'op2': '35'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000010100001101000000000100011

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'load: r12 = [r13]' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'load: r12 = [r13]'
[DISASSEMBLE] -> Parte do opcode: 'load', Parte dos operandos: 'r12 = [r13]'
[DISASSEMBLE] -> Opcode final: 'load', Tipo: 01
[DISASSEMBLE] -> Instrução Load/Store com endereçamento por registrador.
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'na', 'opcode': 'load', 'type': '01', 'rd': 'r12', 'rh': 'r0', 'op2': 'r13'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'load', 'type': '01', 'rd': 'r12', 'rh': 'r0', 'op2': 'r13'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'load', 'type': '01', 'rd': 'r12', 'rh': 'r0', 'op2': 'r13'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000100000101100000000110100000

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'movi: r14 = 39' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'movi: r14 = 39'
[DISASSEMBLE] -> Parte do opcode: 'movi', Parte dos operandos: 'r14 = 39'
[DISASSEMBLE] -> Sufixo de suporte encontrado: 'i'. Opcode final é 'mov'
[DISASSEMBLE] -> Opcode final: 'mov', Tipo: 00
[DISASSEMBLE] -> Instrução 'mov' identificada. Destino: 'r14', Origem: '39'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'i', 'opcode': 'mov', 'type': '00', 'rd': 'r14', 'rh': 'r0', 'op2': '39'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'mov', 'type': '00', 'rd': 'r14', 'rh': 'r0', 'op2': '39'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'mov', 'type': '00', 'rd': 'r14', 'rh': 'r0', 'op2': '39'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000010100001110000000000100111

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'store: [r14] = r12' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'store: [r14] = r12'
[DISASSEMBLE] -> Parte do opcode: 'store', Parte dos operandos: '[r14] = r12'
[DISASSEMBLE] -> Opcode final: 'store', Tipo: 01
[DISASSEMBLE] -> Instrução Store com endereçamento por registrador. Dest detectado: [r14]. Source detectado: 'r12'
[DISASSEMBLE] -> Instrução Load/Store com endereçamento por registrador.
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'na', 'opcode': 'store', 'type': '01', 'rd': 'r0', 'op2': 'r14', 'rh': 'r12'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'store', 'type': '01', 'rd': 'r0', 'op2': 'r14', 'rh': 'r12'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'store', 'type': '01', 'rd': 'r0', 'op2': 'r14', 'rh': 'r12'}
[ENCODE] -> Instrução Store detectada.
[ENCODE] -> rd_bin, rh_bin calculados: Rd(r0)=:00000 e Rh(r12)=:01100
[ENCODE] -> Op2 é um registrador: r14, convertido para binário: 0111000000
[INSTRUCTION] -> Codificação concluída. Binário: 00000100000000000011000111000000

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'movi: r16 = 39' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'movi: r16 = 39'
[DISASSEMBLE] -> Parte do opcode: 'movi', Parte dos operandos: 'r16 = 39'
[DISASSEMBLE] -> Sufixo de suporte encontrado: 'i'. Opcode final é 'mov'
[DISASSEMBLE] -> Opcode final: 'mov', Tipo: 00
[DISASSEMBLE] -> Instrução 'mov' identificada. Destino: 'r16', Origem: '39'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'i', 'opcode': 'mov', 'type': '00', 'rd': 'r16', 'rh': 'r0', 'op2': '39'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'mov', 'type': '00', 'rd': 'r16', 'rh': 'r0', 'op2': '39'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'mov', 'type': '00', 'rd': 'r16', 'rh': 'r0', 'op2': '39'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000010100010000000000000100111

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'load: r15 = [r16]' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'load: r15 = [r16]'
[DISASSEMBLE] -> Parte do opcode: 'load', Parte dos operandos: 'r15 = [r16]'
[DISASSEMBLE] -> Opcode final: 'load', Tipo: 01
[DISASSEMBLE] -> Instrução Load/Store com endereçamento por registrador.
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'na', 'opcode': 'load', 'type': '01', 'rd': 'r15', 'rh': 'r0', 'op2': 'r16'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'load', 'type': '01', 'rd': 'r15', 'rh': 'r0', 'op2': 'r16'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'load', 'type': '01', 'rd': 'r15', 'rh': 'r0', 'op2': 'r16'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000100000101111000001000000000

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'movi: r18 = 40' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'movi: r18 = 40'
[DISASSEMBLE] -> Parte do opcode: 'movi', Parte dos operandos: 'r18 = 40'
[DISASSEMBLE] -> Sufixo de suporte encontrado: 'i'. Opcode final é 'mov'
[DISASSEMBLE] -> Opcode final: 'mov', Tipo: 00
[DISASSEMBLE] -> Instrução 'mov' identificada. Destino: 'r18', Origem: '40'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'i', 'opcode': 'mov', 'type': '00', 'rd': 'r18', 'rh': 'r0', 'op2': '40'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'mov', 'type': '00', 'rd': 'r18', 'rh': 'r0', 'op2': '40'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'mov', 'type': '00', 'rd': 'r18', 'rh': 'r0', 'op2': '40'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000010100010010000000000101000

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'load: r17 = [r18]' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'load: r17 = [r18]'
[DISASSEMBLE] -> Parte do opcode: 'load', Parte dos operandos: 'r17 = [r18]'
[DISASSEMBLE] -> Opcode final: 'load', Tipo: 01
[DISASSEMBLE] -> Instrução Load/Store com endereçamento por registrador.
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'na', 'opcode': 'load', 'type': '01', 'rd': 'r17', 'rh': 'r0', 'op2': 'r18'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'load', 'type': '01', 'rd': 'r17', 'rh': 'r0', 'op2': 'r18'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'load', 'type': '01', 'rd': 'r17', 'rh': 'r0', 'op2': 'r18'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000100000110001000001001000000

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'subi: r19 = r17, 1' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'subi: r19 = r17, 1'
[DISASSEMBLE] -> Parte do opcode: 'subi', Parte dos operandos: 'r19 = r17, 1'
[DISASSEMBLE] -> Sufixo de suporte encontrado: 'i'. Opcode final é 'sub'
[DISASSEMBLE] -> Opcode final: 'sub', Tipo: 00
[DISASSEMBLE] -> Instrução com atribuição. Destino: 'r19', Origem: 'r17, 1'
[DISASSEMBLE] -> Operandos finais: Rd='r19', Rh='r17', Op2='1'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'i', 'opcode': 'sub', 'type': '00', 'rd': 'r19', 'rh': 'r17', 'op2': '1'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'sub', 'type': '00', 'rd': 'r19', 'rh': 'r17', 'op2': '1'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'sub', 'type': '00', 'rd': 'r19', 'rh': 'r17', 'op2': '1'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000010000110011100010000000001

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'subs: r0 = r15, r19' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'subs: r0 = r15, r19'
[DISASSEMBLE] -> Parte do opcode: 'subs', Parte dos operandos: 'r0 = r15, r19'
[DISASSEMBLE] -> Sufixo de suporte encontrado: 's'. Opcode final é 'sub'
[DISASSEMBLE] -> Opcode final: 'sub', Tipo: 00
[DISASSEMBLE] -> Instrução com atribuição. Destino: 'r0', Origem: 'r15, r19'
[DISASSEMBLE] -> Operandos finais: Rd='r0', Rh='r15', Op2='r19'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 's', 'opcode': 'sub', 'type': '00', 'rd': 'r0', 'rh': 'r15', 'op2': 'r19'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 's', 'opcode': 'sub', 'type': '00', 'rd': 'r0', 'rh': 'r15', 'op2': 'r19'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 's', 'opcode': 'sub', 'type': '00', 'rd': 'r0', 'rh': 'r15', 'op2': 'r19'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000001000100000011111001100000

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'bigteq: L5' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'bigteq: L5'
[DISASSEMBLE] -> Parte do opcode: 'bigteq', Parte dos operandos: 'L5'
[DISASSEMBLE] -> Instrução de branch identificada: 'bigteq'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'gteq', 'supp': 'i', 'opcode': 'b', 'type': '11', 'op2': 'L5'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'gteq', 'supp': 'i', 'opcode': 'b', 'type': '11', 'op2': 'L5'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'gteq', 'supp': 'i', 'opcode': 'b', 'type': '11', 'op2': 'L5'}
[ENCODE] -> Instrução de branch detectada: b com condição gteq
[ENCODE] -> Próximo endereço de instrução: 82
[INSTRUCTION] -> Codificação concluída. Binário: 01001110000000000000000000110010

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'movi: r21 = 33' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'movi: r21 = 33'
[DISASSEMBLE] -> Parte do opcode: 'movi', Parte dos operandos: 'r21 = 33'
[DISASSEMBLE] -> Sufixo de suporte encontrado: 'i'. Opcode final é 'mov'
[DISASSEMBLE] -> Opcode final: 'mov', Tipo: 00
[DISASSEMBLE] -> Instrução 'mov' identificada. Destino: 'r21', Origem: '33'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'i', 'opcode': 'mov', 'type': '00', 'rd': 'r21', 'rh': 'r0', 'op2': '33'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'mov', 'type': '00', 'rd': 'r21', 'rh': 'r0', 'op2': '33'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'mov', 'type': '00', 'rd': 'r21', 'rh': 'r0', 'op2': '33'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000010100010101000000000100001

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'load: r20 = [r21]' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'load: r20 = [r21]'
[DISASSEMBLE] -> Parte do opcode: 'load', Parte dos operandos: 'r20 = [r21]'
[DISASSEMBLE] -> Opcode final: 'load', Tipo: 01
[DISASSEMBLE] -> Instrução Load/Store com endereçamento por registrador.
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'na', 'opcode': 'load', 'type': '01', 'rd': 'r20', 'rh': 'r0', 'op2': 'r21'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'load', 'type': '01', 'rd': 'r20', 'rh': 'r0', 'op2': 'r21'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'load', 'type': '01', 'rd': 'r20', 'rh': 'r0', 'op2': 'r21'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000100000110100000001010100000

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'mov: r1 = r20' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'mov: r1 = r20'
[DISASSEMBLE] -> Parte do opcode: 'mov', Parte dos operandos: 'r1 = r20'
[DISASSEMBLE] -> Opcode final: 'mov', Tipo: 00
[DISASSEMBLE] -> Instrução 'mov' identificada. Destino: 'r1', Origem: 'r20'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'na', 'opcode': 'mov', 'type': '00', 'rd': 'r1', 'rh': 'r0', 'op2': 'r20'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'mov', 'type': '00', 'rd': 'r1', 'rh': 'r0', 'op2': 'r20'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'mov', 'type': '00', 'rd': 'r1', 'rh': 'r0', 'op2': 'r20'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000000100000001000001010000000

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'movi: r23 = 39' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'movi: r23 = 39'
[DISASSEMBLE] -> Parte do opcode: 'movi', Parte dos operandos: 'r23 = 39'
[DISASSEMBLE] -> Sufixo de suporte encontrado: 'i'. Opcode final é 'mov'
[DISASSEMBLE] -> Opcode final: 'mov', Tipo: 00
[DISASSEMBLE] -> Instrução 'mov' identificada. Destino: 'r23', Origem: '39'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'i', 'opcode': 'mov', 'type': '00', 'rd': 'r23', 'rh': 'r0', 'op2': '39'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'mov', 'type': '00', 'rd': 'r23', 'rh': 'r0', 'op2': '39'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'mov', 'type': '00', 'rd': 'r23', 'rh': 'r0', 'op2': '39'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000010100010111000000000100111

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'load: r22 = [r23]' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'load: r22 = [r23]'
[DISASSEMBLE] -> Parte do opcode: 'load', Parte dos operandos: 'r22 = [r23]'
[DISASSEMBLE] -> Opcode final: 'load', Tipo: 01
[DISASSEMBLE] -> Instrução Load/Store com endereçamento por registrador.
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'na', 'opcode': 'load', 'type': '01', 'rd': 'r22', 'rh': 'r0', 'op2': 'r23'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'load', 'type': '01', 'rd': 'r22', 'rh': 'r0', 'op2': 'r23'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'load', 'type': '01', 'rd': 'r22', 'rh': 'r0', 'op2': 'r23'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000100000110110000001011100000

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'mov: r2 = r22' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'mov: r2 = r22'
[DISASSEMBLE] -> Parte do opcode: 'mov', Parte dos operandos: 'r2 = r22'
[DISASSEMBLE] -> Opcode final: 'mov', Tipo: 00
[DISASSEMBLE] -> Instrução 'mov' identificada. Destino: 'r2', Origem: 'r22'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'na', 'opcode': 'mov', 'type': '00', 'rd': 'r2', 'rh': 'r0', 'op2': 'r22'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'mov', 'type': '00', 'rd': 'r2', 'rh': 'r0', 'op2': 'r22'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'mov', 'type': '00', 'rd': 'r2', 'rh': 'r0', 'op2': 'r22'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000000100000010000001011000000

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'movi: r25 = 40' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'movi: r25 = 40'
[DISASSEMBLE] -> Parte do opcode: 'movi', Parte dos operandos: 'r25 = 40'
[DISASSEMBLE] -> Sufixo de suporte encontrado: 'i'. Opcode final é 'mov'
[DISASSEMBLE] -> Opcode final: 'mov', Tipo: 00
[DISASSEMBLE] -> Instrução 'mov' identificada. Destino: 'r25', Origem: '40'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'i', 'opcode': 'mov', 'type': '00', 'rd': 'r25', 'rh': 'r0', 'op2': '40'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'mov', 'type': '00', 'rd': 'r25', 'rh': 'r0', 'op2': '40'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'mov', 'type': '00', 'rd': 'r25', 'rh': 'r0', 'op2': '40'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000010100011001000000000101000

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'load: r24 = [r25]' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'load: r24 = [r25]'
[DISASSEMBLE] -> Parte do opcode: 'load', Parte dos operandos: 'r24 = [r25]'
[DISASSEMBLE] -> Opcode final: 'load', Tipo: 01
[DISASSEMBLE] -> Instrução Load/Store com endereçamento por registrador.
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'na', 'opcode': 'load', 'type': '01', 'rd': 'r24', 'rh': 'r0', 'op2': 'r25'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'load', 'type': '01', 'rd': 'r24', 'rh': 'r0', 'op2': 'r25'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'load', 'type': '01', 'rd': 'r24', 'rh': 'r0', 'op2': 'r25'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000100000111000000001100100000

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'mov: r3 = r24' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'mov: r3 = r24'
[DISASSEMBLE] -> Parte do opcode: 'mov', Parte dos operandos: 'r3 = r24'
[DISASSEMBLE] -> Opcode final: 'mov', Tipo: 00
[DISASSEMBLE] -> Instrução 'mov' identificada. Destino: 'r3', Origem: 'r24'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'na', 'opcode': 'mov', 'type': '00', 'rd': 'r3', 'rh': 'r0', 'op2': 'r24'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'mov', 'type': '00', 'rd': 'r3', 'rh': 'r0', 'op2': 'r24'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'mov', 'type': '00', 'rd': 'r3', 'rh': 'r0', 'op2': 'r24'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000000100000011000001100000000

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'movi: r4 = 35' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'movi: r4 = 35'
[DISASSEMBLE] -> Parte do opcode: 'movi', Parte dos operandos: 'r4 = 35'
[DISASSEMBLE] -> Sufixo de suporte encontrado: 'i'. Opcode final é 'mov'
[DISASSEMBLE] -> Opcode final: 'mov', Tipo: 00
[DISASSEMBLE] -> Instrução 'mov' identificada. Destino: 'r4', Origem: '35'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'i', 'opcode': 'mov', 'type': '00', 'rd': 'r4', 'rh': 'r0', 'op2': '35'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'mov', 'type': '00', 'rd': 'r4', 'rh': 'r0', 'op2': '35'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'mov', 'type': '00', 'rd': 'r4', 'rh': 'r0', 'op2': '35'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000010100000100000000000100011

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'store: [r4] = r1' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'store: [r4] = r1'
[DISASSEMBLE] -> Parte do opcode: 'store', Parte dos operandos: '[r4] = r1'
[DISASSEMBLE] -> Opcode final: 'store', Tipo: 01
[DISASSEMBLE] -> Instrução Store com endereçamento por registrador. Dest detectado: [r4]. Source detectado: 'r1'
[DISASSEMBLE] -> Instrução Load/Store com endereçamento por registrador.
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'na', 'opcode': 'store', 'type': '01', 'rd': 'r0', 'op2': 'r4', 'rh': 'r1'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'store', 'type': '01', 'rd': 'r0', 'op2': 'r4', 'rh': 'r1'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'store', 'type': '01', 'rd': 'r0', 'op2': 'r4', 'rh': 'r1'}
[ENCODE] -> Instrução Store detectada.
[ENCODE] -> rd_bin, rh_bin calculados: Rd(r0)=:00000 e Rh(r1)=:00001
[ENCODE] -> Op2 é um registrador: r4, convertido para binário: 0010000000
[INSTRUCTION] -> Codificação concluída. Binário: 00000100000000000000010010000000

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'movi: r5 = 33' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'movi: r5 = 33'
[DISASSEMBLE] -> Parte do opcode: 'movi', Parte dos operandos: 'r5 = 33'
[DISASSEMBLE] -> Sufixo de suporte encontrado: 'i'. Opcode final é 'mov'
[DISASSEMBLE] -> Opcode final: 'mov', Tipo: 00
[DISASSEMBLE] -> Instrução 'mov' identificada. Destino: 'r5', Origem: '33'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'i', 'opcode': 'mov', 'type': '00', 'rd': 'r5', 'rh': 'r0', 'op2': '33'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'mov', 'type': '00', 'rd': 'r5', 'rh': 'r0', 'op2': '33'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'mov', 'type': '00', 'rd': 'r5', 'rh': 'r0', 'op2': '33'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000010100000101000000000100001

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'store: [r5] = r2' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'store: [r5] = r2'
[DISASSEMBLE] -> Parte do opcode: 'store', Parte dos operandos: '[r5] = r2'
[DISASSEMBLE] -> Opcode final: 'store', Tipo: 01
[DISASSEMBLE] -> Instrução Store com endereçamento por registrador. Dest detectado: [r5]. Source detectado: 'r2'
[DISASSEMBLE] -> Instrução Load/Store com endereçamento por registrador.
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'na', 'opcode': 'store', 'type': '01', 'rd': 'r0', 'op2': 'r5', 'rh': 'r2'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'store', 'type': '01', 'rd': 'r0', 'op2': 'r5', 'rh': 'r2'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'store', 'type': '01', 'rd': 'r0', 'op2': 'r5', 'rh': 'r2'}
[ENCODE] -> Instrução Store detectada.
[ENCODE] -> rd_bin, rh_bin calculados: Rd(r0)=:00000 e Rh(r2)=:00010
[ENCODE] -> Op2 é um registrador: r5, convertido para binário: 0010100000
[INSTRUCTION] -> Codificação concluída. Binário: 00000100000000000000100010100000

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'movi: r6 = 40' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'movi: r6 = 40'
[DISASSEMBLE] -> Parte do opcode: 'movi', Parte dos operandos: 'r6 = 40'
[DISASSEMBLE] -> Sufixo de suporte encontrado: 'i'. Opcode final é 'mov'
[DISASSEMBLE] -> Opcode final: 'mov', Tipo: 00
[DISASSEMBLE] -> Instrução 'mov' identificada. Destino: 'r6', Origem: '40'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'i', 'opcode': 'mov', 'type': '00', 'rd': 'r6', 'rh': 'r0', 'op2': '40'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'mov', 'type': '00', 'rd': 'r6', 'rh': 'r0', 'op2': '40'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'mov', 'type': '00', 'rd': 'r6', 'rh': 'r0', 'op2': '40'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000010100000110000000000101000

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'store: [r6] = r3' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'store: [r6] = r3'
[DISASSEMBLE] -> Parte do opcode: 'store', Parte dos operandos: '[r6] = r3'
[DISASSEMBLE] -> Opcode final: 'store', Tipo: 01
[DISASSEMBLE] -> Instrução Store com endereçamento por registrador. Dest detectado: [r6]. Source detectado: 'r3'
[DISASSEMBLE] -> Instrução Load/Store com endereçamento por registrador.
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'na', 'opcode': 'store', 'type': '01', 'rd': 'r0', 'op2': 'r6', 'rh': 'r3'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'store', 'type': '01', 'rd': 'r0', 'op2': 'r6', 'rh': 'r3'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'store', 'type': '01', 'rd': 'r0', 'op2': 'r6', 'rh': 'r3'}
[ENCODE] -> Instrução Store detectada.
[ENCODE] -> rd_bin, rh_bin calculados: Rd(r0)=:00000 e Rh(r3)=:00011
[ENCODE] -> Op2 é um registrador: r6, convertido para binário: 0011000000
[INSTRUCTION] -> Codificação concluída. Binário: 00000100000000000000110011000000

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'movi: r26 = sort_Lret0' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'movi: r26 = sort_Lret0'
[DISASSEMBLE] -> Parte do opcode: 'movi', Parte dos operandos: 'r26 = sort_Lret0'
[DISASSEMBLE] -> Sufixo de suporte encontrado: 'i'. Opcode final é 'mov'
[DISASSEMBLE] -> Opcode final: 'mov', Tipo: 00
[DISASSEMBLE] -> Instrução 'mov' identificada. Destino: 'r26', Origem: 'sort_Lret0'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'i', 'opcode': 'mov', 'type': '00', 'rd': 'r26', 'rh': 'r0', 'op2': 'sort_Lret0'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'mov', 'type': '00', 'rd': 'r26', 'rh': 'r0', 'op2': 'sort_Lret0'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'mov', 'type': '00', 'rd': 'r26', 'rh': 'r0', 'op2': 'sort_Lret0'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000010100011010000000001100100

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'mov: r28 = r26' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'mov: r28 = r26'
[DISASSEMBLE] -> Parte do opcode: 'mov', Parte dos operandos: 'r28 = r26'
[DISASSEMBLE] -> Opcode final: 'mov', Tipo: 00
[DISASSEMBLE] -> Instrução 'mov' identificada. Destino: 'r28', Origem: 'r26'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'na', 'opcode': 'mov', 'type': '00', 'rd': 'r28', 'rh': 'r0', 'op2': 'r26'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'mov', 'type': '00', 'rd': 'r28', 'rh': 'r0', 'op2': 'r26'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'mov', 'type': '00', 'rd': 'r28', 'rh': 'r0', 'op2': 'r26'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000000100011100000001101000000

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'bl: minloc' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'bl: minloc'
[DISASSEMBLE] -> Parte do opcode: 'bl', Parte dos operandos: 'minloc'
[DISASSEMBLE] -> Instrução de branch identificada: 'bl'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'na', 'opcode': 'bl', 'type': '11', 'op2': 'minloc'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'bl', 'type': '11', 'op2': 'minloc'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'bl', 'type': '11', 'op2': 'minloc'}
[ENCODE] -> Instrução de branch detectada: bl com condição do
[ENCODE] -> Próximo endereço de instrução: 100
[ENCODE] -> Instrução de branch com link detectada.
[ENCODE] -> Offset calculado: -99 (destino: 1, PC + 1: 100)
[INSTRUCTION] -> Codificação concluída. Binário: 00001100100011111111111110011101

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'mov: r7 = r0' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'mov: r7 = r0'
[DISASSEMBLE] -> Parte do opcode: 'mov', Parte dos operandos: 'r7 = r0'
[DISASSEMBLE] -> Opcode final: 'mov', Tipo: 00
[DISASSEMBLE] -> Instrução 'mov' identificada. Destino: 'r7', Origem: 'r0'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'na', 'opcode': 'mov', 'type': '00', 'rd': 'r7', 'rh': 'r0', 'op2': 'r0'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'mov', 'type': '00', 'rd': 'r7', 'rh': 'r0', 'op2': 'r0'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'mov', 'type': '00', 'rd': 'r7', 'rh': 'r0', 'op2': 'r0'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000000100000111000000000000000

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'movi: r8 = 38' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'movi: r8 = 38'
[DISASSEMBLE] -> Parte do opcode: 'movi', Parte dos operandos: 'r8 = 38'
[DISASSEMBLE] -> Sufixo de suporte encontrado: 'i'. Opcode final é 'mov'
[DISASSEMBLE] -> Opcode final: 'mov', Tipo: 00
[DISASSEMBLE] -> Instrução 'mov' identificada. Destino: 'r8', Origem: '38'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'i', 'opcode': 'mov', 'type': '00', 'rd': 'r8', 'rh': 'r0', 'op2': '38'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'mov', 'type': '00', 'rd': 'r8', 'rh': 'r0', 'op2': '38'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'mov', 'type': '00', 'rd': 'r8', 'rh': 'r0', 'op2': '38'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000010100001000000000000100110

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'store: [r8] = r7' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'store: [r8] = r7'
[DISASSEMBLE] -> Parte do opcode: 'store', Parte dos operandos: '[r8] = r7'
[DISASSEMBLE] -> Opcode final: 'store', Tipo: 01
[DISASSEMBLE] -> Instrução Store com endereçamento por registrador. Dest detectado: [r8]. Source detectado: 'r7'
[DISASSEMBLE] -> Instrução Load/Store com endereçamento por registrador.
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'na', 'opcode': 'store', 'type': '01', 'rd': 'r0', 'op2': 'r8', 'rh': 'r7'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'store', 'type': '01', 'rd': 'r0', 'op2': 'r8', 'rh': 'r7'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'store', 'type': '01', 'rd': 'r0', 'op2': 'r8', 'rh': 'r7'}
[ENCODE] -> Instrução Store detectada.
[ENCODE] -> rd_bin, rh_bin calculados: Rd(r0)=:00000 e Rh(r7)=:00111
[ENCODE] -> Op2 é um registrador: r8, convertido para binário: 0100000000
[INSTRUCTION] -> Codificação concluída. Binário: 00000100000000000001110100000000

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'movi: r10 = 38' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'movi: r10 = 38'
[DISASSEMBLE] -> Parte do opcode: 'movi', Parte dos operandos: 'r10 = 38'
[DISASSEMBLE] -> Sufixo de suporte encontrado: 'i'. Opcode final é 'mov'
[DISASSEMBLE] -> Opcode final: 'mov', Tipo: 00
[DISASSEMBLE] -> Instrução 'mov' identificada. Destino: 'r10', Origem: '38'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'i', 'opcode': 'mov', 'type': '00', 'rd': 'r10', 'rh': 'r0', 'op2': '38'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'mov', 'type': '00', 'rd': 'r10', 'rh': 'r0', 'op2': '38'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'mov', 'type': '00', 'rd': 'r10', 'rh': 'r0', 'op2': '38'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000010100001010000000000100110

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'load: r9 = [r10]' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'load: r9 = [r10]'
[DISASSEMBLE] -> Parte do opcode: 'load', Parte dos operandos: 'r9 = [r10]'
[DISASSEMBLE] -> Opcode final: 'load', Tipo: 01
[DISASSEMBLE] -> Instrução Load/Store com endereçamento por registrador.
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'na', 'opcode': 'load', 'type': '01', 'rd': 'r9', 'rh': 'r0', 'op2': 'r10'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'load', 'type': '01', 'rd': 'r9', 'rh': 'r0', 'op2': 'r10'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'load', 'type': '01', 'rd': 'r9', 'rh': 'r0', 'op2': 'r10'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000100000101001000000101000000

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'muli: r11 = r9, 4' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'muli: r11 = r9, 4'
[DISASSEMBLE] -> Parte do opcode: 'muli', Parte dos operandos: 'r11 = r9, 4'
[DISASSEMBLE] -> Sufixo de suporte encontrado: 'i'. Opcode final é 'mul'
[DISASSEMBLE] -> Opcode final: 'mul', Tipo: 00
[DISASSEMBLE] -> Instrução com atribuição. Destino: 'r11', Origem: 'r9, 4'
[DISASSEMBLE] -> Operandos finais: Rd='r11', Rh='r9', Op2='4'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'i', 'opcode': 'mul', 'type': '00', 'rd': 'r11', 'rh': 'r9', 'op2': '4'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'mul', 'type': '00', 'rd': 'r11', 'rh': 'r9', 'op2': '4'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'mul', 'type': '00', 'rd': 'r11', 'rh': 'r9', 'op2': '4'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000010001001011010010000000100

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'movi: r13 = 33' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'movi: r13 = 33'
[DISASSEMBLE] -> Parte do opcode: 'movi', Parte dos operandos: 'r13 = 33'
[DISASSEMBLE] -> Sufixo de suporte encontrado: 'i'. Opcode final é 'mov'
[DISASSEMBLE] -> Opcode final: 'mov', Tipo: 00
[DISASSEMBLE] -> Instrução 'mov' identificada. Destino: 'r13', Origem: '33'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'i', 'opcode': 'mov', 'type': '00', 'rd': 'r13', 'rh': 'r0', 'op2': '33'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'mov', 'type': '00', 'rd': 'r13', 'rh': 'r0', 'op2': '33'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'mov', 'type': '00', 'rd': 'r13', 'rh': 'r0', 'op2': '33'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000010100001101000000000100001

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'add: r12 = r13, r11' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'add: r12 = r13, r11'
[DISASSEMBLE] -> Parte do opcode: 'add', Parte dos operandos: 'r12 = r13, r11'
[DISASSEMBLE] -> Opcode final: 'add', Tipo: 00
[DISASSEMBLE] -> Instrução com atribuição. Destino: 'r12', Origem: 'r13, r11'
[DISASSEMBLE] -> Operandos finais: Rd='r12', Rh='r13', Op2='r11'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'na', 'opcode': 'add', 'type': '00', 'rd': 'r12', 'rh': 'r13', 'op2': 'r11'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'add', 'type': '00', 'rd': 'r12', 'rh': 'r13', 'op2': 'r11'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'add', 'type': '00', 'rd': 'r12', 'rh': 'r13', 'op2': 'r11'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000000000001100011010101100000

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'store: [r14] = r12' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'store: [r14] = r12'
[DISASSEMBLE] -> Parte do opcode: 'store', Parte dos operandos: '[r14] = r12'
[DISASSEMBLE] -> Opcode final: 'store', Tipo: 01
[DISASSEMBLE] -> Instrução Store com endereçamento por registrador. Dest detectado: [r14]. Source detectado: 'r12'
[DISASSEMBLE] -> Instrução Load/Store com endereçamento por registrador.
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'na', 'opcode': 'store', 'type': '01', 'rd': 'r0', 'op2': 'r14', 'rh': 'r12'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'store', 'type': '01', 'rd': 'r0', 'op2': 'r14', 'rh': 'r12'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'store', 'type': '01', 'rd': 'r0', 'op2': 'r14', 'rh': 'r12'}
[ENCODE] -> Instrução Store detectada.
[ENCODE] -> rd_bin, rh_bin calculados: Rd(r0)=:00000 e Rh(r12)=:01100
[ENCODE] -> Op2 é um registrador: r14, convertido para binário: 0111000000
[INSTRUCTION] -> Codificação concluída. Binário: 00000100000000000011000111000000

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'movi: r15 = 39' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'movi: r15 = 39'
[DISASSEMBLE] -> Parte do opcode: 'movi', Parte dos operandos: 'r15 = 39'
[DISASSEMBLE] -> Sufixo de suporte encontrado: 'i'. Opcode final é 'mov'
[DISASSEMBLE] -> Opcode final: 'mov', Tipo: 00
[DISASSEMBLE] -> Instrução 'mov' identificada. Destino: 'r15', Origem: '39'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'i', 'opcode': 'mov', 'type': '00', 'rd': 'r15', 'rh': 'r0', 'op2': '39'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'mov', 'type': '00', 'rd': 'r15', 'rh': 'r0', 'op2': '39'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'mov', 'type': '00', 'rd': 'r15', 'rh': 'r0', 'op2': '39'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000010100001111000000000100111

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'load: r16 = [r15]' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'load: r16 = [r15]'
[DISASSEMBLE] -> Parte do opcode: 'load', Parte dos operandos: 'r16 = [r15]'
[DISASSEMBLE] -> Opcode final: 'load', Tipo: 01
[DISASSEMBLE] -> Instrução Load/Store com endereçamento por registrador.
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'na', 'opcode': 'load', 'type': '01', 'rd': 'r16', 'rh': 'r0', 'op2': 'r15'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'load', 'type': '01', 'rd': 'r16', 'rh': 'r0', 'op2': 'r15'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'load', 'type': '01', 'rd': 'r16', 'rh': 'r0', 'op2': 'r15'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000100000110000000000111100000

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'muli: r18 = r16, 4' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'muli: r18 = r16, 4'
[DISASSEMBLE] -> Parte do opcode: 'muli', Parte dos operandos: 'r18 = r16, 4'
[DISASSEMBLE] -> Sufixo de suporte encontrado: 'i'. Opcode final é 'mul'
[DISASSEMBLE] -> Opcode final: 'mul', Tipo: 00
[DISASSEMBLE] -> Instrução com atribuição. Destino: 'r18', Origem: 'r16, 4'
[DISASSEMBLE] -> Operandos finais: Rd='r18', Rh='r16', Op2='4'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'i', 'opcode': 'mul', 'type': '00', 'rd': 'r18', 'rh': 'r16', 'op2': '4'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'mul', 'type': '00', 'rd': 'r18', 'rh': 'r16', 'op2': '4'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'mul', 'type': '00', 'rd': 'r18', 'rh': 'r16', 'op2': '4'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000010001010010100000000000100

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'movi: r17 = 33' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'movi: r17 = 33'
[DISASSEMBLE] -> Parte do opcode: 'movi', Parte dos operandos: 'r17 = 33'
[DISASSEMBLE] -> Sufixo de suporte encontrado: 'i'. Opcode final é 'mov'
[DISASSEMBLE] -> Opcode final: 'mov', Tipo: 00
[DISASSEMBLE] -> Instrução 'mov' identificada. Destino: 'r17', Origem: '33'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'i', 'opcode': 'mov', 'type': '00', 'rd': 'r17', 'rh': 'r0', 'op2': '33'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'mov', 'type': '00', 'rd': 'r17', 'rh': 'r0', 'op2': '33'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'mov', 'type': '00', 'rd': 'r17', 'rh': 'r0', 'op2': '33'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000010100010001000000000100001

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'add: r21 = r17, r18' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'add: r21 = r17, r18'
[DISASSEMBLE] -> Parte do opcode: 'add', Parte dos operandos: 'r21 = r17, r18'
[DISASSEMBLE] -> Opcode final: 'add', Tipo: 00
[DISASSEMBLE] -> Instrução com atribuição. Destino: 'r21', Origem: 'r17, r18'
[DISASSEMBLE] -> Operandos finais: Rd='r21', Rh='r17', Op2='r18'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'na', 'opcode': 'add', 'type': '00', 'rd': 'r21', 'rh': 'r17', 'op2': 'r18'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'add', 'type': '00', 'rd': 'r21', 'rh': 'r17', 'op2': 'r18'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'add', 'type': '00', 'rd': 'r21', 'rh': 'r17', 'op2': 'r18'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000000000010101100011001000000

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'movi: r23 = 38' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'movi: r23 = 38'
[DISASSEMBLE] -> Parte do opcode: 'movi', Parte dos operandos: 'r23 = 38'
[DISASSEMBLE] -> Sufixo de suporte encontrado: 'i'. Opcode final é 'mov'
[DISASSEMBLE] -> Opcode final: 'mov', Tipo: 00
[DISASSEMBLE] -> Instrução 'mov' identificada. Destino: 'r23', Origem: '38'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'i', 'opcode': 'mov', 'type': '00', 'rd': 'r23', 'rh': 'r0', 'op2': '38'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'mov', 'type': '00', 'rd': 'r23', 'rh': 'r0', 'op2': '38'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'mov', 'type': '00', 'rd': 'r23', 'rh': 'r0', 'op2': '38'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000010100010111000000000100110

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'load: r20 = [r23]' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'load: r20 = [r23]'
[DISASSEMBLE] -> Parte do opcode: 'load', Parte dos operandos: 'r20 = [r23]'
[DISASSEMBLE] -> Opcode final: 'load', Tipo: 01
[DISASSEMBLE] -> Instrução Load/Store com endereçamento por registrador.
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'na', 'opcode': 'load', 'type': '01', 'rd': 'r20', 'rh': 'r0', 'op2': 'r23'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'load', 'type': '01', 'rd': 'r20', 'rh': 'r0', 'op2': 'r23'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'load', 'type': '01', 'rd': 'r20', 'rh': 'r0', 'op2': 'r23'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000100000110100000001011100000

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'muli: r22 = r20, 4' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'muli: r22 = r20, 4'
[DISASSEMBLE] -> Parte do opcode: 'muli', Parte dos operandos: 'r22 = r20, 4'
[DISASSEMBLE] -> Sufixo de suporte encontrado: 'i'. Opcode final é 'mul'
[DISASSEMBLE] -> Opcode final: 'mul', Tipo: 00
[DISASSEMBLE] -> Instrução com atribuição. Destino: 'r22', Origem: 'r20, 4'
[DISASSEMBLE] -> Operandos finais: Rd='r22', Rh='r20', Op2='4'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'i', 'opcode': 'mul', 'type': '00', 'rd': 'r22', 'rh': 'r20', 'op2': '4'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'mul', 'type': '00', 'rd': 'r22', 'rh': 'r20', 'op2': '4'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'mul', 'type': '00', 'rd': 'r22', 'rh': 'r20', 'op2': '4'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000010001010110101000000000100

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'movi: r25 = 33' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'movi: r25 = 33'
[DISASSEMBLE] -> Parte do opcode: 'movi', Parte dos operandos: 'r25 = 33'
[DISASSEMBLE] -> Sufixo de suporte encontrado: 'i'. Opcode final é 'mov'
[DISASSEMBLE] -> Opcode final: 'mov', Tipo: 00
[DISASSEMBLE] -> Instrução 'mov' identificada. Destino: 'r25', Origem: '33'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'i', 'opcode': 'mov', 'type': '00', 'rd': 'r25', 'rh': 'r0', 'op2': '33'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'mov', 'type': '00', 'rd': 'r25', 'rh': 'r0', 'op2': '33'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'mov', 'type': '00', 'rd': 'r25', 'rh': 'r0', 'op2': '33'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000010100011001000000000100001

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'add: r24 = r25, r22' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'add: r24 = r25, r22'
[DISASSEMBLE] -> Parte do opcode: 'add', Parte dos operandos: 'r24 = r25, r22'
[DISASSEMBLE] -> Opcode final: 'add', Tipo: 00
[DISASSEMBLE] -> Instrução com atribuição. Destino: 'r24', Origem: 'r25, r22'
[DISASSEMBLE] -> Operandos finais: Rd='r24', Rh='r25', Op2='r22'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'na', 'opcode': 'add', 'type': '00', 'rd': 'r24', 'rh': 'r25', 'op2': 'r22'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'add', 'type': '00', 'rd': 'r24', 'rh': 'r25', 'op2': 'r22'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'add', 'type': '00', 'rd': 'r24', 'rh': 'r25', 'op2': 'r22'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000000000011000110011011000000

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'store: [r24] = r21' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'store: [r24] = r21'
[DISASSEMBLE] -> Parte do opcode: 'store', Parte dos operandos: '[r24] = r21'
[DISASSEMBLE] -> Opcode final: 'store', Tipo: 01
[DISASSEMBLE] -> Instrução Store com endereçamento por registrador. Dest detectado: [r24]. Source detectado: 'r21'
[DISASSEMBLE] -> Instrução Load/Store com endereçamento por registrador.
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'na', 'opcode': 'store', 'type': '01', 'rd': 'r0', 'op2': 'r24', 'rh': 'r21'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'store', 'type': '01', 'rd': 'r0', 'op2': 'r24', 'rh': 'r21'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'store', 'type': '01', 'rd': 'r0', 'op2': 'r24', 'rh': 'r21'}
[ENCODE] -> Instrução Store detectada.
[ENCODE] -> rd_bin, rh_bin calculados: Rd(r0)=:00000 e Rh(r21)=:10101
[ENCODE] -> Op2 é um registrador: r24, convertido para binário: 1100000000
[INSTRUCTION] -> Codificação concluída. Binário: 00000100000000000101011100000000

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'movi: r6 = 39' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'movi: r6 = 39'
[DISASSEMBLE] -> Parte do opcode: 'movi', Parte dos operandos: 'r6 = 39'
[DISASSEMBLE] -> Sufixo de suporte encontrado: 'i'. Opcode final é 'mov'
[DISASSEMBLE] -> Opcode final: 'mov', Tipo: 00
[DISASSEMBLE] -> Instrução 'mov' identificada. Destino: 'r6', Origem: '39'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'i', 'opcode': 'mov', 'type': '00', 'rd': 'r6', 'rh': 'r0', 'op2': '39'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'mov', 'type': '00', 'rd': 'r6', 'rh': 'r0', 'op2': '39'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'mov', 'type': '00', 'rd': 'r6', 'rh': 'r0', 'op2': '39'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000010100000110000000000100111

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'load: r5 = [r6]' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'load: r5 = [r6]'
[DISASSEMBLE] -> Parte do opcode: 'load', Parte dos operandos: 'r5 = [r6]'
[DISASSEMBLE] -> Opcode final: 'load', Tipo: 01
[DISASSEMBLE] -> Instrução Load/Store com endereçamento por registrador.
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'na', 'opcode': 'load', 'type': '01', 'rd': 'r5', 'rh': 'r0', 'op2': 'r6'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'load', 'type': '01', 'rd': 'r5', 'rh': 'r0', 'op2': 'r6'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'load', 'type': '01', 'rd': 'r5', 'rh': 'r0', 'op2': 'r6'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000100000100101000000011000000

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'muli: r26 = r5, 4' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'muli: r26 = r5, 4'
[DISASSEMBLE] -> Parte do opcode: 'muli', Parte dos operandos: 'r26 = r5, 4'
[DISASSEMBLE] -> Sufixo de suporte encontrado: 'i'. Opcode final é 'mul'
[DISASSEMBLE] -> Opcode final: 'mul', Tipo: 00
[DISASSEMBLE] -> Instrução com atribuição. Destino: 'r26', Origem: 'r5, 4'
[DISASSEMBLE] -> Operandos finais: Rd='r26', Rh='r5', Op2='4'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'i', 'opcode': 'mul', 'type': '00', 'rd': 'r26', 'rh': 'r5', 'op2': '4'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'mul', 'type': '00', 'rd': 'r26', 'rh': 'r5', 'op2': '4'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'mul', 'type': '00', 'rd': 'r26', 'rh': 'r5', 'op2': '4'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000010001011010001010000000100

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'movi: r7 = 33' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'movi: r7 = 33'
[DISASSEMBLE] -> Parte do opcode: 'movi', Parte dos operandos: 'r7 = 33'
[DISASSEMBLE] -> Sufixo de suporte encontrado: 'i'. Opcode final é 'mov'
[DISASSEMBLE] -> Opcode final: 'mov', Tipo: 00
[DISASSEMBLE] -> Instrução 'mov' identificada. Destino: 'r7', Origem: '33'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'i', 'opcode': 'mov', 'type': '00', 'rd': 'r7', 'rh': 'r0', 'op2': '33'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'mov', 'type': '00', 'rd': 'r7', 'rh': 'r0', 'op2': '33'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'mov', 'type': '00', 'rd': 'r7', 'rh': 'r0', 'op2': '33'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000010100000111000000000100001

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'add: r8 = r7, r26' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'add: r8 = r7, r26'
[DISASSEMBLE] -> Parte do opcode: 'add', Parte dos operandos: 'r8 = r7, r26'
[DISASSEMBLE] -> Opcode final: 'add', Tipo: 00
[DISASSEMBLE] -> Instrução com atribuição. Destino: 'r8', Origem: 'r7, r26'
[DISASSEMBLE] -> Operandos finais: Rd='r8', Rh='r7', Op2='r26'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'na', 'opcode': 'add', 'type': '00', 'rd': 'r8', 'rh': 'r7', 'op2': 'r26'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'add', 'type': '00', 'rd': 'r8', 'rh': 'r7', 'op2': 'r26'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'add', 'type': '00', 'rd': 'r8', 'rh': 'r7', 'op2': 'r26'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000000000001000001111101000000

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'store: [r8] = r4' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'store: [r8] = r4'
[DISASSEMBLE] -> Parte do opcode: 'store', Parte dos operandos: '[r8] = r4'
[DISASSEMBLE] -> Opcode final: 'store', Tipo: 01
[DISASSEMBLE] -> Instrução Store com endereçamento por registrador. Dest detectado: [r8]. Source detectado: 'r4'
[DISASSEMBLE] -> Instrução Load/Store com endereçamento por registrador.
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'na', 'opcode': 'store', 'type': '01', 'rd': 'r0', 'op2': 'r8', 'rh': 'r4'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'store', 'type': '01', 'rd': 'r0', 'op2': 'r8', 'rh': 'r4'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'store', 'type': '01', 'rd': 'r0', 'op2': 'r8', 'rh': 'r4'}
[ENCODE] -> Instrução Store detectada.
[ENCODE] -> rd_bin, rh_bin calculados: Rd(r0)=:00000 e Rh(r4)=:00100
[ENCODE] -> Op2 é um registrador: r8, convertido para binário: 0100000000
[INSTRUCTION] -> Codificação concluída. Binário: 00000100000000000001000100000000

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'movi: r9 = 39' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'movi: r9 = 39'
[DISASSEMBLE] -> Parte do opcode: 'movi', Parte dos operandos: 'r9 = 39'
[DISASSEMBLE] -> Sufixo de suporte encontrado: 'i'. Opcode final é 'mov'
[DISASSEMBLE] -> Opcode final: 'mov', Tipo: 00
[DISASSEMBLE] -> Instrução 'mov' identificada. Destino: 'r9', Origem: '39'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'i', 'opcode': 'mov', 'type': '00', 'rd': 'r9', 'rh': 'r0', 'op2': '39'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'mov', 'type': '00', 'rd': 'r9', 'rh': 'r0', 'op2': '39'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'mov', 'type': '00', 'rd': 'r9', 'rh': 'r0', 'op2': '39'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000010100001001000000000100111

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'load: r10 = [r9]' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'load: r10 = [r9]'
[DISASSEMBLE] -> Parte do opcode: 'load', Parte dos operandos: 'r10 = [r9]'
[DISASSEMBLE] -> Opcode final: 'load', Tipo: 01
[DISASSEMBLE] -> Instrução Load/Store com endereçamento por registrador.
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'na', 'opcode': 'load', 'type': '01', 'rd': 'r10', 'rh': 'r0', 'op2': 'r9'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'load', 'type': '01', 'rd': 'r10', 'rh': 'r0', 'op2': 'r9'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'load', 'type': '01', 'rd': 'r10', 'rh': 'r0', 'op2': 'r9'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000100000101010000000100100000

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'addi: r12 = r10, 1' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'addi: r12 = r10, 1'
[DISASSEMBLE] -> Parte do opcode: 'addi', Parte dos operandos: 'r12 = r10, 1'
[DISASSEMBLE] -> Sufixo de suporte encontrado: 'i'. Opcode final é 'add'
[DISASSEMBLE] -> Opcode final: 'add', Tipo: 00
[DISASSEMBLE] -> Instrução com atribuição. Destino: 'r12', Origem: 'r10, 1'
[DISASSEMBLE] -> Operandos finais: Rd='r12', Rh='r10', Op2='1'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'i', 'opcode': 'add', 'type': '00', 'rd': 'r12', 'rh': 'r10', 'op2': '1'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'add', 'type': '00', 'rd': 'r12', 'rh': 'r10', 'op2': '1'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'add', 'type': '00', 'rd': 'r12', 'rh': 'r10', 'op2': '1'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000010000001100010100000000001

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'movi: r14 = 39' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'movi: r14 = 39'
[DISASSEMBLE] -> Parte do opcode: 'movi', Parte dos operandos: 'r14 = 39'
[DISASSEMBLE] -> Sufixo de suporte encontrado: 'i'. Opcode final é 'mov'
[DISASSEMBLE] -> Opcode final: 'mov', Tipo: 00
[DISASSEMBLE] -> Instrução 'mov' identificada. Destino: 'r14', Origem: '39'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'i', 'opcode': 'mov', 'type': '00', 'rd': 'r14', 'rh': 'r0', 'op2': '39'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'mov', 'type': '00', 'rd': 'r14', 'rh': 'r0', 'op2': '39'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'mov', 'type': '00', 'rd': 'r14', 'rh': 'r0', 'op2': '39'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000010100001110000000000100111

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'store: [r14] = r12' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'store: [r14] = r12'
[DISASSEMBLE] -> Parte do opcode: 'store', Parte dos operandos: '[r14] = r12'
[DISASSEMBLE] -> Opcode final: 'store', Tipo: 01
[DISASSEMBLE] -> Instrução Store com endereçamento por registrador. Dest detectado: [r14]. Source detectado: 'r12'
[DISASSEMBLE] -> Instrução Load/Store com endereçamento por registrador.
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'na', 'opcode': 'store', 'type': '01', 'rd': 'r0', 'op2': 'r14', 'rh': 'r12'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'store', 'type': '01', 'rd': 'r0', 'op2': 'r14', 'rh': 'r12'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'store', 'type': '01', 'rd': 'r0', 'op2': 'r14', 'rh': 'r12'}
[ENCODE] -> Instrução Store detectada.
[ENCODE] -> rd_bin, rh_bin calculados: Rd(r0)=:00000 e Rh(r12)=:01100
[ENCODE] -> Op2 é um registrador: r14, convertido para binário: 0111000000
[INSTRUCTION] -> Codificação concluída. Binário: 00000100000000000011000111000000

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'bi: L4' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'bi: L4'
[DISASSEMBLE] -> Parte do opcode: 'bi', Parte dos operandos: 'L4'
[DISASSEMBLE] -> Instrução de branch identificada: 'bi'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'i', 'opcode': 'b', 'type': '11', 'op2': 'L4'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'b', 'type': '11', 'op2': 'L4'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'b', 'type': '11', 'op2': 'L4'}
[ENCODE] -> Instrução de branch detectada: b com condição do
[ENCODE] -> Próximo endereço de instrução: 132
[INSTRUCTION] -> Codificação concluída. Binário: 00001110000011111111111111000111

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'bi: sort_epilogue' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'bi: sort_epilogue'
[DISASSEMBLE] -> Parte do opcode: 'bi', Parte dos operandos: 'sort_epilogue'
[DISASSEMBLE] -> Instrução de branch identificada: 'bi'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'i', 'opcode': 'b', 'type': '11', 'op2': 'sort_epilogue'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'b', 'type': '11', 'op2': 'sort_epilogue'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'b', 'type': '11', 'op2': 'sort_epilogue'}
[ENCODE] -> Instrução de branch detectada: b com condição do
[ENCODE] -> Próximo endereço de instrução: 133
[INSTRUCTION] -> Codificação concluída. Binário: 00001110000000000000000000000000

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'mov: r29 = r31' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'mov: r29 = r31'
[DISASSEMBLE] -> Parte do opcode: 'mov', Parte dos operandos: 'r29 = r31'
[DISASSEMBLE] -> Opcode final: 'mov', Tipo: 00
[DISASSEMBLE] -> Instrução 'mov' identificada. Destino: 'r29', Origem: 'r31'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'na', 'opcode': 'mov', 'type': '00', 'rd': 'r29', 'rh': 'r0', 'op2': 'r31'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'mov', 'type': '00', 'rd': 'r29', 'rh': 'r0', 'op2': 'r31'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'mov', 'type': '00', 'rd': 'r29', 'rh': 'r0', 'op2': 'r31'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000000100011101000001111100000

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'load: r31 = [r29]' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'load: r31 = [r29]'
[DISASSEMBLE] -> Parte do opcode: 'load', Parte dos operandos: 'r31 = [r29]'
[DISASSEMBLE] -> Opcode final: 'load', Tipo: 01
[DISASSEMBLE] -> Instrução Load/Store com endereçamento por registrador.
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'na', 'opcode': 'load', 'type': '01', 'rd': 'r31', 'rh': 'r0', 'op2': 'r29'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'load', 'type': '01', 'rd': 'r31', 'rh': 'r0', 'op2': 'r29'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'load', 'type': '01', 'rd': 'r31', 'rh': 'r0', 'op2': 'r29'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000100000111111000001110100000

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'addi: r29 = r29, 1' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'addi: r29 = r29, 1'
[DISASSEMBLE] -> Parte do opcode: 'addi', Parte dos operandos: 'r29 = r29, 1'
[DISASSEMBLE] -> Sufixo de suporte encontrado: 'i'. Opcode final é 'add'
[DISASSEMBLE] -> Opcode final: 'add', Tipo: 00
[DISASSEMBLE] -> Instrução com atribuição. Destino: 'r29', Origem: 'r29, 1'
[DISASSEMBLE] -> Operandos finais: Rd='r29', Rh='r29', Op2='1'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'i', 'opcode': 'add', 'type': '00', 'rd': 'r29', 'rh': 'r29', 'op2': '1'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'add', 'type': '00', 'rd': 'r29', 'rh': 'r29', 'op2': '1'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'add', 'type': '00', 'rd': 'r29', 'rh': 'r29', 'op2': '1'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000010000011101111010000000001

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'load: r28 = [r29]' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'load: r28 = [r29]'
[DISASSEMBLE] -> Parte do opcode: 'load', Parte dos operandos: 'r28 = [r29]'
[DISASSEMBLE] -> Opcode final: 'load', Tipo: 01
[DISASSEMBLE] -> Instrução Load/Store com endereçamento por registrador.
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'na', 'opcode': 'load', 'type': '01', 'rd': 'r28', 'rh': 'r0', 'op2': 'r29'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'load', 'type': '01', 'rd': 'r28', 'rh': 'r0', 'op2': 'r29'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'load', 'type': '01', 'rd': 'r28', 'rh': 'r0', 'op2': 'r29'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000100000111100000001110100000

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'addi: r29 = r29, 1' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'addi: r29 = r29, 1'
[DISASSEMBLE] -> Parte do opcode: 'addi', Parte dos operandos: 'r29 = r29, 1'
[DISASSEMBLE] -> Sufixo de suporte encontrado: 'i'. Opcode final é 'add'
[DISASSEMBLE] -> Opcode final: 'add', Tipo: 00
[DISASSEMBLE] -> Instrução com atribuição. Destino: 'r29', Origem: 'r29, 1'
[DISASSEMBLE] -> Operandos finais: Rd='r29', Rh='r29', Op2='1'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'i', 'opcode': 'add', 'type': '00', 'rd': 'r29', 'rh': 'r29', 'op2': '1'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'add', 'type': '00', 'rd': 'r29', 'rh': 'r29', 'op2': '1'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'add', 'type': '00', 'rd': 'r29', 'rh': 'r29', 'op2': '1'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000010000011101111010000000001

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'b: r28' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'b: r28'
[DISASSEMBLE] -> Parte do opcode: 'b', Parte dos operandos: 'r28'
[DISASSEMBLE] -> Instrução de branch identificada: 'b'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'na', 'opcode': 'b', 'type': '11', 'op2': 'r28'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'b', 'type': '11', 'op2': 'r28'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'b', 'type': '11', 'op2': 'r28'}
[ENCODE] -> Instrução de branch detectada: b com condição do
[ENCODE] -> Próximo endereço de instrução: 139
[INSTRUCTION] -> Codificação concluída. Binário: 00001100000000000000000000011100

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'movi: r29 = stack_space' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'movi: r29 = stack_space'
[DISASSEMBLE] -> Parte do opcode: 'movi', Parte dos operandos: 'r29 = stack_space'
[DISASSEMBLE] -> Sufixo de suporte encontrado: 'i'. Opcode final é 'mov'
[DISASSEMBLE] -> Opcode final: 'mov', Tipo: 00
[DISASSEMBLE] -> Instrução 'mov' identificada. Destino: 'r29', Origem: 'stack_space'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'i', 'opcode': 'mov', 'type': '00', 'rd': 'r29', 'rh': 'r0', 'op2': 'stack_space'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'mov', 'type': '00', 'rd': 'r29', 'rh': 'r0', 'op2': 'stack_space'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'mov', 'type': '00', 'rd': 'r29', 'rh': 'r0', 'op2': 'stack_space'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000010100011101000000011001101

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'mov: r31 = r29' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'mov: r31 = r29'
[DISASSEMBLE] -> Parte do opcode: 'mov', Parte dos operandos: 'r31 = r29'
[DISASSEMBLE] -> Opcode final: 'mov', Tipo: 00
[DISASSEMBLE] -> Instrução 'mov' identificada. Destino: 'r31', Origem: 'r29'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'na', 'opcode': 'mov', 'type': '00', 'rd': 'r31', 'rh': 'r0', 'op2': 'r29'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'mov', 'type': '00', 'rd': 'r31', 'rh': 'r0', 'op2': 'r29'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'mov', 'type': '00', 'rd': 'r31', 'rh': 'r0', 'op2': 'r29'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000000100011111000001110100000

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'movi: r12 = 0' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'movi: r12 = 0'
[DISASSEMBLE] -> Parte do opcode: 'movi', Parte dos operandos: 'r12 = 0'
[DISASSEMBLE] -> Sufixo de suporte encontrado: 'i'. Opcode final é 'mov'
[DISASSEMBLE] -> Opcode final: 'mov', Tipo: 00
[DISASSEMBLE] -> Instrução 'mov' identificada. Destino: 'r12', Origem: '0'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'i', 'opcode': 'mov', 'type': '00', 'rd': 'r12', 'rh': 'r0', 'op2': '0'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'mov', 'type': '00', 'rd': 'r12', 'rh': 'r0', 'op2': '0'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'mov', 'type': '00', 'rd': 'r12', 'rh': 'r0', 'op2': '0'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000010100001100000000000000000

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'movi: r13 = 39' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'movi: r13 = 39'
[DISASSEMBLE] -> Parte do opcode: 'movi', Parte dos operandos: 'r13 = 39'
[DISASSEMBLE] -> Sufixo de suporte encontrado: 'i'. Opcode final é 'mov'
[DISASSEMBLE] -> Opcode final: 'mov', Tipo: 00
[DISASSEMBLE] -> Instrução 'mov' identificada. Destino: 'r13', Origem: '39'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'i', 'opcode': 'mov', 'type': '00', 'rd': 'r13', 'rh': 'r0', 'op2': '39'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'mov', 'type': '00', 'rd': 'r13', 'rh': 'r0', 'op2': '39'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'mov', 'type': '00', 'rd': 'r13', 'rh': 'r0', 'op2': '39'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000010100001101000000000100111

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'store: [r13] = r12' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'store: [r13] = r12'
[DISASSEMBLE] -> Parte do opcode: 'store', Parte dos operandos: '[r13] = r12'
[DISASSEMBLE] -> Opcode final: 'store', Tipo: 01
[DISASSEMBLE] -> Instrução Store com endereçamento por registrador. Dest detectado: [r13]. Source detectado: 'r12'
[DISASSEMBLE] -> Instrução Load/Store com endereçamento por registrador.
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'na', 'opcode': 'store', 'type': '01', 'rd': 'r0', 'op2': 'r13', 'rh': 'r12'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'store', 'type': '01', 'rd': 'r0', 'op2': 'r13', 'rh': 'r12'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'store', 'type': '01', 'rd': 'r0', 'op2': 'r13', 'rh': 'r12'}
[ENCODE] -> Instrução Store detectada.
[ENCODE] -> rd_bin, rh_bin calculados: Rd(r0)=:00000 e Rh(r12)=:01100
[ENCODE] -> Op2 é um registrador: r13, convertido para binário: 0110100000
[INSTRUCTION] -> Codificação concluída. Binário: 00000100000000000011000110100000

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'movi: r15 = 39' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'movi: r15 = 39'
[DISASSEMBLE] -> Parte do opcode: 'movi', Parte dos operandos: 'r15 = 39'
[DISASSEMBLE] -> Sufixo de suporte encontrado: 'i'. Opcode final é 'mov'
[DISASSEMBLE] -> Opcode final: 'mov', Tipo: 00
[DISASSEMBLE] -> Instrução 'mov' identificada. Destino: 'r15', Origem: '39'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'i', 'opcode': 'mov', 'type': '00', 'rd': 'r15', 'rh': 'r0', 'op2': '39'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'mov', 'type': '00', 'rd': 'r15', 'rh': 'r0', 'op2': '39'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'mov', 'type': '00', 'rd': 'r15', 'rh': 'r0', 'op2': '39'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000010100001111000000000100111

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'load: r14 = [r15]' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'load: r14 = [r15]'
[DISASSEMBLE] -> Parte do opcode: 'load', Parte dos operandos: 'r14 = [r15]'
[DISASSEMBLE] -> Opcode final: 'load', Tipo: 01
[DISASSEMBLE] -> Instrução Load/Store com endereçamento por registrador.
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'na', 'opcode': 'load', 'type': '01', 'rd': 'r14', 'rh': 'r0', 'op2': 'r15'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'load', 'type': '01', 'rd': 'r14', 'rh': 'r0', 'op2': 'r15'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'load', 'type': '01', 'rd': 'r14', 'rh': 'r0', 'op2': 'r15'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000100000101110000000111100000

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'movi: r16 = 10' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'movi: r16 = 10'
[DISASSEMBLE] -> Parte do opcode: 'movi', Parte dos operandos: 'r16 = 10'
[DISASSEMBLE] -> Sufixo de suporte encontrado: 'i'. Opcode final é 'mov'
[DISASSEMBLE] -> Opcode final: 'mov', Tipo: 00
[DISASSEMBLE] -> Instrução 'mov' identificada. Destino: 'r16', Origem: '10'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'i', 'opcode': 'mov', 'type': '00', 'rd': 'r16', 'rh': 'r0', 'op2': '10'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'mov', 'type': '00', 'rd': 'r16', 'rh': 'r0', 'op2': '10'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'mov', 'type': '00', 'rd': 'r16', 'rh': 'r0', 'op2': '10'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000010100010000000000000001010

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'subs: r0 = r14, r16' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'subs: r0 = r14, r16'
[DISASSEMBLE] -> Parte do opcode: 'subs', Parte dos operandos: 'r0 = r14, r16'
[DISASSEMBLE] -> Sufixo de suporte encontrado: 's'. Opcode final é 'sub'
[DISASSEMBLE] -> Opcode final: 'sub', Tipo: 00
[DISASSEMBLE] -> Instrução com atribuição. Destino: 'r0', Origem: 'r14, r16'
[DISASSEMBLE] -> Operandos finais: Rd='r0', Rh='r14', Op2='r16'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 's', 'opcode': 'sub', 'type': '00', 'rd': 'r0', 'rh': 'r14', 'op2': 'r16'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 's', 'opcode': 'sub', 'type': '00', 'rd': 'r0', 'rh': 'r14', 'op2': 'r16'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 's', 'opcode': 'sub', 'type': '00', 'rd': 'r0', 'rh': 'r14', 'op2': 'r16'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000001000100000011101000000000

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'bigteq: L7' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'bigteq: L7'
[DISASSEMBLE] -> Parte do opcode: 'bigteq', Parte dos operandos: 'L7'
[DISASSEMBLE] -> Instrução de branch identificada: 'bigteq'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'gteq', 'supp': 'i', 'opcode': 'b', 'type': '11', 'op2': 'L7'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'gteq', 'supp': 'i', 'opcode': 'b', 'type': '11', 'op2': 'L7'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'gteq', 'supp': 'i', 'opcode': 'b', 'type': '11', 'op2': 'L7'}
[ENCODE] -> Instrução de branch detectada: b com condição gteq
[ENCODE] -> Próximo endereço de instrução: 149
[INSTRUCTION] -> Codificação concluída. Binário: 01001110000000000000000000001101

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'in: r17' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'in: r17'
[DISASSEMBLE] -> Parte do opcode: 'in', Parte dos operandos: 'r17'
[DISASSEMBLE] -> Opcode final: 'in', Tipo: 00
[DISASSEMBLE] -> Instrução de operando único. Rd: 'r17'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'na', 'opcode': 'in', 'type': '00', 'rd': 'r17', 'rh': 'r0', 'op2': '0'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'in', 'type': '00', 'rd': 'r17', 'rh': 'r0', 'op2': '0'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'in', 'type': '00', 'rd': 'r17', 'rh': 'r0', 'op2': '0'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000000100110001000000000000000

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'movi: r19 = 39' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'movi: r19 = 39'
[DISASSEMBLE] -> Parte do opcode: 'movi', Parte dos operandos: 'r19 = 39'
[DISASSEMBLE] -> Sufixo de suporte encontrado: 'i'. Opcode final é 'mov'
[DISASSEMBLE] -> Opcode final: 'mov', Tipo: 00
[DISASSEMBLE] -> Instrução 'mov' identificada. Destino: 'r19', Origem: '39'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'i', 'opcode': 'mov', 'type': '00', 'rd': 'r19', 'rh': 'r0', 'op2': '39'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'mov', 'type': '00', 'rd': 'r19', 'rh': 'r0', 'op2': '39'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'mov', 'type': '00', 'rd': 'r19', 'rh': 'r0', 'op2': '39'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000010100010011000000000100111

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'load: r18 = [r19]' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'load: r18 = [r19]'
[DISASSEMBLE] -> Parte do opcode: 'load', Parte dos operandos: 'r18 = [r19]'
[DISASSEMBLE] -> Opcode final: 'load', Tipo: 01
[DISASSEMBLE] -> Instrução Load/Store com endereçamento por registrador.
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'na', 'opcode': 'load', 'type': '01', 'rd': 'r18', 'rh': 'r0', 'op2': 'r19'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'load', 'type': '01', 'rd': 'r18', 'rh': 'r0', 'op2': 'r19'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'load', 'type': '01', 'rd': 'r18', 'rh': 'r0', 'op2': 'r19'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000100000110010000001001100000

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'muli: r20 = r18, 4' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'muli: r20 = r18, 4'
[DISASSEMBLE] -> Parte do opcode: 'muli', Parte dos operandos: 'r20 = r18, 4'
[DISASSEMBLE] -> Sufixo de suporte encontrado: 'i'. Opcode final é 'mul'
[DISASSEMBLE] -> Opcode final: 'mul', Tipo: 00
[DISASSEMBLE] -> Instrução com atribuição. Destino: 'r20', Origem: 'r18, 4'
[DISASSEMBLE] -> Operandos finais: Rd='r20', Rh='r18', Op2='4'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'i', 'opcode': 'mul', 'type': '00', 'rd': 'r20', 'rh': 'r18', 'op2': '4'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'mul', 'type': '00', 'rd': 'r20', 'rh': 'r18', 'op2': '4'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'mul', 'type': '00', 'rd': 'r20', 'rh': 'r18', 'op2': '4'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000010001010100100100000000100

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'movi: r21 = 34' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'movi: r21 = 34'
[DISASSEMBLE] -> Parte do opcode: 'movi', Parte dos operandos: 'r21 = 34'
[DISASSEMBLE] -> Sufixo de suporte encontrado: 'i'. Opcode final é 'mov'
[DISASSEMBLE] -> Opcode final: 'mov', Tipo: 00
[DISASSEMBLE] -> Instrução 'mov' identificada. Destino: 'r21', Origem: '34'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'i', 'opcode': 'mov', 'type': '00', 'rd': 'r21', 'rh': 'r0', 'op2': '34'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'mov', 'type': '00', 'rd': 'r21', 'rh': 'r0', 'op2': '34'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'mov', 'type': '00', 'rd': 'r21', 'rh': 'r0', 'op2': '34'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000010100010101000000000100010

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'add: r22 = r21, r20' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'add: r22 = r21, r20'
[DISASSEMBLE] -> Parte do opcode: 'add', Parte dos operandos: 'r22 = r21, r20'
[DISASSEMBLE] -> Opcode final: 'add', Tipo: 00
[DISASSEMBLE] -> Instrução com atribuição. Destino: 'r22', Origem: 'r21, r20'
[DISASSEMBLE] -> Operandos finais: Rd='r22', Rh='r21', Op2='r20'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'na', 'opcode': 'add', 'type': '00', 'rd': 'r22', 'rh': 'r21', 'op2': 'r20'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'add', 'type': '00', 'rd': 'r22', 'rh': 'r21', 'op2': 'r20'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'add', 'type': '00', 'rd': 'r22', 'rh': 'r21', 'op2': 'r20'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000000000010110101011010000000

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'store: [r22] = r17' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'store: [r22] = r17'
[DISASSEMBLE] -> Parte do opcode: 'store', Parte dos operandos: '[r22] = r17'
[DISASSEMBLE] -> Opcode final: 'store', Tipo: 01
[DISASSEMBLE] -> Instrução Store com endereçamento por registrador. Dest detectado: [r22]. Source detectado: 'r17'
[DISASSEMBLE] -> Instrução Load/Store com endereçamento por registrador.
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'na', 'opcode': 'store', 'type': '01', 'rd': 'r0', 'op2': 'r22', 'rh': 'r17'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'store', 'type': '01', 'rd': 'r0', 'op2': 'r22', 'rh': 'r17'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'store', 'type': '01', 'rd': 'r0', 'op2': 'r22', 'rh': 'r17'}
[ENCODE] -> Instrução Store detectada.
[ENCODE] -> rd_bin, rh_bin calculados: Rd(r0)=:00000 e Rh(r17)=:10001
[ENCODE] -> Op2 é um registrador: r22, convertido para binário: 1011000000
[INSTRUCTION] -> Codificação concluída. Binário: 00000100000000000100011011000000

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'movi: r24 = 39' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'movi: r24 = 39'
[DISASSEMBLE] -> Parte do opcode: 'movi', Parte dos operandos: 'r24 = 39'
[DISASSEMBLE] -> Sufixo de suporte encontrado: 'i'. Opcode final é 'mov'
[DISASSEMBLE] -> Opcode final: 'mov', Tipo: 00
[DISASSEMBLE] -> Instrução 'mov' identificada. Destino: 'r24', Origem: '39'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'i', 'opcode': 'mov', 'type': '00', 'rd': 'r24', 'rh': 'r0', 'op2': '39'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'mov', 'type': '00', 'rd': 'r24', 'rh': 'r0', 'op2': '39'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'mov', 'type': '00', 'rd': 'r24', 'rh': 'r0', 'op2': '39'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000010100011000000000000100111

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'load: r23 = [r24]' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'load: r23 = [r24]'
[DISASSEMBLE] -> Parte do opcode: 'load', Parte dos operandos: 'r23 = [r24]'
[DISASSEMBLE] -> Opcode final: 'load', Tipo: 01
[DISASSEMBLE] -> Instrução Load/Store com endereçamento por registrador.
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'na', 'opcode': 'load', 'type': '01', 'rd': 'r23', 'rh': 'r0', 'op2': 'r24'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'load', 'type': '01', 'rd': 'r23', 'rh': 'r0', 'op2': 'r24'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'load', 'type': '01', 'rd': 'r23', 'rh': 'r0', 'op2': 'r24'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000100000110111000001100000000

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'addi: r25 = r23, 1' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'addi: r25 = r23, 1'
[DISASSEMBLE] -> Parte do opcode: 'addi', Parte dos operandos: 'r25 = r23, 1'
[DISASSEMBLE] -> Sufixo de suporte encontrado: 'i'. Opcode final é 'add'
[DISASSEMBLE] -> Opcode final: 'add', Tipo: 00
[DISASSEMBLE] -> Instrução com atribuição. Destino: 'r25', Origem: 'r23, 1'
[DISASSEMBLE] -> Operandos finais: Rd='r25', Rh='r23', Op2='1'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'i', 'opcode': 'add', 'type': '00', 'rd': 'r25', 'rh': 'r23', 'op2': '1'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'add', 'type': '00', 'rd': 'r25', 'rh': 'r23', 'op2': '1'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'add', 'type': '00', 'rd': 'r25', 'rh': 'r23', 'op2': '1'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000010000011001101110000000001

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'movi: r26 = 39' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'movi: r26 = 39'
[DISASSEMBLE] -> Parte do opcode: 'movi', Parte dos operandos: 'r26 = 39'
[DISASSEMBLE] -> Sufixo de suporte encontrado: 'i'. Opcode final é 'mov'
[DISASSEMBLE] -> Opcode final: 'mov', Tipo: 00
[DISASSEMBLE] -> Instrução 'mov' identificada. Destino: 'r26', Origem: '39'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'i', 'opcode': 'mov', 'type': '00', 'rd': 'r26', 'rh': 'r0', 'op2': '39'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'mov', 'type': '00', 'rd': 'r26', 'rh': 'r0', 'op2': '39'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'mov', 'type': '00', 'rd': 'r26', 'rh': 'r0', 'op2': '39'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000010100011010000000000100111

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'store: [r26] = r25' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'store: [r26] = r25'
[DISASSEMBLE] -> Parte do opcode: 'store', Parte dos operandos: '[r26] = r25'
[DISASSEMBLE] -> Opcode final: 'store', Tipo: 01
[DISASSEMBLE] -> Instrução Store com endereçamento por registrador. Dest detectado: [r26]. Source detectado: 'r25'
[DISASSEMBLE] -> Instrução Load/Store com endereçamento por registrador.
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'na', 'opcode': 'store', 'type': '01', 'rd': 'r0', 'op2': 'r26', 'rh': 'r25'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'store', 'type': '01', 'rd': 'r0', 'op2': 'r26', 'rh': 'r25'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'store', 'type': '01', 'rd': 'r0', 'op2': 'r26', 'rh': 'r25'}
[ENCODE] -> Instrução Store detectada.
[ENCODE] -> rd_bin, rh_bin calculados: Rd(r0)=:00000 e Rh(r25)=:11001
[ENCODE] -> Op2 é um registrador: r26, convertido para binário: 1101000000
[INSTRUCTION] -> Codificação concluída. Binário: 00000100000000000110011101000000

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'bi: L6' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'bi: L6'
[DISASSEMBLE] -> Parte do opcode: 'bi', Parte dos operandos: 'L6'
[DISASSEMBLE] -> Instrução de branch identificada: 'bi'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'i', 'opcode': 'b', 'type': '11', 'op2': 'L6'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'b', 'type': '11', 'op2': 'L6'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'b', 'type': '11', 'op2': 'L6'}
[ENCODE] -> Instrução de branch detectada: b com condição do
[ENCODE] -> Próximo endereço de instrução: 162
[INSTRUCTION] -> Codificação concluída. Binário: 00001110000011111111111111101110

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'movi: r5 = 34' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'movi: r5 = 34'
[DISASSEMBLE] -> Parte do opcode: 'movi', Parte dos operandos: 'r5 = 34'
[DISASSEMBLE] -> Sufixo de suporte encontrado: 'i'. Opcode final é 'mov'
[DISASSEMBLE] -> Opcode final: 'mov', Tipo: 00
[DISASSEMBLE] -> Instrução 'mov' identificada. Destino: 'r5', Origem: '34'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'i', 'opcode': 'mov', 'type': '00', 'rd': 'r5', 'rh': 'r0', 'op2': '34'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'mov', 'type': '00', 'rd': 'r5', 'rh': 'r0', 'op2': '34'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'mov', 'type': '00', 'rd': 'r5', 'rh': 'r0', 'op2': '34'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000010100000101000000000100010

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'load: r4 = [r5]' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'load: r4 = [r5]'
[DISASSEMBLE] -> Parte do opcode: 'load', Parte dos operandos: 'r4 = [r5]'
[DISASSEMBLE] -> Opcode final: 'load', Tipo: 01
[DISASSEMBLE] -> Instrução Load/Store com endereçamento por registrador.
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'na', 'opcode': 'load', 'type': '01', 'rd': 'r4', 'rh': 'r0', 'op2': 'r5'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'load', 'type': '01', 'rd': 'r4', 'rh': 'r0', 'op2': 'r5'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'load', 'type': '01', 'rd': 'r4', 'rh': 'r0', 'op2': 'r5'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000100000100100000000010100000

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'mov: r1 = r4' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'mov: r1 = r4'
[DISASSEMBLE] -> Parte do opcode: 'mov', Parte dos operandos: 'r1 = r4'
[DISASSEMBLE] -> Opcode final: 'mov', Tipo: 00
[DISASSEMBLE] -> Instrução 'mov' identificada. Destino: 'r1', Origem: 'r4'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'na', 'opcode': 'mov', 'type': '00', 'rd': 'r1', 'rh': 'r0', 'op2': 'r4'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'mov', 'type': '00', 'rd': 'r1', 'rh': 'r0', 'op2': 'r4'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'mov', 'type': '00', 'rd': 'r1', 'rh': 'r0', 'op2': 'r4'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000000100000001000000010000000

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'movi: r6 = 0' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'movi: r6 = 0'
[DISASSEMBLE] -> Parte do opcode: 'movi', Parte dos operandos: 'r6 = 0'
[DISASSEMBLE] -> Sufixo de suporte encontrado: 'i'. Opcode final é 'mov'
[DISASSEMBLE] -> Opcode final: 'mov', Tipo: 00
[DISASSEMBLE] -> Instrução 'mov' identificada. Destino: 'r6', Origem: '0'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'i', 'opcode': 'mov', 'type': '00', 'rd': 'r6', 'rh': 'r0', 'op2': '0'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'mov', 'type': '00', 'rd': 'r6', 'rh': 'r0', 'op2': '0'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'mov', 'type': '00', 'rd': 'r6', 'rh': 'r0', 'op2': '0'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000010100000110000000000000000

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'mov: r2 = r6' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'mov: r2 = r6'
[DISASSEMBLE] -> Parte do opcode: 'mov', Parte dos operandos: 'r2 = r6'
[DISASSEMBLE] -> Opcode final: 'mov', Tipo: 00
[DISASSEMBLE] -> Instrução 'mov' identificada. Destino: 'r2', Origem: 'r6'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'na', 'opcode': 'mov', 'type': '00', 'rd': 'r2', 'rh': 'r0', 'op2': 'r6'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'mov', 'type': '00', 'rd': 'r2', 'rh': 'r0', 'op2': 'r6'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'mov', 'type': '00', 'rd': 'r2', 'rh': 'r0', 'op2': 'r6'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000000100000010000000011000000

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'movi: r7 = 10' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'movi: r7 = 10'
[DISASSEMBLE] -> Parte do opcode: 'movi', Parte dos operandos: 'r7 = 10'
[DISASSEMBLE] -> Sufixo de suporte encontrado: 'i'. Opcode final é 'mov'
[DISASSEMBLE] -> Opcode final: 'mov', Tipo: 00
[DISASSEMBLE] -> Instrução 'mov' identificada. Destino: 'r7', Origem: '10'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'i', 'opcode': 'mov', 'type': '00', 'rd': 'r7', 'rh': 'r0', 'op2': '10'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'mov', 'type': '00', 'rd': 'r7', 'rh': 'r0', 'op2': '10'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'mov', 'type': '00', 'rd': 'r7', 'rh': 'r0', 'op2': '10'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000010100000111000000000001010

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'mov: r3 = r7' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'mov: r3 = r7'
[DISASSEMBLE] -> Parte do opcode: 'mov', Parte dos operandos: 'r3 = r7'
[DISASSEMBLE] -> Opcode final: 'mov', Tipo: 00
[DISASSEMBLE] -> Instrução 'mov' identificada. Destino: 'r3', Origem: 'r7'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'na', 'opcode': 'mov', 'type': '00', 'rd': 'r3', 'rh': 'r0', 'op2': 'r7'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'mov', 'type': '00', 'rd': 'r3', 'rh': 'r0', 'op2': 'r7'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'mov', 'type': '00', 'rd': 'r3', 'rh': 'r0', 'op2': 'r7'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000000100000011000000011100000

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'movi: r8 = 35' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'movi: r8 = 35'
[DISASSEMBLE] -> Parte do opcode: 'movi', Parte dos operandos: 'r8 = 35'
[DISASSEMBLE] -> Sufixo de suporte encontrado: 'i'. Opcode final é 'mov'
[DISASSEMBLE] -> Opcode final: 'mov', Tipo: 00
[DISASSEMBLE] -> Instrução 'mov' identificada. Destino: 'r8', Origem: '35'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'i', 'opcode': 'mov', 'type': '00', 'rd': 'r8', 'rh': 'r0', 'op2': '35'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'mov', 'type': '00', 'rd': 'r8', 'rh': 'r0', 'op2': '35'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'mov', 'type': '00', 'rd': 'r8', 'rh': 'r0', 'op2': '35'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000010100001000000000000100011

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'store: [r8] = r1' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'store: [r8] = r1'
[DISASSEMBLE] -> Parte do opcode: 'store', Parte dos operandos: '[r8] = r1'
[DISASSEMBLE] -> Opcode final: 'store', Tipo: 01
[DISASSEMBLE] -> Instrução Store com endereçamento por registrador. Dest detectado: [r8]. Source detectado: 'r1'
[DISASSEMBLE] -> Instrução Load/Store com endereçamento por registrador.
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'na', 'opcode': 'store', 'type': '01', 'rd': 'r0', 'op2': 'r8', 'rh': 'r1'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'store', 'type': '01', 'rd': 'r0', 'op2': 'r8', 'rh': 'r1'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'store', 'type': '01', 'rd': 'r0', 'op2': 'r8', 'rh': 'r1'}
[ENCODE] -> Instrução Store detectada.
[ENCODE] -> rd_bin, rh_bin calculados: Rd(r0)=:00000 e Rh(r1)=:00001
[ENCODE] -> Op2 é um registrador: r8, convertido para binário: 0100000000
[INSTRUCTION] -> Codificação concluída. Binário: 00000100000000000000010100000000

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'movi: r9 = 40' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'movi: r9 = 40'
[DISASSEMBLE] -> Parte do opcode: 'movi', Parte dos operandos: 'r9 = 40'
[DISASSEMBLE] -> Sufixo de suporte encontrado: 'i'. Opcode final é 'mov'
[DISASSEMBLE] -> Opcode final: 'mov', Tipo: 00
[DISASSEMBLE] -> Instrução 'mov' identificada. Destino: 'r9', Origem: '40'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'i', 'opcode': 'mov', 'type': '00', 'rd': 'r9', 'rh': 'r0', 'op2': '40'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'mov', 'type': '00', 'rd': 'r9', 'rh': 'r0', 'op2': '40'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'mov', 'type': '00', 'rd': 'r9', 'rh': 'r0', 'op2': '40'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000010100001001000000000101000

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'store: [r9] = r2' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'store: [r9] = r2'
[DISASSEMBLE] -> Parte do opcode: 'store', Parte dos operandos: '[r9] = r2'
[DISASSEMBLE] -> Opcode final: 'store', Tipo: 01
[DISASSEMBLE] -> Instrução Store com endereçamento por registrador. Dest detectado: [r9]. Source detectado: 'r2'
[DISASSEMBLE] -> Instrução Load/Store com endereçamento por registrador.
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'na', 'opcode': 'store', 'type': '01', 'rd': 'r0', 'op2': 'r9', 'rh': 'r2'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'store', 'type': '01', 'rd': 'r0', 'op2': 'r9', 'rh': 'r2'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'store', 'type': '01', 'rd': 'r0', 'op2': 'r9', 'rh': 'r2'}
[ENCODE] -> Instrução Store detectada.
[ENCODE] -> rd_bin, rh_bin calculados: Rd(r0)=:00000 e Rh(r2)=:00010
[ENCODE] -> Op2 é um registrador: r9, convertido para binário: 0100100000
[INSTRUCTION] -> Codificação concluída. Binário: 00000100000000000000100100100000

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'movi: r10 = 33' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'movi: r10 = 33'
[DISASSEMBLE] -> Parte do opcode: 'movi', Parte dos operandos: 'r10 = 33'
[DISASSEMBLE] -> Sufixo de suporte encontrado: 'i'. Opcode final é 'mov'
[DISASSEMBLE] -> Opcode final: 'mov', Tipo: 00
[DISASSEMBLE] -> Instrução 'mov' identificada. Destino: 'r10', Origem: '33'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'i', 'opcode': 'mov', 'type': '00', 'rd': 'r10', 'rh': 'r0', 'op2': '33'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'mov', 'type': '00', 'rd': 'r10', 'rh': 'r0', 'op2': '33'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'mov', 'type': '00', 'rd': 'r10', 'rh': 'r0', 'op2': '33'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000010100001010000000000100001

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'store: [r10] = r3' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'store: [r10] = r3'
[DISASSEMBLE] -> Parte do opcode: 'store', Parte dos operandos: '[r10] = r3'
[DISASSEMBLE] -> Opcode final: 'store', Tipo: 01
[DISASSEMBLE] -> Instrução Store com endereçamento por registrador. Dest detectado: [r10]. Source detectado: 'r3'
[DISASSEMBLE] -> Instrução Load/Store com endereçamento por registrador.
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'na', 'opcode': 'store', 'type': '01', 'rd': 'r0', 'op2': 'r10', 'rh': 'r3'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'store', 'type': '01', 'rd': 'r0', 'op2': 'r10', 'rh': 'r3'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'store', 'type': '01', 'rd': 'r0', 'op2': 'r10', 'rh': 'r3'}
[ENCODE] -> Instrução Store detectada.
[ENCODE] -> rd_bin, rh_bin calculados: Rd(r0)=:00000 e Rh(r3)=:00011
[ENCODE] -> Op2 é um registrador: r10, convertido para binário: 0101000000
[INSTRUCTION] -> Codificação concluída. Binário: 00000100000000000000110101000000

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'movi: r28 = main_Lret0' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'movi: r28 = main_Lret0'
[DISASSEMBLE] -> Parte do opcode: 'movi', Parte dos operandos: 'r28 = main_Lret0'
[DISASSEMBLE] -> Sufixo de suporte encontrado: 'i'. Opcode final é 'mov'
[DISASSEMBLE] -> Opcode final: 'mov', Tipo: 00
[DISASSEMBLE] -> Instrução 'mov' identificada. Destino: 'r28', Origem: 'main_Lret0'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'i', 'opcode': 'mov', 'type': '00', 'rd': 'r28', 'rh': 'r0', 'op2': 'main_Lret0'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'mov', 'type': '00', 'rd': 'r28', 'rh': 'r0', 'op2': 'main_Lret0'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'mov', 'type': '00', 'rd': 'r28', 'rh': 'r0', 'op2': 'main_Lret0'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000010100011100000000010110001

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'bl: sort' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'bl: sort'
[DISASSEMBLE] -> Parte do opcode: 'bl', Parte dos operandos: 'sort'
[DISASSEMBLE] -> Instrução de branch identificada: 'bl'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'na', 'opcode': 'bl', 'type': '11', 'op2': 'sort'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'bl', 'type': '11', 'op2': 'sort'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'bl', 'type': '11', 'op2': 'sort'}
[ENCODE] -> Instrução de branch detectada: bl com condição do
[ENCODE] -> Próximo endereço de instrução: 177
[ENCODE] -> Instrução de branch com link detectada.
[ENCODE] -> Offset calculado: -111 (destino: 66, PC + 1: 177)
[INSTRUCTION] -> Codificação concluída. Binário: 00001100100011111111111110010001

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'movi: r11 = 0' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'movi: r11 = 0'
[DISASSEMBLE] -> Parte do opcode: 'movi', Parte dos operandos: 'r11 = 0'
[DISASSEMBLE] -> Sufixo de suporte encontrado: 'i'. Opcode final é 'mov'
[DISASSEMBLE] -> Opcode final: 'mov', Tipo: 00
[DISASSEMBLE] -> Instrução 'mov' identificada. Destino: 'r11', Origem: '0'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'i', 'opcode': 'mov', 'type': '00', 'rd': 'r11', 'rh': 'r0', 'op2': '0'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'mov', 'type': '00', 'rd': 'r11', 'rh': 'r0', 'op2': '0'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'mov', 'type': '00', 'rd': 'r11', 'rh': 'r0', 'op2': '0'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000010100001011000000000000000

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'movi: r13 = 39' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'movi: r13 = 39'
[DISASSEMBLE] -> Parte do opcode: 'movi', Parte dos operandos: 'r13 = 39'
[DISASSEMBLE] -> Sufixo de suporte encontrado: 'i'. Opcode final é 'mov'
[DISASSEMBLE] -> Opcode final: 'mov', Tipo: 00
[DISASSEMBLE] -> Instrução 'mov' identificada. Destino: 'r13', Origem: '39'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'i', 'opcode': 'mov', 'type': '00', 'rd': 'r13', 'rh': 'r0', 'op2': '39'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'mov', 'type': '00', 'rd': 'r13', 'rh': 'r0', 'op2': '39'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'mov', 'type': '00', 'rd': 'r13', 'rh': 'r0', 'op2': '39'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000010100001101000000000100111

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'store: [r13] = r11' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'store: [r13] = r11'
[DISASSEMBLE] -> Parte do opcode: 'store', Parte dos operandos: '[r13] = r11'
[DISASSEMBLE] -> Opcode final: 'store', Tipo: 01
[DISASSEMBLE] -> Instrução Store com endereçamento por registrador. Dest detectado: [r13]. Source detectado: 'r11'
[DISASSEMBLE] -> Instrução Load/Store com endereçamento por registrador.
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'na', 'opcode': 'store', 'type': '01', 'rd': 'r0', 'op2': 'r13', 'rh': 'r11'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'store', 'type': '01', 'rd': 'r0', 'op2': 'r13', 'rh': 'r11'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'store', 'type': '01', 'rd': 'r0', 'op2': 'r13', 'rh': 'r11'}
[ENCODE] -> Instrução Store detectada.
[ENCODE] -> rd_bin, rh_bin calculados: Rd(r0)=:00000 e Rh(r11)=:01011
[ENCODE] -> Op2 é um registrador: r13, convertido para binário: 0110100000
[INSTRUCTION] -> Codificação concluída. Binário: 00000100000000000010110110100000

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'movi: r14 = 39' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'movi: r14 = 39'
[DISASSEMBLE] -> Parte do opcode: 'movi', Parte dos operandos: 'r14 = 39'
[DISASSEMBLE] -> Sufixo de suporte encontrado: 'i'. Opcode final é 'mov'
[DISASSEMBLE] -> Opcode final: 'mov', Tipo: 00
[DISASSEMBLE] -> Instrução 'mov' identificada. Destino: 'r14', Origem: '39'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'i', 'opcode': 'mov', 'type': '00', 'rd': 'r14', 'rh': 'r0', 'op2': '39'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'mov', 'type': '00', 'rd': 'r14', 'rh': 'r0', 'op2': '39'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'mov', 'type': '00', 'rd': 'r14', 'rh': 'r0', 'op2': '39'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000010100001110000000000100111

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'load: r15 = [r14]' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'load: r15 = [r14]'
[DISASSEMBLE] -> Parte do opcode: 'load', Parte dos operandos: 'r15 = [r14]'
[DISASSEMBLE] -> Opcode final: 'load', Tipo: 01
[DISASSEMBLE] -> Instrução Load/Store com endereçamento por registrador.
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'na', 'opcode': 'load', 'type': '01', 'rd': 'r15', 'rh': 'r0', 'op2': 'r14'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'load', 'type': '01', 'rd': 'r15', 'rh': 'r0', 'op2': 'r14'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'load', 'type': '01', 'rd': 'r15', 'rh': 'r0', 'op2': 'r14'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000100000101111000000111000000

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'movi: r19 = 10' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'movi: r19 = 10'
[DISASSEMBLE] -> Parte do opcode: 'movi', Parte dos operandos: 'r19 = 10'
[DISASSEMBLE] -> Sufixo de suporte encontrado: 'i'. Opcode final é 'mov'
[DISASSEMBLE] -> Opcode final: 'mov', Tipo: 00
[DISASSEMBLE] -> Instrução 'mov' identificada. Destino: 'r19', Origem: '10'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'i', 'opcode': 'mov', 'type': '00', 'rd': 'r19', 'rh': 'r0', 'op2': '10'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'mov', 'type': '00', 'rd': 'r19', 'rh': 'r0', 'op2': '10'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'mov', 'type': '00', 'rd': 'r19', 'rh': 'r0', 'op2': '10'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000010100010011000000000001010

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'subs: r0 = r15, r19' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'subs: r0 = r15, r19'
[DISASSEMBLE] -> Parte do opcode: 'subs', Parte dos operandos: 'r0 = r15, r19'
[DISASSEMBLE] -> Sufixo de suporte encontrado: 's'. Opcode final é 'sub'
[DISASSEMBLE] -> Opcode final: 'sub', Tipo: 00
[DISASSEMBLE] -> Instrução com atribuição. Destino: 'r0', Origem: 'r15, r19'
[DISASSEMBLE] -> Operandos finais: Rd='r0', Rh='r15', Op2='r19'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 's', 'opcode': 'sub', 'type': '00', 'rd': 'r0', 'rh': 'r15', 'op2': 'r19'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 's', 'opcode': 'sub', 'type': '00', 'rd': 'r0', 'rh': 'r15', 'op2': 'r19'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 's', 'opcode': 'sub', 'type': '00', 'rd': 'r0', 'rh': 'r15', 'op2': 'r19'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000001000100000011111001100000

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'bigteq: L9' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'bigteq: L9'
[DISASSEMBLE] -> Parte do opcode: 'bigteq', Parte dos operandos: 'L9'
[DISASSEMBLE] -> Instrução de branch identificada: 'bigteq'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'gteq', 'supp': 'i', 'opcode': 'b', 'type': '11', 'op2': 'L9'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'gteq', 'supp': 'i', 'opcode': 'b', 'type': '11', 'op2': 'L9'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'gteq', 'supp': 'i', 'opcode': 'b', 'type': '11', 'op2': 'L9'}
[ENCODE] -> Instrução de branch detectada: b com condição gteq
[ENCODE] -> Próximo endereço de instrução: 185
[INSTRUCTION] -> Codificação concluída. Binário: 01001110000000000000000000001101

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'movi: r17 = 39' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'movi: r17 = 39'
[DISASSEMBLE] -> Parte do opcode: 'movi', Parte dos operandos: 'r17 = 39'
[DISASSEMBLE] -> Sufixo de suporte encontrado: 'i'. Opcode final é 'mov'
[DISASSEMBLE] -> Opcode final: 'mov', Tipo: 00
[DISASSEMBLE] -> Instrução 'mov' identificada. Destino: 'r17', Origem: '39'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'i', 'opcode': 'mov', 'type': '00', 'rd': 'r17', 'rh': 'r0', 'op2': '39'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'mov', 'type': '00', 'rd': 'r17', 'rh': 'r0', 'op2': '39'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'mov', 'type': '00', 'rd': 'r17', 'rh': 'r0', 'op2': '39'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000010100010001000000000100111

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'load: r18 = [r17]' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'load: r18 = [r17]'
[DISASSEMBLE] -> Parte do opcode: 'load', Parte dos operandos: 'r18 = [r17]'
[DISASSEMBLE] -> Opcode final: 'load', Tipo: 01
[DISASSEMBLE] -> Instrução Load/Store com endereçamento por registrador.
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'na', 'opcode': 'load', 'type': '01', 'rd': 'r18', 'rh': 'r0', 'op2': 'r17'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'load', 'type': '01', 'rd': 'r18', 'rh': 'r0', 'op2': 'r17'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'load', 'type': '01', 'rd': 'r18', 'rh': 'r0', 'op2': 'r17'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000100000110010000001000100000

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'muli: r22 = r18, 4' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'muli: r22 = r18, 4'
[DISASSEMBLE] -> Parte do opcode: 'muli', Parte dos operandos: 'r22 = r18, 4'
[DISASSEMBLE] -> Sufixo de suporte encontrado: 'i'. Opcode final é 'mul'
[DISASSEMBLE] -> Opcode final: 'mul', Tipo: 00
[DISASSEMBLE] -> Instrução com atribuição. Destino: 'r22', Origem: 'r18, 4'
[DISASSEMBLE] -> Operandos finais: Rd='r22', Rh='r18', Op2='4'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'i', 'opcode': 'mul', 'type': '00', 'rd': 'r22', 'rh': 'r18', 'op2': '4'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'mul', 'type': '00', 'rd': 'r22', 'rh': 'r18', 'op2': '4'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'mul', 'type': '00', 'rd': 'r22', 'rh': 'r18', 'op2': '4'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000010001010110100100000000100

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'movi: r24 = 34' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'movi: r24 = 34'
[DISASSEMBLE] -> Parte do opcode: 'movi', Parte dos operandos: 'r24 = 34'
[DISASSEMBLE] -> Sufixo de suporte encontrado: 'i'. Opcode final é 'mov'
[DISASSEMBLE] -> Opcode final: 'mov', Tipo: 00
[DISASSEMBLE] -> Instrução 'mov' identificada. Destino: 'r24', Origem: '34'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'i', 'opcode': 'mov', 'type': '00', 'rd': 'r24', 'rh': 'r0', 'op2': '34'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'mov', 'type': '00', 'rd': 'r24', 'rh': 'r0', 'op2': '34'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'mov', 'type': '00', 'rd': 'r24', 'rh': 'r0', 'op2': '34'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000010100011000000000000100010

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'add: r23 = r24, r22' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'add: r23 = r24, r22'
[DISASSEMBLE] -> Parte do opcode: 'add', Parte dos operandos: 'r23 = r24, r22'
[DISASSEMBLE] -> Opcode final: 'add', Tipo: 00
[DISASSEMBLE] -> Instrução com atribuição. Destino: 'r23', Origem: 'r24, r22'
[DISASSEMBLE] -> Operandos finais: Rd='r23', Rh='r24', Op2='r22'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'na', 'opcode': 'add', 'type': '00', 'rd': 'r23', 'rh': 'r24', 'op2': 'r22'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'add', 'type': '00', 'rd': 'r23', 'rh': 'r24', 'op2': 'r22'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'add', 'type': '00', 'rd': 'r23', 'rh': 'r24', 'op2': 'r22'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000000000010111110001011000000

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'mov: r1 = r23' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'mov: r1 = r23'
[DISASSEMBLE] -> Parte do opcode: 'mov', Parte dos operandos: 'r1 = r23'
[DISASSEMBLE] -> Opcode final: 'mov', Tipo: 00
[DISASSEMBLE] -> Instrução 'mov' identificada. Destino: 'r1', Origem: 'r23'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'na', 'opcode': 'mov', 'type': '00', 'rd': 'r1', 'rh': 'r0', 'op2': 'r23'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'mov', 'type': '00', 'rd': 'r1', 'rh': 'r0', 'op2': 'r23'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'mov', 'type': '00', 'rd': 'r1', 'rh': 'r0', 'op2': 'r23'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000000100000001000001011100000

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'out: r1' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'out: r1'
[DISASSEMBLE] -> Parte do opcode: 'out', Parte dos operandos: 'r1'
[DISASSEMBLE] -> Instrução 'out' identificada.
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'na', 'opcode': 'out', 'type': '00', 'rd': 'r0', 'rh': 'r0', 'op2': 'r1'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'out', 'type': '00', 'rd': 'r0', 'rh': 'r0', 'op2': 'r1'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'out', 'type': '00', 'rd': 'r0', 'rh': 'r0', 'op2': 'r1'}
[ENCODE] -> Instrução 'out' detectada.
[INSTRUCTION] -> Codificação concluída. Binário: 00000000101000000000000000100000

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'movi: r26 = 39' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'movi: r26 = 39'
[DISASSEMBLE] -> Parte do opcode: 'movi', Parte dos operandos: 'r26 = 39'
[DISASSEMBLE] -> Sufixo de suporte encontrado: 'i'. Opcode final é 'mov'
[DISASSEMBLE] -> Opcode final: 'mov', Tipo: 00
[DISASSEMBLE] -> Instrução 'mov' identificada. Destino: 'r26', Origem: '39'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'i', 'opcode': 'mov', 'type': '00', 'rd': 'r26', 'rh': 'r0', 'op2': '39'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'mov', 'type': '00', 'rd': 'r26', 'rh': 'r0', 'op2': '39'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'mov', 'type': '00', 'rd': 'r26', 'rh': 'r0', 'op2': '39'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000010100011010000000000100111

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'load: r25 = [r26]' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'load: r25 = [r26]'
[DISASSEMBLE] -> Parte do opcode: 'load', Parte dos operandos: 'r25 = [r26]'
[DISASSEMBLE] -> Opcode final: 'load', Tipo: 01
[DISASSEMBLE] -> Instrução Load/Store com endereçamento por registrador.
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'na', 'opcode': 'load', 'type': '01', 'rd': 'r25', 'rh': 'r0', 'op2': 'r26'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'load', 'type': '01', 'rd': 'r25', 'rh': 'r0', 'op2': 'r26'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'load', 'type': '01', 'rd': 'r25', 'rh': 'r0', 'op2': 'r26'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000100000111001000001101000000

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'addi: r5 = r25, 1' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'addi: r5 = r25, 1'
[DISASSEMBLE] -> Parte do opcode: 'addi', Parte dos operandos: 'r5 = r25, 1'
[DISASSEMBLE] -> Sufixo de suporte encontrado: 'i'. Opcode final é 'add'
[DISASSEMBLE] -> Opcode final: 'add', Tipo: 00
[DISASSEMBLE] -> Instrução com atribuição. Destino: 'r5', Origem: 'r25, 1'
[DISASSEMBLE] -> Operandos finais: Rd='r5', Rh='r25', Op2='1'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'i', 'opcode': 'add', 'type': '00', 'rd': 'r5', 'rh': 'r25', 'op2': '1'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'add', 'type': '00', 'rd': 'r5', 'rh': 'r25', 'op2': '1'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'add', 'type': '00', 'rd': 'r5', 'rh': 'r25', 'op2': '1'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000010000000101110010000000001

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'movi: r4 = 39' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'movi: r4 = 39'
[DISASSEMBLE] -> Parte do opcode: 'movi', Parte dos operandos: 'r4 = 39'
[DISASSEMBLE] -> Sufixo de suporte encontrado: 'i'. Opcode final é 'mov'
[DISASSEMBLE] -> Opcode final: 'mov', Tipo: 00
[DISASSEMBLE] -> Instrução 'mov' identificada. Destino: 'r4', Origem: '39'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'i', 'opcode': 'mov', 'type': '00', 'rd': 'r4', 'rh': 'r0', 'op2': '39'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'mov', 'type': '00', 'rd': 'r4', 'rh': 'r0', 'op2': '39'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'mov', 'type': '00', 'rd': 'r4', 'rh': 'r0', 'op2': '39'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000010100000100000000000100111

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'store: [r4] = r5' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'store: [r4] = r5'
[DISASSEMBLE] -> Parte do opcode: 'store', Parte dos operandos: '[r4] = r5'
[DISASSEMBLE] -> Opcode final: 'store', Tipo: 01
[DISASSEMBLE] -> Instrução Store com endereçamento por registrador. Dest detectado: [r4]. Source detectado: 'r5'
[DISASSEMBLE] -> Instrução Load/Store com endereçamento por registrador.
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'na', 'opcode': 'store', 'type': '01', 'rd': 'r0', 'op2': 'r4', 'rh': 'r5'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'store', 'type': '01', 'rd': 'r0', 'op2': 'r4', 'rh': 'r5'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'store', 'type': '01', 'rd': 'r0', 'op2': 'r4', 'rh': 'r5'}
[ENCODE] -> Instrução Store detectada.
[ENCODE] -> rd_bin, rh_bin calculados: Rd(r0)=:00000 e Rh(r5)=:00101
[ENCODE] -> Op2 é um registrador: r4, convertido para binário: 0010000000
[INSTRUCTION] -> Codificação concluída. Binário: 00000100000000000001010010000000

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'bi: L8' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'bi: L8'
[DISASSEMBLE] -> Parte do opcode: 'bi', Parte dos operandos: 'L8'
[DISASSEMBLE] -> Instrução de branch identificada: 'bi'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'i', 'opcode': 'b', 'type': '11', 'op2': 'L8'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'b', 'type': '11', 'op2': 'L8'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'b', 'type': '11', 'op2': 'L8'}
[ENCODE] -> Instrução de branch detectada: b com condição do
[ENCODE] -> Próximo endereço de instrução: 198
[INSTRUCTION] -> Codificação concluída. Binário: 00001110000011111111111111101110

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'bi: main_epilogue' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'bi: main_epilogue'
[DISASSEMBLE] -> Parte do opcode: 'bi', Parte dos operandos: 'main_epilogue'
[DISASSEMBLE] -> Instrução de branch identificada: 'bi'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'i', 'opcode': 'b', 'type': '11', 'op2': 'main_epilogue'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'b', 'type': '11', 'op2': 'main_epilogue'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'b', 'type': '11', 'op2': 'main_epilogue'}
[ENCODE] -> Instrução de branch detectada: b com condição do
[ENCODE] -> Próximo endereço de instrução: 199
[INSTRUCTION] -> Codificação concluída. Binário: 00001110000000000000000000000000

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'mov: r29 = r31' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'mov: r29 = r31'
[DISASSEMBLE] -> Parte do opcode: 'mov', Parte dos operandos: 'r29 = r31'
[DISASSEMBLE] -> Opcode final: 'mov', Tipo: 00
[DISASSEMBLE] -> Instrução 'mov' identificada. Destino: 'r29', Origem: 'r31'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'na', 'opcode': 'mov', 'type': '00', 'rd': 'r29', 'rh': 'r0', 'op2': 'r31'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'mov', 'type': '00', 'rd': 'r29', 'rh': 'r0', 'op2': 'r31'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'mov', 'type': '00', 'rd': 'r29', 'rh': 'r0', 'op2': 'r31'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000000100011101000001111100000

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'load: r31 = [r29]' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'load: r31 = [r29]'
[DISASSEMBLE] -> Parte do opcode: 'load', Parte dos operandos: 'r31 = [r29]'
[DISASSEMBLE] -> Opcode final: 'load', Tipo: 01
[DISASSEMBLE] -> Instrução Load/Store com endereçamento por registrador.
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'na', 'opcode': 'load', 'type': '01', 'rd': 'r31', 'rh': 'r0', 'op2': 'r29'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'load', 'type': '01', 'rd': 'r31', 'rh': 'r0', 'op2': 'r29'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'load', 'type': '01', 'rd': 'r31', 'rh': 'r0', 'op2': 'r29'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000100000111111000001110100000

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'addi: r29 = r29, 1' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'addi: r29 = r29, 1'
[DISASSEMBLE] -> Parte do opcode: 'addi', Parte dos operandos: 'r29 = r29, 1'
[DISASSEMBLE] -> Sufixo de suporte encontrado: 'i'. Opcode final é 'add'
[DISASSEMBLE] -> Opcode final: 'add', Tipo: 00
[DISASSEMBLE] -> Instrução com atribuição. Destino: 'r29', Origem: 'r29, 1'
[DISASSEMBLE] -> Operandos finais: Rd='r29', Rh='r29', Op2='1'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'i', 'opcode': 'add', 'type': '00', 'rd': 'r29', 'rh': 'r29', 'op2': '1'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'add', 'type': '00', 'rd': 'r29', 'rh': 'r29', 'op2': '1'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'add', 'type': '00', 'rd': 'r29', 'rh': 'r29', 'op2': '1'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000010000011101111010000000001

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'load: r28 = [r29]' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'load: r28 = [r29]'
[DISASSEMBLE] -> Parte do opcode: 'load', Parte dos operandos: 'r28 = [r29]'
[DISASSEMBLE] -> Opcode final: 'load', Tipo: 01
[DISASSEMBLE] -> Instrução Load/Store com endereçamento por registrador.
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'na', 'opcode': 'load', 'type': '01', 'rd': 'r28', 'rh': 'r0', 'op2': 'r29'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'load', 'type': '01', 'rd': 'r28', 'rh': 'r0', 'op2': 'r29'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'load', 'type': '01', 'rd': 'r28', 'rh': 'r0', 'op2': 'r29'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000100000111100000001110100000

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'addi: r29 = r29, 1' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'addi: r29 = r29, 1'
[DISASSEMBLE] -> Parte do opcode: 'addi', Parte dos operandos: 'r29 = r29, 1'
[DISASSEMBLE] -> Sufixo de suporte encontrado: 'i'. Opcode final é 'add'
[DISASSEMBLE] -> Opcode final: 'add', Tipo: 00
[DISASSEMBLE] -> Instrução com atribuição. Destino: 'r29', Origem: 'r29, 1'
[DISASSEMBLE] -> Operandos finais: Rd='r29', Rh='r29', Op2='1'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'i', 'opcode': 'add', 'type': '00', 'rd': 'r29', 'rh': 'r29', 'op2': '1'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'add', 'type': '00', 'rd': 'r29', 'rh': 'r29', 'op2': '1'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'add', 'type': '00', 'rd': 'r29', 'rh': 'r29', 'op2': '1'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000010000011101111010000000001

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'ret:' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'ret:'
[DISASSEMBLE] -> Instrução 'ret' identificada.
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'na', 'opcode': 'ret', 'type': '11'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'ret', 'type': '11'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'ret', 'type': '11'}
[INSTRUCTION] -> Codificação concluída. Binário: 00001100111111111111111111111111

[PASS 2] -> 205 linhas de código de máquina geradas.

[PASS 2] Etapa 3: Adicionando a seção de dados e literais ao código de máquina final...
[PASS 2] -> Dados a serem adicionados (endereço: valor): [(205, '32'), (206, '33'), (207, '34'), (208, '35'), (209, '36'), (210, '37'), (211, '38'), (212, '39'), (213, '40'), (214, '0'), (215, '0'), (216, '0'), (217, '0'), (218, '0'), (219, '0'), (220, '0'), (221, '0'), (222, '0'), (223, '0'), (224, '0'), (225, '0'), (226, '0'), (227, '0'), (228, '0'), (229, '0'), (230, '0'), (231, '0'), (232, '0'), (233, '0'), (234, '0'), (235, '0'), (236, '0'), (237, '0'), (238, '0'), (239, '0'), (240, '0'), (241, '0'), (242, '0'), (243, '0'), (244, '0'), (245, '0'), (246, '0'), (247, '0'), (248, '0'), (249, '0'), (250, '0'), (251, '0'), (252, '0'), (253, '0'), (254, '0'), (255, '0'), (256, '0'), (257, '0'), (258, '0'), (259, '0'), (260, '0'), (261, '0'), (262, '0'), (263, '0'), (264, '0'), (265, '0'), (266, '0'), (267, '0'), (268, '0')]
--- Fim da Segunda Passagem ---
=== PROCESSO DE MONTAGEM CONCLUÍDO ===
--- DEBUG OUTPUT ---
00001110000000000000000010001010 -> cond[0000] type[11] supp[10] op[0000] offset_calc[(139 - 1) = 138]->bin[00000000000010001010]
00000010000111101111010000000001 -> cond[0000] type[00] supp[10] op[0001] Rd[11101] Rh[11101] imm[1=1]->[0000000001]
00000100000000000111001110100000 -> cond[0000] type[01] supp[00] op[0000] Rd[00000] Rh[11100] Ro[11101] pad[00000] (Store sem imediato)
00000010000111101111010000000001 -> cond[0000] type[00] supp[10] op[0001] Rd[11101] Rh[11101] imm[1=1]->[0000000001]
00000100000000000111111110100000 -> cond[0000] type[01] supp[00] op[0000] Rd[00000] Rh[11111] Ro[11101] pad[00000] (Store sem imediato)
00000000100011111000001110100000 -> cond[0000] type[00] supp[00] op[1000] Rd[11111] Rh[00000] Ro[11101] pad[00000] (Mov sem imediato)
00000010100001101000000000100011 -> cond[0000] type[00] supp[10] op[1000] Rd[01101] Rh[00000] imm[35=35]->[0000100011]
00000100000101100000000110100000 -> cond[0000] type[01] supp[00] op[0001] Rd[01100] Rh[00000] Ro[01101] pad[00000] (Load sem imediato)
00000010100001110000000000100110 -> cond[0000] type[00] supp[10] op[1000] Rd[01110] Rh[00000] imm[38=38]->[0000100110]
00000100000000000011000111000000 -> cond[0000] type[01] supp[00] op[0000] Rd[00000] Rh[01100] Ro[01110] pad[00000] (Store sem imediato)
00000010100010000000000000100011 -> cond[0000] type[00] supp[10] op[1000] Rd[10000] Rh[00000] imm[35=35]->[0000100011]
00000100000101111000001000000000 -> cond[0000] type[01] supp[00] op[0001] Rd[01111] Rh[00000] Ro[10000] pad[00000] (Load sem imediato)
00000010001010001011110000000100 -> cond[0000] type[00] supp[10] op[0010] Rd[10001] Rh[01111] imm[4=4]->[0000000100]
00000010100010010000000000100001 -> cond[0000] type[00] supp[10] op[1000] Rd[10010] Rh[00000] imm[33=33]->[0000100001]
00000000000010011100101000100000 -> cond[0000] type[00] supp[00] op[0000] Rd[10011] Rh[10010] Ro[10001] pad[00000]
00000010100010100000000000100100 -> cond[0000] type[00] supp[10] op[1000] Rd[10100] Rh[00000] imm[36=36]->[0000100100]
00000100000000000100111010000000 -> cond[0000] type[01] supp[00] op[0000] Rd[00000] Rh[10011] Ro[10100] pad[00000] (Store sem imediato)
00000010100010110000000000100011 -> cond[0000] type[00] supp[10] op[1000] Rd[10110] Rh[00000] imm[35=35]->[0000100011]
00000100000110101000001011000000 -> cond[0000] type[01] supp[00] op[0001] Rd[10101] Rh[00000] Ro[10110] pad[00000] (Load sem imediato)
00000010000010111101010000000001 -> cond[0000] type[00] supp[10] op[0000] Rd[10111] Rh[10101] imm[1=1]->[0000000001]
00000010100011000000000000100111 -> cond[0000] type[00] supp[10] op[1000] Rd[11000] Rh[00000] imm[39=39]->[0000100111]
00000100000000000101111100000000 -> cond[0000] type[01] supp[00] op[0000] Rd[00000] Rh[10111] Ro[11000] pad[00000] (Store sem imediato)
00000010100011010000000000100111 -> cond[0000] type[00] supp[10] op[1000] Rd[11010] Rh[00000] imm[39=39]->[0000100111]
00000100000111001000001101000000 -> cond[0000] type[01] supp[00] op[0001] Rd[11001] Rh[00000] Ro[11010] pad[00000] (Load sem imediato)
00000010100000101000000000101000 -> cond[0000] type[00] supp[10] op[1000] Rd[00101] Rh[00000] imm[40=40]->[0000101000]
00000100000100100000000010100000 -> cond[0000] type[01] supp[00] op[0001] Rd[00100] Rh[00000] Ro[00101] pad[00000] (Load sem imediato)
00000001000100000110010010000000 -> cond[0000] type[00] supp[01] op[0001] Rd[00000] Rh[11001] Ro[00100] pad[00000]
01001110000000000000000000011011 -> cond[0100] type[11] supp[10] op[0000] offset_calc[(55 - 28) = 27]->bin[00000000000000011011]
00000010100000111000000000100111 -> cond[0000] type[00] supp[10] op[1000] Rd[00111] Rh[00000] imm[39=39]->[0000100111]
00000100000100110000000011100000 -> cond[0000] type[01] supp[00] op[0001] Rd[00110] Rh[00000] Ro[00111] pad[00000] (Load sem imediato)
00000010001001000001100000000100 -> cond[0000] type[00] supp[10] op[0010] Rd[01000] Rh[00110] imm[4=4]->[0000000100]
00000010100001001000000000100001 -> cond[0000] type[00] supp[10] op[1000] Rd[01001] Rh[00000] imm[33=33]->[0000100001]
00000000000001010010010100000000 -> cond[0000] type[00] supp[00] op[0000] Rd[01010] Rh[01001] Ro[01000] pad[00000]
00000010100001101000000000100100 -> cond[0000] type[00] supp[10] op[1000] Rd[01101] Rh[00000] imm[36=36]->[0000100100]
00000100000101011000000110100000 -> cond[0000] type[01] supp[00] op[0001] Rd[01011] Rh[00000] Ro[01101] pad[00000] (Load sem imediato)
00000001000100000010100101100000 -> cond[0000] type[00] supp[01] op[0001] Rd[00000] Rh[01010] Ro[01011] pad[00000]
01001110000000000000000000001100 -> cond[0100] type[11] supp[10] op[0000] offset_calc[(49 - 37) = 12]->bin[00000000000000001100]
00000010100001110000000000100111 -> cond[0000] type[00] supp[10] op[1000] Rd[01110] Rh[00000] imm[39=39]->[0000100111]
00000100000101100000000111000000 -> cond[0000] type[01] supp[00] op[0001] Rd[01100] Rh[00000] Ro[01110] pad[00000] (Load sem imediato)
00000010001010000011000000000100 -> cond[0000] type[00] supp[10] op[0010] Rd[10000] Rh[01100] imm[4=4]->[0000000100]
00000010100001111000000000100001 -> cond[0000] type[00] supp[10] op[1000] Rd[01111] Rh[00000] imm[33=33]->[0000100001]
00000000000010011011111000000000 -> cond[0000] type[00] supp[00] op[0000] Rd[10011] Rh[01111] Ro[10000] pad[00000]
00000010100010100000000000100100 -> cond[0000] type[00] supp[10] op[1000] Rd[10100] Rh[00000] imm[36=36]->[0000100100]
00000100000000000100111010000000 -> cond[0000] type[01] supp[00] op[0000] Rd[00000] Rh[10011] Ro[10100] pad[00000] (Store sem imediato)
00000010100010101000000000100111 -> cond[0000] type[00] supp[10] op[1000] Rd[10101] Rh[00000] imm[39=39]->[0000100111]
00000100000110110000001010100000 -> cond[0000] type[01] supp[00] op[0001] Rd[10110] Rh[00000] Ro[10101] pad[00000] (Load sem imediato)
00000010100010111000000000100110 -> cond[0000] type[00] supp[10] op[1000] Rd[10111] Rh[00000] imm[38=38]->[0000100110]
00000100000000000101101011100000 -> cond[0000] type[01] supp[00] op[0000] Rd[00000] Rh[10110] Ro[10111] pad[00000] (Store sem imediato)
00001110000000000000000000000000 -> cond[0000] type[11] supp[10] op[0000] offset_calc[(49 - 49) = 0]->bin[00000000000000000000]
00000010100011010000000000100111 -> cond[0000] type[00] supp[10] op[1000] Rd[11010] Rh[00000] imm[39=39]->[0000100111]
00000100000111000000001101000000 -> cond[0000] type[01] supp[00] op[0001] Rd[11000] Rh[00000] Ro[11010] pad[00000] (Load sem imediato)
00000010000011001110000000000001 -> cond[0000] type[00] supp[10] op[0000] Rd[11001] Rh[11000] imm[1=1]->[0000000001]
00000010100000101000000000100111 -> cond[0000] type[00] supp[10] op[1000] Rd[00101] Rh[00000] imm[39=39]->[0000100111]
00000100000000000110010010100000 -> cond[0000] type[01] supp[00] op[0000] Rd[00000] Rh[11001] Ro[00101] pad[00000] (Store sem imediato)
00001110000011111111111111011111 -> cond[0000] type[11] supp[10] op[0000] offset_calc[(22 - 55) = -33]->bin[11111111111111011111]
00000010100000111000000000100110 -> cond[0000] type[00] supp[10] op[1000] Rd[00111] Rh[00000] imm[38=38]->[0000100110]
00000100000100100000000011100000 -> cond[0000] type[01] supp[00] op[0001] Rd[00100] Rh[00000] Ro[00111] pad[00000] (Load sem imediato)
00000000100000000000000010000000 -> cond[0000] type[00] supp[00] op[1000] Rd[00000] Rh[00000] Ro[00100] pad[00000] (Mov sem imediato)
00001110000000000000000000000001 -> cond[0000] type[11] supp[10] op[0000] offset_calc[(60 - 59) = 1]->bin[00000000000000000001]
00001110000000000000000000000000 -> cond[0000] type[11] supp[10] op[0000] offset_calc[(60 - 60) = 0]->bin[00000000000000000000]
00000000100011101000001111100000 -> cond[0000] type[00] supp[00] op[1000] Rd[11101] Rh[00000] Ro[11111] pad[00000] (Mov sem imediato)
00000100000111111000001110100000 -> cond[0000] type[01] supp[00] op[0001] Rd[11111] Rh[00000] Ro[11101] pad[00000] (Load sem imediato)
00000010000011101111010000000001 -> cond[0000] type[00] supp[10] op[0000] Rd[11101] Rh[11101] imm[1=1]->[0000000001]
00000100000111100000001110100000 -> cond[0000] type[01] supp[00] op[0001] Rd[11100] Rh[00000] Ro[11101] pad[00000] (Load sem imediato)
00000010000011101111010000000001 -> cond[0000] type[00] supp[10] op[0000] Rd[11101] Rh[11101] imm[1=1]->[0000000001]
00001100000000000000000000011100 -> cond[0000] type[11] supp[00] op[0000] offset_calc[(imm - 66) = 28]->bin[00000000000000011100]
00000010000111101111010000000001 -> cond[0000] type[00] supp[10] op[0001] Rd[11101] Rh[11101] imm[1=1]->[0000000001]
00000100000000000111001110100000 -> cond[0000] type[01] supp[00] op[0000] Rd[00000] Rh[11100] Ro[11101] pad[00000] (Store sem imediato)
00000010000111101111010000000001 -> cond[0000] type[00] supp[10] op[0001] Rd[11101] Rh[11101] imm[1=1]->[0000000001]
00000100000000000111111110100000 -> cond[0000] type[01] supp[00] op[0000] Rd[00000] Rh[11111] Ro[11101] pad[00000] (Store sem imediato)
00000000100011111000001110100000 -> cond[0000] type[00] supp[00] op[1000] Rd[11111] Rh[00000] Ro[11101] pad[00000] (Mov sem imediato)
00000010100001101000000000100011 -> cond[0000] type[00] supp[10] op[1000] Rd[01101] Rh[00000] imm[35=35]->[0000100011]
00000100000101100000000110100000 -> cond[0000] type[01] supp[00] op[0001] Rd[01100] Rh[00000] Ro[01101] pad[00000] (Load sem imediato)
00000010100001110000000000100111 -> cond[0000] type[00] supp[10] op[1000] Rd[01110] Rh[00000] imm[39=39]->[0000100111]
00000100000000000011000111000000 -> cond[0000] type[01] supp[00] op[0000] Rd[00000] Rh[01100] Ro[01110] pad[00000] (Store sem imediato)
00000010100010000000000000100111 -> cond[0000] type[00] supp[10] op[1000] Rd[10000] Rh[00000] imm[39=39]->[0000100111]
00000100000101111000001000000000 -> cond[0000] type[01] supp[00] op[0001] Rd[01111] Rh[00000] Ro[10000] pad[00000] (Load sem imediato)
00000010100010010000000000101000 -> cond[0000] type[00] supp[10] op[1000] Rd[10010] Rh[00000] imm[40=40]->[0000101000]
00000100000110001000001001000000 -> cond[0000] type[01] supp[00] op[0001] Rd[10001] Rh[00000] Ro[10010] pad[00000] (Load sem imediato)
00000010000110011100010000000001 -> cond[0000] type[00] supp[10] op[0001] Rd[10011] Rh[10001] imm[1=1]->[0000000001]
00000001000100000011111001100000 -> cond[0000] type[00] supp[01] op[0001] Rd[00000] Rh[01111] Ro[10011] pad[00000]
01001110000000000000000000110010 -> cond[0100] type[11] supp[10] op[0000] offset_calc[(132 - 82) = 50]->bin[00000000000000110010]
00000010100010101000000000100001 -> cond[0000] type[00] supp[10] op[1000] Rd[10101] Rh[00000] imm[33=33]->[0000100001]
00000100000110100000001010100000 -> cond[0000] type[01] supp[00] op[0001] Rd[10100] Rh[00000] Ro[10101] pad[00000] (Load sem imediato)
00000000100000001000001010000000 -> cond[0000] type[00] supp[00] op[1000] Rd[00001] Rh[00000] Ro[10100] pad[00000] (Mov sem imediato)
00000010100010111000000000100111 -> cond[0000] type[00] supp[10] op[1000] Rd[10111] Rh[00000] imm[39=39]->[0000100111]
00000100000110110000001011100000 -> cond[0000] type[01] supp[00] op[0001] Rd[10110] Rh[00000] Ro[10111] pad[00000] (Load sem imediato)
00000000100000010000001011000000 -> cond[0000] type[00] supp[00] op[1000] Rd[00010] Rh[00000] Ro[10110] pad[00000] (Mov sem imediato)
00000010100011001000000000101000 -> cond[0000] type[00] supp[10] op[1000] Rd[11001] Rh[00000] imm[40=40]->[0000101000]
00000100000111000000001100100000 -> cond[0000] type[01] supp[00] op[0001] Rd[11000] Rh[00000] Ro[11001] pad[00000] (Load sem imediato)
00000000100000011000001100000000 -> cond[0000] type[00] supp[00] op[1000] Rd[00011] Rh[00000] Ro[11000] pad[00000] (Mov sem imediato)
00000010100000100000000000100011 -> cond[0000] type[00] supp[10] op[1000] Rd[00100] Rh[00000] imm[35=35]->[0000100011]
00000100000000000000010010000000 -> cond[0000] type[01] supp[00] op[0000] Rd[00000] Rh[00001] Ro[00100] pad[00000] (Store sem imediato)
00000010100000101000000000100001 -> cond[0000] type[00] supp[10] op[1000] Rd[00101] Rh[00000] imm[33=33]->[0000100001]
00000100000000000000100010100000 -> cond[0000] type[01] supp[00] op[0000] Rd[00000] Rh[00010] Ro[00101] pad[00000] (Store sem imediato)
00000010100000110000000000101000 -> cond[0000] type[00] supp[10] op[1000] Rd[00110] Rh[00000] imm[40=40]->[0000101000]
00000100000000000000110011000000 -> cond[0000] type[01] supp[00] op[0000] Rd[00000] Rh[00011] Ro[00110] pad[00000] (Store sem imediato)
00000010100011010000000001100100 -> cond[0000] type[00] supp[10] op[1000] Rd[11010] Rh[00000] imm[sort_Lret0=100]->[0001100100]
00000000100011100000001101000000 -> cond[0000] type[00] supp[00] op[1000] Rd[11100] Rh[00000] Ro[11010] pad[00000] (Mov sem imediato)
00001100100011111111111110011101 -> cond[0000] type[11] supp[00] op[1000] offset_calc[(1 - 100) = -99]->bin[11111111111110011101]
00000000100000111000000000000000 -> cond[0000] type[00] supp[00] op[1000] Rd[00111] Rh[00000] Ro[00000] pad[00000] (Mov sem imediato)
00000010100001000000000000100110 -> cond[0000] type[00] supp[10] op[1000] Rd[01000] Rh[00000] imm[38=38]->[0000100110]
00000100000000000001110100000000 -> cond[0000] type[01] supp[00] op[0000] Rd[00000] Rh[00111] Ro[01000] pad[00000] (Store sem imediato)
00000010100001010000000000100110 -> cond[0000] type[00] supp[10] op[1000] Rd[01010] Rh[00000] imm[38=38]->[0000100110]
00000100000101001000000101000000 -> cond[0000] type[01] supp[00] op[0001] Rd[01001] Rh[00000] Ro[01010] pad[00000] (Load sem imediato)
00000010001001011010010000000100 -> cond[0000] type[00] supp[10] op[0010] Rd[01011] Rh[01001] imm[4=4]->[0000000100]
00000010100001101000000000100001 -> cond[0000] type[00] supp[10] op[1000] Rd[01101] Rh[00000] imm[33=33]->[0000100001]
00000000000001100011010101100000 -> cond[0000] type[00] supp[00] op[0000] Rd[01100] Rh[01101] Ro[01011] pad[00000]
00000100000000000011000111000000 -> cond[0000] type[01] supp[00] op[0000] Rd[00000] Rh[01100] Ro[01110] pad[00000] (Store sem imediato)
00000010100001111000000000100111 -> cond[0000] type[00] supp[10] op[1000] Rd[01111] Rh[00000] imm[39=39]->[0000100111]
00000100000110000000000111100000 -> cond[0000] type[01] supp[00] op[0001] Rd[10000] Rh[00000] Ro[01111] pad[00000] (Load sem imediato)
00000010001010010100000000000100 -> cond[0000] type[00] supp[10] op[0010] Rd[10010] Rh[10000] imm[4=4]->[0000000100]
00000010100010001000000000100001 -> cond[0000] type[00] supp[10] op[1000] Rd[10001] Rh[00000] imm[33=33]->[0000100001]
00000000000010101100011001000000 -> cond[0000] type[00] supp[00] op[0000] Rd[10101] Rh[10001] Ro[10010] pad[00000]
00000010100010111000000000100110 -> cond[0000] type[00] supp[10] op[1000] Rd[10111] Rh[00000] imm[38=38]->[0000100110]
00000100000110100000001011100000 -> cond[0000] type[01] supp[00] op[0001] Rd[10100] Rh[00000] Ro[10111] pad[00000] (Load sem imediato)
00000010001010110101000000000100 -> cond[0000] type[00] supp[10] op[0010] Rd[10110] Rh[10100] imm[4=4]->[0000000100]
00000010100011001000000000100001 -> cond[0000] type[00] supp[10] op[1000] Rd[11001] Rh[00000] imm[33=33]->[0000100001]
00000000000011000110011011000000 -> cond[0000] type[00] supp[00] op[0000] Rd[11000] Rh[11001] Ro[10110] pad[00000]
00000100000000000101011100000000 -> cond[0000] type[01] supp[00] op[0000] Rd[00000] Rh[10101] Ro[11000] pad[00000] (Store sem imediato)
00000010100000110000000000100111 -> cond[0000] type[00] supp[10] op[1000] Rd[00110] Rh[00000] imm[39=39]->[0000100111]
00000100000100101000000011000000 -> cond[0000] type[01] supp[00] op[0001] Rd[00101] Rh[00000] Ro[00110] pad[00000] (Load sem imediato)
00000010001011010001010000000100 -> cond[0000] type[00] supp[10] op[0010] Rd[11010] Rh[00101] imm[4=4]->[0000000100]
00000010100000111000000000100001 -> cond[0000] type[00] supp[10] op[1000] Rd[00111] Rh[00000] imm[33=33]->[0000100001]
00000000000001000001111101000000 -> cond[0000] type[00] supp[00] op[0000] Rd[01000] Rh[00111] Ro[11010] pad[00000]
00000100000000000001000100000000 -> cond[0000] type[01] supp[00] op[0000] Rd[00000] Rh[00100] Ro[01000] pad[00000] (Store sem imediato)
00000010100001001000000000100111 -> cond[0000] type[00] supp[10] op[1000] Rd[01001] Rh[00000] imm[39=39]->[0000100111]
00000100000101010000000100100000 -> cond[0000] type[01] supp[00] op[0001] Rd[01010] Rh[00000] Ro[01001] pad[00000] (Load sem imediato)
00000010000001100010100000000001 -> cond[0000] type[00] supp[10] op[0000] Rd[01100] Rh[01010] imm[1=1]->[0000000001]
00000010100001110000000000100111 -> cond[0000] type[00] supp[10] op[1000] Rd[01110] Rh[00000] imm[39=39]->[0000100111]
00000100000000000011000111000000 -> cond[0000] type[01] supp[00] op[0000] Rd[00000] Rh[01100] Ro[01110] pad[00000] (Store sem imediato)
00001110000011111111111111000111 -> cond[0000] type[11] supp[10] op[0000] offset_calc[(75 - 132) = -57]->bin[11111111111111000111]
00001110000000000000000000000000 -> cond[0000] type[11] supp[10] op[0000] offset_calc[(133 - 133) = 0]->bin[00000000000000000000]
00000000100011101000001111100000 -> cond[0000] type[00] supp[00] op[1000] Rd[11101] Rh[00000] Ro[11111] pad[00000] (Mov sem imediato)
00000100000111111000001110100000 -> cond[0000] type[01] supp[00] op[0001] Rd[11111] Rh[00000] Ro[11101] pad[00000] (Load sem imediato)
00000010000011101111010000000001 -> cond[0000] type[00] supp[10] op[0000] Rd[11101] Rh[11101] imm[1=1]->[0000000001]
00000100000111100000001110100000 -> cond[0000] type[01] supp[00] op[0001] Rd[11100] Rh[00000] Ro[11101] pad[00000] (Load sem imediato)
00000010000011101111010000000001 -> cond[0000] type[00] supp[10] op[0000] Rd[11101] Rh[11101] imm[1=1]->[0000000001]
00001100000000000000000000011100 -> cond[0000] type[11] supp[00] op[0000] offset_calc[(imm - 139) = 28]->bin[00000000000000011100]
00000010100011101000000011001101 -> cond[0000] type[00] supp[10] op[1000] Rd[11101] Rh[00000] imm[stack_space=205]->[0011001101]
00000000100011111000001110100000 -> cond[0000] type[00] supp[00] op[1000] Rd[11111] Rh[00000] Ro[11101] pad[00000] (Mov sem imediato)
00000010100001100000000000000000 -> cond[0000] type[00] supp[10] op[1000] Rd[01100] Rh[00000] imm[0=0]->[0000000000]
00000010100001101000000000100111 -> cond[0000] type[00] supp[10] op[1000] Rd[01101] Rh[00000] imm[39=39]->[0000100111]
00000100000000000011000110100000 -> cond[0000] type[01] supp[00] op[0000] Rd[00000] Rh[01100] Ro[01101] pad[00000] (Store sem imediato)
00000010100001111000000000100111 -> cond[0000] type[00] supp[10] op[1000] Rd[01111] Rh[00000] imm[39=39]->[0000100111]
00000100000101110000000111100000 -> cond[0000] type[01] supp[00] op[0001] Rd[01110] Rh[00000] Ro[01111] pad[00000] (Load sem imediato)
00000010100010000000000000001010 -> cond[0000] type[00] supp[10] op[1000] Rd[10000] Rh[00000] imm[10=10]->[0000001010]
00000001000100000011101000000000 -> cond[0000] type[00] supp[01] op[0001] Rd[00000] Rh[01110] Ro[10000] pad[00000]
01001110000000000000000000001101 -> cond[0100] type[11] supp[10] op[0000] offset_calc[(162 - 149) = 13]->bin[00000000000000001101]
00000000100110001000000000000000 -> cond[0000] type[00] supp[00] op[1001] Rd[10001] Rh[00000] Ro[00000] pad[00000]
00000010100010011000000000100111 -> cond[0000] type[00] supp[10] op[1000] Rd[10011] Rh[00000] imm[39=39]->[0000100111]
00000100000110010000001001100000 -> cond[0000] type[01] supp[00] op[0001] Rd[10010] Rh[00000] Ro[10011] pad[00000] (Load sem imediato)
00000010001010100100100000000100 -> cond[0000] type[00] supp[10] op[0010] Rd[10100] Rh[10010] imm[4=4]->[0000000100]
00000010100010101000000000100010 -> cond[0000] type[00] supp[10] op[1000] Rd[10101] Rh[00000] imm[34=34]->[0000100010]
00000000000010110101011010000000 -> cond[0000] type[00] supp[00] op[0000] Rd[10110] Rh[10101] Ro[10100] pad[00000]
00000100000000000100011011000000 -> cond[0000] type[01] supp[00] op[0000] Rd[00000] Rh[10001] Ro[10110] pad[00000] (Store sem imediato)
00000010100011000000000000100111 -> cond[0000] type[00] supp[10] op[1000] Rd[11000] Rh[00000] imm[39=39]->[0000100111]
00000100000110111000001100000000 -> cond[0000] type[01] supp[00] op[0001] Rd[10111] Rh[00000] Ro[11000] pad[00000] (Load sem imediato)
00000010000011001101110000000001 -> cond[0000] type[00] supp[10] op[0000] Rd[11001] Rh[10111] imm[1=1]->[0000000001]
00000010100011010000000000100111 -> cond[0000] type[00] supp[10] op[1000] Rd[11010] Rh[00000] imm[39=39]->[0000100111]
00000100000000000110011101000000 -> cond[0000] type[01] supp[00] op[0000] Rd[00000] Rh[11001] Ro[11010] pad[00000] (Store sem imediato)
00001110000011111111111111101110 -> cond[0000] type[11] supp[10] op[0000] offset_calc[(144 - 162) = -18]->bin[11111111111111101110]
00000010100000101000000000100010 -> cond[0000] type[00] supp[10] op[1000] Rd[00101] Rh[00000] imm[34=34]->[0000100010]
00000100000100100000000010100000 -> cond[0000] type[01] supp[00] op[0001] Rd[00100] Rh[00000] Ro[00101] pad[00000] (Load sem imediato)
00000000100000001000000010000000 -> cond[0000] type[00] supp[00] op[1000] Rd[00001] Rh[00000] Ro[00100] pad[00000] (Mov sem imediato)
00000010100000110000000000000000 -> cond[0000] type[00] supp[10] op[1000] Rd[00110] Rh[00000] imm[0=0]->[0000000000]
00000000100000010000000011000000 -> cond[0000] type[00] supp[00] op[1000] Rd[00010] Rh[00000] Ro[00110] pad[00000] (Mov sem imediato)
00000010100000111000000000001010 -> cond[0000] type[00] supp[10] op[1000] Rd[00111] Rh[00000] imm[10=10]->[0000001010]
00000000100000011000000011100000 -> cond[0000] type[00] supp[00] op[1000] Rd[00011] Rh[00000] Ro[00111] pad[00000] (Mov sem imediato)
00000010100001000000000000100011 -> cond[0000] type[00] supp[10] op[1000] Rd[01000] Rh[00000] imm[35=35]->[0000100011]
00000100000000000000010100000000 -> cond[0000] type[01] supp[00] op[0000] Rd[00000] Rh[00001] Ro[01000] pad[00000] (Store sem imediato)
00000010100001001000000000101000 -> cond[0000] type[00] supp[10] op[1000] Rd[01001] Rh[00000] imm[40=40]->[0000101000]
00000100000000000000100100100000 -> cond[0000] type[01] supp[00] op[0000] Rd[00000] Rh[00010] Ro[01001] pad[00000] (Store sem imediato)
00000010100001010000000000100001 -> cond[0000] type[00] supp[10] op[1000] Rd[01010] Rh[00000] imm[33=33]->[0000100001]
00000100000000000000110101000000 -> cond[0000] type[01] supp[00] op[0000] Rd[00000] Rh[00011] Ro[01010] pad[00000] (Store sem imediato)
00000010100011100000000010110001 -> cond[0000] type[00] supp[10] op[1000] Rd[11100] Rh[00000] imm[main_Lret0=177]->[0010110001]
00001100100011111111111110010001 -> cond[0000] type[11] supp[00] op[1000] offset_calc[(66 - 177) = -111]->bin[11111111111110010001]
00000010100001011000000000000000 -> cond[0000] type[00] supp[10] op[1000] Rd[01011] Rh[00000] imm[0=0]->[0000000000]
00000010100001101000000000100111 -> cond[0000] type[00] supp[10] op[1000] Rd[01101] Rh[00000] imm[39=39]->[0000100111]
00000100000000000010110110100000 -> cond[0000] type[01] supp[00] op[0000] Rd[00000] Rh[01011] Ro[01101] pad[00000] (Store sem imediato)
00000010100001110000000000100111 -> cond[0000] type[00] supp[10] op[1000] Rd[01110] Rh[00000] imm[39=39]->[0000100111]
00000100000101111000000111000000 -> cond[0000] type[01] supp[00] op[0001] Rd[01111] Rh[00000] Ro[01110] pad[00000] (Load sem imediato)
00000010100010011000000000001010 -> cond[0000] type[00] supp[10] op[1000] Rd[10011] Rh[00000] imm[10=10]->[0000001010]
00000001000100000011111001100000 -> cond[0000] type[00] supp[01] op[0001] Rd[00000] Rh[01111] Ro[10011] pad[00000]
01001110000000000000000000001101 -> cond[0100] type[11] supp[10] op[0000] offset_calc[(198 - 185) = 13]->bin[00000000000000001101]
00000010100010001000000000100111 -> cond[0000] type[00] supp[10] op[1000] Rd[10001] Rh[00000] imm[39=39]->[0000100111]
00000100000110010000001000100000 -> cond[0000] type[01] supp[00] op[0001] Rd[10010] Rh[00000] Ro[10001] pad[00000] (Load sem imediato)
00000010001010110100100000000100 -> cond[0000] type[00] supp[10] op[0010] Rd[10110] Rh[10010] imm[4=4]->[0000000100]
00000010100011000000000000100010 -> cond[0000] type[00] supp[10] op[1000] Rd[11000] Rh[00000] imm[34=34]->[0000100010]
00000000000010111110001011000000 -> cond[0000] type[00] supp[00] op[0000] Rd[10111] Rh[11000] Ro[10110] pad[00000]
00000000100000001000001011100000 -> cond[0000] type[00] supp[00] op[1000] Rd[00001] Rh[00000] Ro[10111] pad[00000] (Mov sem imediato)
00000000101000000000000000100000 -> cond[0000] type[00] supp[00] op[1010] Rd[00000] Rh[00000] Ro[00001] pad[00000] (Out sem imediato)
00000010100011010000000000100111 -> cond[0000] type[00] supp[10] op[1000] Rd[11010] Rh[00000] imm[39=39]->[0000100111]
00000100000111001000001101000000 -> cond[0000] type[01] supp[00] op[0001] Rd[11001] Rh[00000] Ro[11010] pad[00000] (Load sem imediato)
00000010000000101110010000000001 -> cond[0000] type[00] supp[10] op[0000] Rd[00101] Rh[11001] imm[1=1]->[0000000001]
00000010100000100000000000100111 -> cond[0000] type[00] supp[10] op[1000] Rd[00100] Rh[00000] imm[39=39]->[0000100111]
00000100000000000001010010000000 -> cond[0000] type[01] supp[00] op[0000] Rd[00000] Rh[00101] Ro[00100] pad[00000] (Store sem imediato)
00001110000011111111111111101110 -> cond[0000] type[11] supp[10] op[0000] offset_calc[(180 - 198) = -18]->bin[11111111111111101110]
00001110000000000000000000000000 -> cond[0000] type[11] supp[10] op[0000] offset_calc[(199 - 199) = 0]->bin[00000000000000000000]
00000000100011101000001111100000 -> cond[0000] type[00] supp[00] op[1000] Rd[11101] Rh[00000] Ro[11111] pad[00000] (Mov sem imediato)
00000100000111111000001110100000 -> cond[0000] type[01] supp[00] op[0001] Rd[11111] Rh[00000] Ro[11101] pad[00000] (Load sem imediato)
00000010000011101111010000000001 -> cond[0000] type[00] supp[10] op[0000] Rd[11101] Rh[11101] imm[1=1]->[0000000001]
00000100000111100000001110100000 -> cond[0000] type[01] supp[00] op[0001] Rd[11100] Rh[00000] Ro[11101] pad[00000] (Load sem imediato)
00000010000011101111010000000001 -> cond[0000] type[00] supp[10] op[0000] Rd[11101] Rh[11101] imm[1=1]->[0000000001]
00001100111111111111111111111111 -> cond[0000] type[11] supp[00] op[1111] operand[-1]

Código de máquina gerado com sucesso em: docs/output/generated_machine_code.txt

--- Iniciando a Decodificação do Código de Máquina ---
--- Decodificação Concluída ---
--- MACHINE CODE DECODED ---
