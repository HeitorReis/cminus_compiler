

=== INICIANDO GERAÇÃO DE ASSEMBLY ===

--- Passagem 1A: Coletando definições de funções ---
[Passagem 1A] Função encontrada: 'minloc'
[ALLOC_INIT] Inicializando alocador para a função 'minloc'
[ALLOC_INIT] Pool de registradores definido: ['r4', 'r5', 'r6', 'r7', 'r8', 'r9', 'r10', 'r11', 'r12', 'r13', 'r14', 'r15', 'r16', 'r17', 'r18', 'r19', 'r20', 'r21', 'r22', 'r23', 'r24', 'r25', 'r26']
[ALLOC_INIT] Registrador de spill reservado: r30
[ALLOC_INIT] Estado inicial: 23 registradores livres.
[FUNC_CTX] Contexto para a função 'minloc' criado.
[Passagem 1A] Função encontrada: 'sort'
[ALLOC_INIT] Inicializando alocador para a função 'sort'
[ALLOC_INIT] Pool de registradores definido: ['r4', 'r5', 'r6', 'r7', 'r8', 'r9', 'r10', 'r11', 'r12', 'r13', 'r14', 'r15', 'r16', 'r17', 'r18', 'r19', 'r20', 'r21', 'r22', 'r23', 'r24', 'r25', 'r26']
[ALLOC_INIT] Registrador de spill reservado: r30
[ALLOC_INIT] Estado inicial: 23 registradores livres.
[FUNC_CTX] Contexto para a função 'sort' criado.
[Passagem 1A] Função encontrada: 'main'
[ALLOC_INIT] Inicializando alocador para a função 'main'
[ALLOC_INIT] Pool de registradores definido: ['r4', 'r5', 'r6', 'r7', 'r8', 'r9', 'r10', 'r11', 'r12', 'r13', 'r14', 'r15', 'r16', 'r17', 'r18', 'r19', 'r20', 'r21', 'r22', 'r23', 'r24', 'r25', 'r26']
[ALLOC_INIT] Registrador de spill reservado: r30
[ALLOC_INIT] Estado inicial: 23 registradores livres.
[FUNC_CTX] Contexto para a função 'main' criado.

--- Passagem 1B: Construindo a Tabela de Símbolos Globais ---
[Passagem 1B] Declaração de Vetor Global encontrada: 'vet' de tamanho 2
[SymbolTable] Adding symbol: <Symbol(name='vet', type=ARRAY(size=2, base_type=INT), scope='global', addr=128)>
--- Fim da Passagem 1: 1 símbolos globais encontrados. ---

--- Passagem 2: Traduzindo o IR para cada função ---

[Processando Função] -> 'minloc'
-> IR isolado para 'minloc' contém 25 instruções.
[DEBUG] Função 'minloc': all_vars={'high', 'a', 'low', 'k', 'i', 'x'}, defined_vars={'i', 'k', 'x'}, params=['high', 'a', 'low']
--> Parâmetros para 'minloc': ['high', 'a', 'low']
--> Variáveis Locais para 'minloc': ['i', 'k', 'x']
--> Criando o layout da pilha para 'minloc'...
    -> Mapeando 'high' para o offset [fp, #-1] (size=1)
    -> Mapeando 'a' para o offset [fp, #-2] (size=1)
    -> Mapeando 'low' para o offset [fp, #-3] (size=1)
    -> Mapeando 'i' para o offset [fp, #-4] (size=1)
    -> Mapeando 'k' para o offset [fp, #-5] (size=1)
    -> Mapeando 'x' para o offset [fp, #-6] (size=1)
--> Tamanho total do frame para 'minloc': 16 palavras.
[ADD_INSTR] Adicionando instrução para 'minloc': subi: r30 = r31, 1
[ADD_INSTR] Adicionando instrução para 'minloc': store: [r30] = r1
[ADD_INSTR] Adicionando instrução para 'minloc': subi: r30 = r31, 2
[ADD_INSTR] Adicionando instrução para 'minloc': store: [r30] = r2
[ADD_INSTR] Adicionando instrução para 'minloc': subi: r30 = r31, 3
[ADD_INSTR] Adicionando instrução para 'minloc': store: [r30] = r3

--- [TRANSLATE] Processando IR: k := low ---
[TRANSLATE] -> Detalhes: Destino='k', Expressão='low'
[TRANSLATE] -> Caminho: Atribuição Simples
[ENSURE] Tentando garantir 'low' em um registrador.
[ENSURE] -> 'low' é uma variável da pilha. Carregando...
[GET_FREE] -> Encontrado registrador livre: r4. Restantes: 22.
[ADD_INSTR] Adicionando instrução para 'minloc': subi: r30 = r31, 3
[ADD_INSTR] Adicionando instrução para 'minloc': load: r4 = [r30]
[ASSIGN_REG] Mapeando 'low' para r4.
[TRANSLATE_ASSIGN] -> Armazenando 'k' na sua posição da pilha.
[ADD_INSTR] Adicionando instrução para 'minloc': subi: r30 = r31, 5
[ADD_INSTR] Adicionando instrução para 'minloc': store: [r30] = r4
[UPDATE_MAP] Mapeando 'k' para o registrador r4 (que contém o valor de origem).
[ASSIGN_REG] Mapeando 'k' para r4.
[ASSIGN_REG] -> Registrador r4 já continha 'low'. Liberando o mapeamento antigo.
[UNASSIGN_REG] Desmapeado r4 de 'low'.
[UNASSIGN_REG] -> Estado atual: 23 registradores livres. Mapeamentos: {}

--- [TRANSLATE] Processando IR: t0 := a + low ---
[TRANSLATE] -> Detalhes: Destino='t0', Expressão='a + low'
[TRANSLATE] -> Caminho: Operação Aritmética
[ENSURE] Tentando garantir 'a' em um registrador.
[ENSURE] -> 'a' é uma variável da pilha. Carregando...
[GET_FREE] -> Encontrado registrador livre: r5. Restantes: 22.
[ADD_INSTR] Adicionando instrução para 'minloc': subi: r30 = r31, 2
[ADD_INSTR] Adicionando instrução para 'minloc': load: r5 = [r30]
[ASSIGN_REG] Mapeando 'a' para r5.
[ENSURE] Tentando garantir 'low' em um registrador.
[ENSURE] -> 'low' é uma variável da pilha. Carregando...
[GET_FREE] -> Encontrado registrador livre: r6. Restantes: 21.
[ADD_INSTR] Adicionando instrução para 'minloc': subi: r30 = r31, 3
[ADD_INSTR] Adicionando instrução para 'minloc': load: r6 = [r30]
[ASSIGN_REG] Mapeando 'low' para r6.
[GET_TEMP] Solicitando registrador para o temporário 't0'.
[GET_FREE] -> Encontrado registrador livre: r7. Restantes: 20.
[ASSIGN_REG] Mapeando 't0' para r7.
[GET_TEMP] -> 't0' alocado no registrador r7.
[ADD_INSTR] Adicionando instrução para 'minloc': add: r7 = r5, r6

--- [TRANSLATE] Processando IR: t1 := *t0 ---
[TRANSLATE] -> Detalhes: Destino='t1', Expressão='*t0'
[TRANSLATE] -> Caminho: Carregar de Ponteiro (*)
[TRANSLATE] -> Ponteiro é uma temporária ('t0'). Usando seu valor como endereço.
[ENSURE] Tentando garantir 't0' em um registrador.
[ENSURE] -> Sucesso! 't0' já está em r7.
[GET_TEMP] Solicitando registrador para o temporário 't1'.
[GET_FREE] -> Encontrado registrador livre: r8. Restantes: 19.
[ASSIGN_REG] Mapeando 't1' para r8.
[GET_TEMP] -> 't1' alocado no registrador r8.
[ADD_INSTR] Adicionando instrução para 'minloc': load: r8 = [r7]
[FREE_TEMP] Liberando registrador r7 que continha o temporário 't0'.
[UNASSIGN_REG] Desmapeado r7 de 't0'.
[UNASSIGN_REG] -> Estado atual: 20 registradores livres. Mapeamentos: {'k': 'r4', 'a': 'r5', 'low': 'r6', 't1': 'r8'}

--- [TRANSLATE] Processando IR: x := t1 ---
[TRANSLATE] -> Detalhes: Destino='x', Expressão='t1'
[TRANSLATE] -> Caminho: Atribuição Simples
[ENSURE] Tentando garantir 't1' em um registrador.
[ENSURE] -> Sucesso! 't1' já está em r8.
[TRANSLATE_ASSIGN] -> Armazenando 'x' na sua posição da pilha.
[ADD_INSTR] Adicionando instrução para 'minloc': subi: r30 = r31, 6
[ADD_INSTR] Adicionando instrução para 'minloc': store: [r30] = r8
[UPDATE_MAP] Mapeando 'x' para o registrador r8 (que contém o valor de origem).
[ASSIGN_REG] Mapeando 'x' para r8.
[ASSIGN_REG] -> Registrador r8 já continha 't1'. Liberando o mapeamento antigo.
[UNASSIGN_REG] Desmapeado r8 de 't1'.
[UNASSIGN_REG] -> Estado atual: 21 registradores livres. Mapeamentos: {'k': 'r4', 'a': 'r5', 'low': 'r6'}

--- [TRANSLATE] Processando IR: t2 := low + 1 ---
[TRANSLATE] -> Detalhes: Destino='t2', Expressão='low + 1'
[TRANSLATE] -> Caminho: Operação Aritmética
[ENSURE] Tentando garantir 'low' em um registrador.
[ENSURE] -> Sucesso! 'low' já está em r6.
[TRANSLATE] -> Operando 2 é um imediato: 1
[GET_TEMP] Solicitando registrador para o temporário 't2'.
[GET_FREE] -> Encontrado registrador livre: r9. Restantes: 20.
[ASSIGN_REG] Mapeando 't2' para r9.
[GET_TEMP] -> 't2' alocado no registrador r9.
[ADD_INSTR] Adicionando instrução para 'minloc': addi: r9 = r6, 1

--- [TRANSLATE] Processando IR: i := t2 ---
[TRANSLATE] -> Detalhes: Destino='i', Expressão='t2'
[TRANSLATE] -> Caminho: Atribuição Simples
[ENSURE] Tentando garantir 't2' em um registrador.
[ENSURE] -> Sucesso! 't2' já está em r9.
[TRANSLATE_ASSIGN] -> Armazenando 'i' na sua posição da pilha.
[ADD_INSTR] Adicionando instrução para 'minloc': subi: r30 = r31, 4
[ADD_INSTR] Adicionando instrução para 'minloc': store: [r30] = r9
[UPDATE_MAP] Mapeando 'i' para o registrador r9 (que contém o valor de origem).
[ASSIGN_REG] Mapeando 'i' para r9.
[ASSIGN_REG] -> Registrador r9 já continha 't2'. Liberando o mapeamento antigo.
[UNASSIGN_REG] Desmapeado r9 de 't2'.
[UNASSIGN_REG] -> Estado atual: 21 registradores livres. Mapeamentos: {'k': 'r4', 'a': 'r5', 'low': 'r6', 'x': 'r8'}

--- [TRANSLATE] Processando IR: L0: ---
[TRANSLATE] -> Rótulo detectado: L0:
[SPILL_ALL] Verificando registradores sujos para salvar. Sujos: {'r7', 'r9', 'r8'}
[SPILL_ALL] -> Salvando variável local 'i' do registrador r9 na pilha [fp, #-4].
[ADD_INSTR] Adicionando instrução para 'minloc': subi: r30 = r31, 4
[ADD_INSTR] Adicionando instrução para 'minloc': store: [r30] = r9
[SPILL_ALL] -> Salvando variável local 'x' do registrador r8 na pilha [fp, #-6].
[ADD_INSTR] Adicionando instrução para 'minloc': subi: r30 = r31, 6
[ADD_INSTR] Adicionando instrução para 'minloc': store: [r30] = r8
[ADD_INSTR] Adicionando instrução para 'minloc': L0:

--- [TRANSLATE] Processando IR: t3 := i < high ---
[TRANSLATE] -> Detalhes: Destino='t3', Expressão='i < high'
[TRANSLATE] -> Caminho: Comparação (condicional)
[ENSURE] Tentando garantir 'i' em um registrador.
[ENSURE] -> Sucesso! 'i' já está em r9.
[ENSURE] Tentando garantir 'high' em um registrador.
[ENSURE] -> 'high' é uma variável da pilha. Carregando...
[GET_FREE] -> Encontrado registrador livre: r10. Restantes: 20.
[ADD_INSTR] Adicionando instrução para 'minloc': subi: r30 = r31, 1
[ADD_INSTR] Adicionando instrução para 'minloc': load: r10 = [r30]
[ASSIGN_REG] Mapeando 'high' para r10.
[ADD_INSTR] Adicionando instrução para 'minloc': subs: r0 = r9, r10

--- [TRANSLATE] Processando IR: if_false t3 goto L1 ---
[TRANSLATE] -> Caminho: Desvio Condicional (if_false)
[ADD_INSTR] Adicionando instrução para 'minloc': bigteq: L1

--- [TRANSLATE] Processando IR: t4 := a + i ---
[TRANSLATE] -> Detalhes: Destino='t4', Expressão='a + i'
[TRANSLATE] -> Caminho: Operação Aritmética
[ENSURE] Tentando garantir 'a' em um registrador.
[ENSURE] -> Sucesso! 'a' já está em r5.
[ENSURE] Tentando garantir 'i' em um registrador.
[ENSURE] -> Sucesso! 'i' já está em r9.
[GET_TEMP] Solicitando registrador para o temporário 't4'.
[GET_FREE] -> Encontrado registrador livre: r11. Restantes: 19.
[ASSIGN_REG] Mapeando 't4' para r11.
[GET_TEMP] -> 't4' alocado no registrador r11.
[ADD_INSTR] Adicionando instrução para 'minloc': add: r11 = r5, r9

--- [TRANSLATE] Processando IR: t5 := *t4 ---
[TRANSLATE] -> Detalhes: Destino='t5', Expressão='*t4'
[TRANSLATE] -> Caminho: Carregar de Ponteiro (*)
[TRANSLATE] -> Ponteiro é uma temporária ('t4'). Usando seu valor como endereço.
[ENSURE] Tentando garantir 't4' em um registrador.
[ENSURE] -> Sucesso! 't4' já está em r11.
[GET_TEMP] Solicitando registrador para o temporário 't5'.
[GET_FREE] -> Encontrado registrador livre: r12. Restantes: 18.
[ASSIGN_REG] Mapeando 't5' para r12.
[GET_TEMP] -> 't5' alocado no registrador r12.
[ADD_INSTR] Adicionando instrução para 'minloc': load: r12 = [r11]
[FREE_TEMP] Liberando registrador r11 que continha o temporário 't4'.
[UNASSIGN_REG] Desmapeado r11 de 't4'.
[UNASSIGN_REG] -> Estado atual: 19 registradores livres. Mapeamentos: {'k': 'r4', 'a': 'r5', 'low': 'r6', 'x': 'r8', 'i': 'r9', 'high': 'r10', 't5': 'r12'}

--- [TRANSLATE] Processando IR: t6 := t5 < x ---
[TRANSLATE] -> Detalhes: Destino='t6', Expressão='t5 < x'
[TRANSLATE] -> Caminho: Comparação (condicional)
[ENSURE] Tentando garantir 't5' em um registrador.
[ENSURE] -> Sucesso! 't5' já está em r12.
[ENSURE] Tentando garantir 'x' em um registrador.
[ENSURE] -> Sucesso! 'x' já está em r8.
[ADD_INSTR] Adicionando instrução para 'minloc': subs: r0 = r12, r8

--- [TRANSLATE] Processando IR: if_false t6 goto L2 ---
[TRANSLATE] -> Caminho: Desvio Condicional (if_false)
[ADD_INSTR] Adicionando instrução para 'minloc': bigteq: L2

--- [TRANSLATE] Processando IR: t7 := a + i ---
[TRANSLATE] -> Detalhes: Destino='t7', Expressão='a + i'
[TRANSLATE] -> Caminho: Operação Aritmética
[ENSURE] Tentando garantir 'a' em um registrador.
[ENSURE] -> Sucesso! 'a' já está em r5.
[ENSURE] Tentando garantir 'i' em um registrador.
[ENSURE] -> Sucesso! 'i' já está em r9.
[GET_TEMP] Solicitando registrador para o temporário 't7'.
[GET_FREE] -> Encontrado registrador livre: r13. Restantes: 18.
[ASSIGN_REG] Mapeando 't7' para r13.
[GET_TEMP] -> 't7' alocado no registrador r13.
[ADD_INSTR] Adicionando instrução para 'minloc': add: r13 = r5, r9

--- [TRANSLATE] Processando IR: t8 := *t7 ---
[TRANSLATE] -> Detalhes: Destino='t8', Expressão='*t7'
[TRANSLATE] -> Caminho: Carregar de Ponteiro (*)
[TRANSLATE] -> Ponteiro é uma temporária ('t7'). Usando seu valor como endereço.
[ENSURE] Tentando garantir 't7' em um registrador.
[ENSURE] -> Sucesso! 't7' já está em r13.
[GET_TEMP] Solicitando registrador para o temporário 't8'.
[GET_FREE] -> Encontrado registrador livre: r14. Restantes: 17.
[ASSIGN_REG] Mapeando 't8' para r14.
[GET_TEMP] -> 't8' alocado no registrador r14.
[ADD_INSTR] Adicionando instrução para 'minloc': load: r14 = [r13]
[FREE_TEMP] Liberando registrador r13 que continha o temporário 't7'.
[UNASSIGN_REG] Desmapeado r13 de 't7'.
[UNASSIGN_REG] -> Estado atual: 18 registradores livres. Mapeamentos: {'k': 'r4', 'a': 'r5', 'low': 'r6', 'x': 'r8', 'i': 'r9', 'high': 'r10', 't5': 'r12', 't8': 'r14'}

--- [TRANSLATE] Processando IR: x := t8 ---
[TRANSLATE] -> Detalhes: Destino='x', Expressão='t8'
[TRANSLATE] -> Caminho: Atribuição Simples
[ENSURE] Tentando garantir 't8' em um registrador.
[ENSURE] -> Sucesso! 't8' já está em r14.
[TRANSLATE_ASSIGN] -> Armazenando 'x' na sua posição da pilha.
[ADD_INSTR] Adicionando instrução para 'minloc': subi: r30 = r31, 6
[ADD_INSTR] Adicionando instrução para 'minloc': store: [r30] = r14
[UPDATE_MAP] Mapeando 'x' para o registrador r14 (que contém o valor de origem).
[ASSIGN_REG] Mapeando 'x' para r14.
[ASSIGN_REG] -> Variável 'x' já estava em r8. Liberando o mapeamento antigo.
[UNASSIGN_REG] Desmapeado r8 de 'x'.
[UNASSIGN_REG] -> Estado atual: 18 registradores livres. Mapeamentos: {'k': 'r4', 'a': 'r5', 'low': 'r6', 'i': 'r9', 'high': 'r10', 't5': 'r12', 't8': 'r14'}
[ASSIGN_REG] -> Registrador r14 já continha 't8'. Liberando o mapeamento antigo.
[UNASSIGN_REG] Desmapeado r14 de 't8'.
[UNASSIGN_REG] -> Estado atual: 19 registradores livres. Mapeamentos: {'k': 'r4', 'a': 'r5', 'low': 'r6', 'i': 'r9', 'high': 'r10', 't5': 'r12'}

--- [TRANSLATE] Processando IR: k := i ---
[TRANSLATE] -> Detalhes: Destino='k', Expressão='i'
[TRANSLATE] -> Caminho: Atribuição Simples
[ENSURE] Tentando garantir 'i' em um registrador.
[ENSURE] -> Sucesso! 'i' já está em r9.
[TRANSLATE_ASSIGN] -> Armazenando 'k' na sua posição da pilha.
[ADD_INSTR] Adicionando instrução para 'minloc': subi: r30 = r31, 5
[ADD_INSTR] Adicionando instrução para 'minloc': store: [r30] = r9
[UPDATE_MAP] Mapeando 'k' para o registrador r9 (que contém o valor de origem).
[ASSIGN_REG] Mapeando 'k' para r9.
[ASSIGN_REG] -> Variável 'k' já estava em r4. Liberando o mapeamento antigo.
[UNASSIGN_REG] Desmapeado r4 de 'k'.
[UNASSIGN_REG] -> Estado atual: 19 registradores livres. Mapeamentos: {'a': 'r5', 'low': 'r6', 'i': 'r9', 'high': 'r10', 't5': 'r12', 'x': 'r14'}
[ASSIGN_REG] -> Registrador r9 já continha 'i'. Liberando o mapeamento antigo.
[UNASSIGN_REG] Desmapeado r9 de 'i'.
[UNASSIGN_REG] -> Estado atual: 19 registradores livres. Mapeamentos: {'a': 'r5', 'low': 'r6', 'high': 'r10', 't5': 'r12', 'x': 'r14'}

--- [TRANSLATE] Processando IR: goto L3 ---
[TRANSLATE] -> Desvio incondicional detectado: L3
[SPILL_ALL] Verificando registradores sujos para salvar. Sujos: {'r7', 'r13', 'r14', 'r11', 'r12'}
[SPILL_ALL] -> Salvando variável local 'x' do registrador r14 na pilha [fp, #-6].
[ADD_INSTR] Adicionando instrução para 'minloc': subi: r30 = r31, 6
[ADD_INSTR] Adicionando instrução para 'minloc': store: [r30] = r14
[ADD_INSTR] Adicionando instrução para 'minloc': bi: L3

--- [TRANSLATE] Processando IR: L2: ---
[TRANSLATE] -> Rótulo detectado: L2:
[SPILL_ALL] Verificando registradores sujos para salvar. Sujos: {'r7', 'r13', 'r11', 'r12'}
[ADD_INSTR] Adicionando instrução para 'minloc': L2:

--- [TRANSLATE] Processando IR: L3: ---
[TRANSLATE] -> Rótulo detectado: L3:
[SPILL_ALL] Verificando registradores sujos para salvar. Sujos: {'r7', 'r13', 'r11', 'r12'}
[ADD_INSTR] Adicionando instrução para 'minloc': L3:

--- [TRANSLATE] Processando IR: t9 := i + 1 ---
[TRANSLATE] -> Detalhes: Destino='t9', Expressão='i + 1'
[TRANSLATE] -> Caminho: Operação Aritmética
[ENSURE] Tentando garantir 'i' em um registrador.
[ENSURE] -> 'i' é uma variável da pilha. Carregando...
[GET_FREE] -> Encontrado registrador livre: r15. Restantes: 18.
[ADD_INSTR] Adicionando instrução para 'minloc': subi: r30 = r31, 4
[ADD_INSTR] Adicionando instrução para 'minloc': load: r15 = [r30]
[ASSIGN_REG] Mapeando 'i' para r15.
[TRANSLATE] -> Operando 2 é um imediato: 1
[GET_TEMP] Solicitando registrador para o temporário 't9'.
[GET_FREE] -> Encontrado registrador livre: r16. Restantes: 17.
[ASSIGN_REG] Mapeando 't9' para r16.
[GET_TEMP] -> 't9' alocado no registrador r16.
[ADD_INSTR] Adicionando instrução para 'minloc': addi: r16 = r15, 1

--- [TRANSLATE] Processando IR: i := t9 ---
[TRANSLATE] -> Detalhes: Destino='i', Expressão='t9'
[TRANSLATE] -> Caminho: Atribuição Simples
[ENSURE] Tentando garantir 't9' em um registrador.
[ENSURE] -> Sucesso! 't9' já está em r16.
[TRANSLATE_ASSIGN] -> Armazenando 'i' na sua posição da pilha.
[ADD_INSTR] Adicionando instrução para 'minloc': subi: r30 = r31, 4
[ADD_INSTR] Adicionando instrução para 'minloc': store: [r30] = r16
[UPDATE_MAP] Mapeando 'i' para o registrador r16 (que contém o valor de origem).
[ASSIGN_REG] Mapeando 'i' para r16.
[ASSIGN_REG] -> Variável 'i' já estava em r15. Liberando o mapeamento antigo.
[UNASSIGN_REG] Desmapeado r15 de 'i'.
[UNASSIGN_REG] -> Estado atual: 18 registradores livres. Mapeamentos: {'a': 'r5', 'low': 'r6', 'high': 'r10', 't5': 'r12', 'x': 'r14', 'k': 'r9', 't9': 'r16'}
[ASSIGN_REG] -> Registrador r16 já continha 't9'. Liberando o mapeamento antigo.
[UNASSIGN_REG] Desmapeado r16 de 't9'.
[UNASSIGN_REG] -> Estado atual: 19 registradores livres. Mapeamentos: {'a': 'r5', 'low': 'r6', 'high': 'r10', 't5': 'r12', 'x': 'r14', 'k': 'r9'}

--- [TRANSLATE] Processando IR: goto L0 ---
[TRANSLATE_SKIP] -> Ignorando 'goto' redundante após um 'goto'.

--- [TRANSLATE] Processando IR: L1: ---
[TRANSLATE] -> Rótulo detectado: L1:
[SPILL_ALL] Verificando registradores sujos para salvar. Sujos: {'r7', 'r13', 'r16', 'r11', 'r12'}
[SPILL_ALL] -> Salvando variável local 'i' do registrador r16 na pilha [fp, #-4].
[ADD_INSTR] Adicionando instrução para 'minloc': subi: r30 = r31, 4
[ADD_INSTR] Adicionando instrução para 'minloc': store: [r30] = r16
[ADD_INSTR] Adicionando instrução para 'minloc': L1:

--- [TRANSLATE] Processando IR: return k ---
[TRANSLATE] -> Caminho: Retorno de Função
[ENSURE] Tentando garantir 'k' em um registrador.
[ENSURE] -> Sucesso! 'k' já está em r9.
[ADD_INSTR] Adicionando instrução para 'minloc': mov: r0 = r9
[SPILL_ALL] Verificando registradores sujos para salvar. Sujos: {'r7', 'r13', 'r11', 'r12'}
[TRANSLATE] -> Pular para a seção de epílogo.
[ADD_INSTR] Adicionando instrução para 'minloc': bi: minloc_epilogue
-> Finalizando a função 'minloc', fazendo spill de todos os registradores sujos.
[SPILL_ALL] Verificando registradores sujos para salvar. Sujos: {'r7', 'r13', 'r11', 'r12'}

[Processando Função] -> 'sort'
-> IR isolado para 'sort' contém 24 instruções.
[DEBUG] Função 'sort': all_vars={'high', 'a', 'low', 'k', 'i'}, defined_vars={'i', 'k'}, params=['high', 'a', 'low']
--> Parâmetros para 'sort': ['high', 'a', 'low']
--> Variáveis Locais para 'sort': ['i', 'k']
--> Criando o layout da pilha para 'sort'...
    -> Mapeando 'high' para o offset [fp, #-1] (size=1)
    -> Mapeando 'a' para o offset [fp, #-2] (size=1)
    -> Mapeando 'low' para o offset [fp, #-3] (size=1)
    -> Mapeando 'i' para o offset [fp, #-4] (size=1)
    -> Mapeando 'k' para o offset [fp, #-5] (size=1)
--> Tamanho total do frame para 'sort': 15 palavras.
[ADD_INSTR] Adicionando instrução para 'sort': subi: r30 = r31, 1
[ADD_INSTR] Adicionando instrução para 'sort': store: [r30] = r1
[ADD_INSTR] Adicionando instrução para 'sort': subi: r30 = r31, 2
[ADD_INSTR] Adicionando instrução para 'sort': store: [r30] = r2
[ADD_INSTR] Adicionando instrução para 'sort': subi: r30 = r31, 3
[ADD_INSTR] Adicionando instrução para 'sort': store: [r30] = r3

--- [TRANSLATE] Processando IR: i := low ---
[TRANSLATE] -> Detalhes: Destino='i', Expressão='low'
[TRANSLATE] -> Caminho: Atribuição Simples
[ENSURE] Tentando garantir 'low' em um registrador.
[ENSURE] -> 'low' é uma variável da pilha. Carregando...
[GET_FREE] -> Encontrado registrador livre: r4. Restantes: 22.
[ADD_INSTR] Adicionando instrução para 'sort': subi: r30 = r31, 3
[ADD_INSTR] Adicionando instrução para 'sort': load: r4 = [r30]
[ASSIGN_REG] Mapeando 'low' para r4.
[TRANSLATE_ASSIGN] -> Armazenando 'i' na sua posição da pilha.
[ADD_INSTR] Adicionando instrução para 'sort': subi: r30 = r31, 4
[ADD_INSTR] Adicionando instrução para 'sort': store: [r30] = r4
[UPDATE_MAP] Mapeando 'i' para o registrador r4 (que contém o valor de origem).
[ASSIGN_REG] Mapeando 'i' para r4.
[ASSIGN_REG] -> Registrador r4 já continha 'low'. Liberando o mapeamento antigo.
[UNASSIGN_REG] Desmapeado r4 de 'low'.
[UNASSIGN_REG] -> Estado atual: 23 registradores livres. Mapeamentos: {}

--- [TRANSLATE] Processando IR: L4: ---
[TRANSLATE] -> Rótulo detectado: L4:
[SPILL_ALL] Verificando registradores sujos para salvar. Sujos: set()
[ADD_INSTR] Adicionando instrução para 'sort': L4:

--- [TRANSLATE] Processando IR: t10 := high - 1 ---
[TRANSLATE] -> Detalhes: Destino='t10', Expressão='high - 1'
[TRANSLATE] -> Caminho: Operação Aritmética
[ENSURE] Tentando garantir 'high' em um registrador.
[ENSURE] -> 'high' é uma variável da pilha. Carregando...
[GET_FREE] -> Encontrado registrador livre: r5. Restantes: 22.
[ADD_INSTR] Adicionando instrução para 'sort': subi: r30 = r31, 1
[ADD_INSTR] Adicionando instrução para 'sort': load: r5 = [r30]
[ASSIGN_REG] Mapeando 'high' para r5.
[TRANSLATE] -> Operando 2 é um imediato: 1
[GET_TEMP] Solicitando registrador para o temporário 't10'.
[GET_FREE] -> Encontrado registrador livre: r6. Restantes: 21.
[ASSIGN_REG] Mapeando 't10' para r6.
[GET_TEMP] -> 't10' alocado no registrador r6.
[ADD_INSTR] Adicionando instrução para 'sort': subi: r6 = r5, 1

--- [TRANSLATE] Processando IR: t11 := i < t10 ---
[TRANSLATE] -> Detalhes: Destino='t11', Expressão='i < t10'
[TRANSLATE] -> Caminho: Comparação (condicional)
[ENSURE] Tentando garantir 'i' em um registrador.
[ENSURE] -> Sucesso! 'i' já está em r4.
[ENSURE] Tentando garantir 't10' em um registrador.
[ENSURE] -> Sucesso! 't10' já está em r6.
[ADD_INSTR] Adicionando instrução para 'sort': subs: r0 = r4, r6

--- [TRANSLATE] Processando IR: if_false t11 goto L5 ---
[TRANSLATE] -> Caminho: Desvio Condicional (if_false)
[ADD_INSTR] Adicionando instrução para 'sort': bigteq: L5

--- [TRANSLATE] Processando IR: arg a ---
[TRANSLATE] -> Caminho: Passagem de Argumento (arg 1)
[ENSURE] Tentando garantir 'a' em um registrador.
[ENSURE] -> 'a' é uma variável da pilha. Carregando...
[GET_FREE] -> Encontrado registrador livre: r7. Restantes: 20.
[ADD_INSTR] Adicionando instrução para 'sort': subi: r30 = r31, 2
[ADD_INSTR] Adicionando instrução para 'sort': load: r7 = [r30]
[ASSIGN_REG] Mapeando 'a' para r7.
[ADD_INSTR] Adicionando instrução para 'sort': mov: r1 = r7

--- [TRANSLATE] Processando IR: arg i ---
[TRANSLATE] -> Caminho: Passagem de Argumento (arg 2)
[ENSURE] Tentando garantir 'i' em um registrador.
[ENSURE] -> Sucesso! 'i' já está em r4.
[ADD_INSTR] Adicionando instrução para 'sort': mov: r2 = r4

--- [TRANSLATE] Processando IR: arg high ---
[TRANSLATE] -> Caminho: Passagem de Argumento (arg 3)
[ENSURE] Tentando garantir 'high' em um registrador.
[ENSURE] -> Sucesso! 'high' já está em r5.
[ADD_INSTR] Adicionando instrução para 'sort': mov: r3 = r5

--- [TRANSLATE] Processando IR: t12 := call minloc, 3 ---
[TRANSLATE] -> Detalhes: Destino='t12', Expressão='call minloc, 3'
[TRANSLATE] -> Caminho: Chamada de Função
[SPILL_ALL] Verificando registradores sujos para salvar. Sujos: {'r6'}
[TRANSLATE] -> Caminho: Chamada de Função com Retorno
[GET_TEMP] Solicitando registrador para o temporário 't_ret_21'.
[GET_FREE] -> Encontrado registrador livre: r8. Restantes: 19.
[ASSIGN_REG] Mapeando 't_ret_21' para r8.
[GET_TEMP] -> 't_ret_21' alocado no registrador r8.
[ADD_INSTR] Adicionando instrução para 'sort': movi: r8 = sort_Lret0
[ADD_INSTR] Adicionando instrução para 'sort': mov: r28 = r8
[ADD_INSTR] Adicionando instrução para 'sort': bl: minloc
[FREE_TEMP] Liberando registrador r8 que continha o temporário 't_ret_21'.
[UNASSIGN_REG] Desmapeado r8 de 't_ret_21'.
[UNASSIGN_REG] -> Estado atual: 20 registradores livres. Mapeamentos: {'i': 'r4', 'high': 'r5', 't10': 'r6', 'a': 'r7'}
[ADD_INSTR] Adicionando instrução para 'sort': sort_Lret0:
[GET_TEMP] Solicitando registrador para o temporário 't12'.
[GET_FREE] -> Encontrado registrador livre: r9. Restantes: 19.
[ASSIGN_REG] Mapeando 't12' para r9.
[GET_TEMP] -> 't12' alocado no registrador r9.
[ADD_INSTR] Adicionando instrução para 'sort': mov: r9 = r0
[UNASSIGN_REG] Desmapeado r7 de 'a'.
[UNASSIGN_REG] -> Estado atual: 20 registradores livres. Mapeamentos: {'i': 'r4', 'high': 'r5', 't10': 'r6', 't12': 'r9'}
[UNASSIGN_REG] Desmapeado r4 de 'i'.
[UNASSIGN_REG] -> Estado atual: 20 registradores livres. Mapeamentos: {'high': 'r5', 't10': 'r6', 't12': 'r9'}
[UNASSIGN_REG] Desmapeado r5 de 'high'.
[UNASSIGN_REG] -> Estado atual: 21 registradores livres. Mapeamentos: {'t10': 'r6', 't12': 'r9'}

--- [TRANSLATE] Processando IR: k := t12 ---
[TRANSLATE] -> Detalhes: Destino='k', Expressão='t12'
[TRANSLATE] -> Caminho: Atribuição Simples
[ENSURE] Tentando garantir 't12' em um registrador.
[ENSURE] -> Sucesso! 't12' já está em r9.
[TRANSLATE_ASSIGN] -> Armazenando 'k' na sua posição da pilha.
[ADD_INSTR] Adicionando instrução para 'sort': subi: r30 = r31, 5
[ADD_INSTR] Adicionando instrução para 'sort': store: [r30] = r9
[UPDATE_MAP] Mapeando 'k' para o registrador r9 (que contém o valor de origem).
[ASSIGN_REG] Mapeando 'k' para r9.
[ASSIGN_REG] -> Registrador r9 já continha 't12'. Liberando o mapeamento antigo.
[UNASSIGN_REG] Desmapeado r9 de 't12'.
[UNASSIGN_REG] -> Estado atual: 22 registradores livres. Mapeamentos: {'t10': 'r6'}

--- [TRANSLATE] Processando IR: t13 := a + k ---
[TRANSLATE] -> Detalhes: Destino='t13', Expressão='a + k'
[TRANSLATE] -> Caminho: Operação Aritmética
[ENSURE] Tentando garantir 'a' em um registrador.
[ENSURE] -> 'a' é uma variável da pilha. Carregando...
[GET_FREE] -> Encontrado registrador livre: r10. Restantes: 21.
[ADD_INSTR] Adicionando instrução para 'sort': subi: r30 = r31, 2
[ADD_INSTR] Adicionando instrução para 'sort': load: r10 = [r30]
[ASSIGN_REG] Mapeando 'a' para r10.
[ENSURE] Tentando garantir 'k' em um registrador.
[ENSURE] -> Sucesso! 'k' já está em r9.
[GET_TEMP] Solicitando registrador para o temporário 't13'.
[GET_FREE] -> Encontrado registrador livre: r11. Restantes: 20.
[ASSIGN_REG] Mapeando 't13' para r11.
[GET_TEMP] -> 't13' alocado no registrador r11.
[ADD_INSTR] Adicionando instrução para 'sort': add: r11 = r10, r9

--- [TRANSLATE] Processando IR: t14 := *t13 ---
[TRANSLATE] -> Detalhes: Destino='t14', Expressão='*t13'
[TRANSLATE] -> Caminho: Carregar de Ponteiro (*)
[TRANSLATE] -> Ponteiro é uma temporária ('t13'). Usando seu valor como endereço.
[ENSURE] Tentando garantir 't13' em um registrador.
[ENSURE] -> Sucesso! 't13' já está em r11.
[GET_TEMP] Solicitando registrador para o temporário 't14'.
[GET_FREE] -> Encontrado registrador livre: r12. Restantes: 19.
[ASSIGN_REG] Mapeando 't14' para r12.
[GET_TEMP] -> 't14' alocado no registrador r12.
[ADD_INSTR] Adicionando instrução para 'sort': load: r12 = [r11]
[FREE_TEMP] Liberando registrador r11 que continha o temporário 't13'.
[UNASSIGN_REG] Desmapeado r11 de 't13'.
[UNASSIGN_REG] -> Estado atual: 20 registradores livres. Mapeamentos: {'t10': 'r6', 'k': 'r9', 'a': 'r10', 't14': 'r12'}

--- [TRANSLATE] Processando IR: t := t14 ---
[TRANSLATE] -> Detalhes: Destino='t', Expressão='t14'
[TRANSLATE] -> Caminho: Atribuição Simples
[ENSURE] Tentando garantir 't14' em um registrador.
[ENSURE] -> Sucesso! 't14' já está em r12.
[UPDATE_MAP] Mapeando 't' para o registrador r12 (que contém o valor de origem).
[ASSIGN_REG] Mapeando 't' para r12.
[ASSIGN_REG] -> Registrador r12 já continha 't14'. Liberando o mapeamento antigo.
[UNASSIGN_REG] Desmapeado r12 de 't14'.
[UNASSIGN_REG] -> Estado atual: 21 registradores livres. Mapeamentos: {'t10': 'r6', 'k': 'r9', 'a': 'r10'}
[FREE_TEMP] Liberando registrador r12 que continha o temporário 't'.
[UNASSIGN_REG] Desmapeado r12 de 't'.
[UNASSIGN_REG] -> Estado atual: 21 registradores livres. Mapeamentos: {'t10': 'r6', 'k': 'r9', 'a': 'r10'}

--- [TRANSLATE] Processando IR: t15 := a + i ---
[TRANSLATE] -> Detalhes: Destino='t15', Expressão='a + i'
[TRANSLATE] -> Caminho: Operação Aritmética
[ENSURE] Tentando garantir 'a' em um registrador.
[ENSURE] -> Sucesso! 'a' já está em r10.
[ENSURE] Tentando garantir 'i' em um registrador.
[ENSURE] -> 'i' é uma variável da pilha. Carregando...
[GET_FREE] -> Encontrado registrador livre: r13. Restantes: 20.
[ADD_INSTR] Adicionando instrução para 'sort': subi: r30 = r31, 4
[ADD_INSTR] Adicionando instrução para 'sort': load: r13 = [r30]
[ASSIGN_REG] Mapeando 'i' para r13.
[GET_TEMP] Solicitando registrador para o temporário 't15'.
[GET_FREE] -> Encontrado registrador livre: r14. Restantes: 19.
[ASSIGN_REG] Mapeando 't15' para r14.
[GET_TEMP] -> 't15' alocado no registrador r14.
[ADD_INSTR] Adicionando instrução para 'sort': add: r14 = r10, r13

--- [TRANSLATE] Processando IR: t16 := *t15 ---
[TRANSLATE] -> Detalhes: Destino='t16', Expressão='*t15'
[TRANSLATE] -> Caminho: Carregar de Ponteiro (*)
[TRANSLATE] -> Ponteiro é uma temporária ('t15'). Usando seu valor como endereço.
[ENSURE] Tentando garantir 't15' em um registrador.
[ENSURE] -> Sucesso! 't15' já está em r14.
[GET_TEMP] Solicitando registrador para o temporário 't16'.
[GET_FREE] -> Encontrado registrador livre: r15. Restantes: 18.
[ASSIGN_REG] Mapeando 't16' para r15.
[GET_TEMP] -> 't16' alocado no registrador r15.
[ADD_INSTR] Adicionando instrução para 'sort': load: r15 = [r14]
[FREE_TEMP] Liberando registrador r14 que continha o temporário 't15'.
[UNASSIGN_REG] Desmapeado r14 de 't15'.
[UNASSIGN_REG] -> Estado atual: 19 registradores livres. Mapeamentos: {'t10': 'r6', 'k': 'r9', 'a': 'r10', 'i': 'r13', 't16': 'r15'}

--- [TRANSLATE] Processando IR: t17 := a + k ---
[TRANSLATE] -> Detalhes: Destino='t17', Expressão='a + k'
[TRANSLATE] -> Caminho: Operação Aritmética
[ENSURE] Tentando garantir 'a' em um registrador.
[ENSURE] -> Sucesso! 'a' já está em r10.
[ENSURE] Tentando garantir 'k' em um registrador.
[ENSURE] -> Sucesso! 'k' já está em r9.
[GET_TEMP] Solicitando registrador para o temporário 't17'.
[GET_FREE] -> Encontrado registrador livre: r16. Restantes: 18.
[ASSIGN_REG] Mapeando 't17' para r16.
[GET_TEMP] -> 't17' alocado no registrador r16.
[ADD_INSTR] Adicionando instrução para 'sort': add: r16 = r10, r9

--- [TRANSLATE] Processando IR: *t17 := t16 ---
[TRANSLATE] -> Detalhes: Destino='*t17', Expressão='t16'
[TRANSLATE] -> Caminho: Armazenar em Ponteiro (*)
[ENSURE] Tentando garantir 't16' em um registrador.
[ENSURE] -> Sucesso! 't16' já está em r15.
[TRANSLATE] -> Endereço de destino é uma variável temporária. Usando registrador temporário.
[ENSURE] Tentando garantir 't17' em um registrador.
[ENSURE] -> Sucesso! 't17' já está em r16.
[ADD_INSTR] Adicionando instrução para 'sort': store: [r16] = r15
[UNASSIGN_REG] Desmapeado r15 de 't16'.
[UNASSIGN_REG] -> Estado atual: 19 registradores livres. Mapeamentos: {'t10': 'r6', 'k': 'r9', 'a': 'r10', 'i': 'r13', 't17': 'r16'}
[UNASSIGN_REG] Desmapeado r16 de 't17'.
[UNASSIGN_REG] -> Estado atual: 20 registradores livres. Mapeamentos: {'t10': 'r6', 'k': 'r9', 'a': 'r10', 'i': 'r13'}

--- [TRANSLATE] Processando IR: t18 := a + i ---
[TRANSLATE] -> Detalhes: Destino='t18', Expressão='a + i'
[TRANSLATE] -> Caminho: Operação Aritmética
[ENSURE] Tentando garantir 'a' em um registrador.
[ENSURE] -> Sucesso! 'a' já está em r10.
[ENSURE] Tentando garantir 'i' em um registrador.
[ENSURE] -> Sucesso! 'i' já está em r13.
[GET_TEMP] Solicitando registrador para o temporário 't18'.
[GET_FREE] -> Encontrado registrador livre: r17. Restantes: 19.
[ASSIGN_REG] Mapeando 't18' para r17.
[GET_TEMP] -> 't18' alocado no registrador r17.
[ADD_INSTR] Adicionando instrução para 'sort': add: r17 = r10, r13

--- [TRANSLATE] Processando IR: *t18 := t ---
[TRANSLATE] -> Detalhes: Destino='*t18', Expressão='t'
[TRANSLATE] -> Caminho: Armazenar em Ponteiro (*)
[ENSURE] Tentando garantir 't' em um registrador.
[GET_TEMP] Solicitando registrador para o temporário 't'.
[GET_FREE] -> Encontrado registrador livre: r18. Restantes: 18.
[ASSIGN_REG] Mapeando 't' para r18.
[GET_TEMP] -> 't' alocado no registrador r18.
[ENSURE] -> Variável temporária 't' alocada em r18.
[TRANSLATE] -> Endereço de destino é uma variável temporária. Usando registrador temporário.
[ENSURE] Tentando garantir 't18' em um registrador.
[ENSURE] -> Sucesso! 't18' já está em r17.
[ADD_INSTR] Adicionando instrução para 'sort': store: [r17] = r18
[UNASSIGN_REG] Desmapeado r18 de 't'.
[UNASSIGN_REG] -> Estado atual: 19 registradores livres. Mapeamentos: {'t10': 'r6', 'k': 'r9', 'a': 'r10', 'i': 'r13', 't18': 'r17'}
[UNASSIGN_REG] Desmapeado r17 de 't18'.
[UNASSIGN_REG] -> Estado atual: 20 registradores livres. Mapeamentos: {'t10': 'r6', 'k': 'r9', 'a': 'r10', 'i': 'r13'}

--- [TRANSLATE] Processando IR: t19 := i + 1 ---
[TRANSLATE] -> Detalhes: Destino='t19', Expressão='i + 1'
[TRANSLATE] -> Caminho: Operação Aritmética
[ENSURE] Tentando garantir 'i' em um registrador.
[ENSURE] -> Sucesso! 'i' já está em r13.
[TRANSLATE] -> Operando 2 é um imediato: 1
[GET_TEMP] Solicitando registrador para o temporário 't19'.
[GET_FREE] -> Encontrado registrador livre: r19. Restantes: 19.
[ASSIGN_REG] Mapeando 't19' para r19.
[GET_TEMP] -> 't19' alocado no registrador r19.
[ADD_INSTR] Adicionando instrução para 'sort': addi: r19 = r13, 1

--- [TRANSLATE] Processando IR: i := t19 ---
[TRANSLATE] -> Detalhes: Destino='i', Expressão='t19'
[TRANSLATE] -> Caminho: Atribuição Simples
[ENSURE] Tentando garantir 't19' em um registrador.
[ENSURE] -> Sucesso! 't19' já está em r19.
[TRANSLATE_ASSIGN] -> Armazenando 'i' na sua posição da pilha.
[ADD_INSTR] Adicionando instrução para 'sort': subi: r30 = r31, 4
[ADD_INSTR] Adicionando instrução para 'sort': store: [r30] = r19
[UPDATE_MAP] Mapeando 'i' para o registrador r19 (que contém o valor de origem).
[ASSIGN_REG] Mapeando 'i' para r19.
[ASSIGN_REG] -> Variável 'i' já estava em r13. Liberando o mapeamento antigo.
[UNASSIGN_REG] Desmapeado r13 de 'i'.
[UNASSIGN_REG] -> Estado atual: 20 registradores livres. Mapeamentos: {'t10': 'r6', 'k': 'r9', 'a': 'r10', 't19': 'r19'}
[ASSIGN_REG] -> Registrador r19 já continha 't19'. Liberando o mapeamento antigo.
[UNASSIGN_REG] Desmapeado r19 de 't19'.
[UNASSIGN_REG] -> Estado atual: 21 registradores livres. Mapeamentos: {'t10': 'r6', 'k': 'r9', 'a': 'r10'}

--- [TRANSLATE] Processando IR: goto L4 ---
[TRANSLATE] -> Desvio incondicional detectado: L4
[SPILL_ALL] Verificando registradores sujos para salvar. Sujos: {'r15', 'r17', 'r14', 'r9', 'r8', 'r18', 'r16', 'r11', 'r19', 'r6', 'r12'}
[SPILL_ALL] -> Salvando variável local 'k' do registrador r9 na pilha [fp, #-5].
[ADD_INSTR] Adicionando instrução para 'sort': subi: r30 = r31, 5
[ADD_INSTR] Adicionando instrução para 'sort': store: [r30] = r9
[SPILL_ALL] -> Salvando variável local 'i' do registrador r19 na pilha [fp, #-4].
[ADD_INSTR] Adicionando instrução para 'sort': subi: r30 = r31, 4
[ADD_INSTR] Adicionando instrução para 'sort': store: [r30] = r19
[ADD_INSTR] Adicionando instrução para 'sort': bi: L4

--- [TRANSLATE] Processando IR: L5: ---
[TRANSLATE] -> Rótulo detectado: L5:
[SPILL_ALL] Verificando registradores sujos para salvar. Sujos: {'r15', 'r17', 'r14', 'r8', 'r18', 'r16', 'r11', 'r6', 'r12'}
[ADD_INSTR] Adicionando instrução para 'sort': L5:

--- [TRANSLATE] Processando IR: return _ ---
[TRANSLATE] -> Caminho: Retorno de Função
[SPILL_ALL] Verificando registradores sujos para salvar. Sujos: {'r15', 'r17', 'r14', 'r8', 'r18', 'r16', 'r11', 'r6', 'r12'}
[TRANSLATE] -> Pular para a seção de epílogo.
[ADD_INSTR] Adicionando instrução para 'sort': bi: sort_epilogue
-> Finalizando a função 'sort', fazendo spill de todos os registradores sujos.
[SPILL_ALL] Verificando registradores sujos para salvar. Sujos: {'r15', 'r17', 'r14', 'r8', 'r18', 'r16', 'r11', 'r6', 'r12'}

[Processando Função] -> 'main'
-> IR isolado para 'main' contém 31 instruções.
[DEBUG] Função 'main': all_vars={'i', 'vet'}, defined_vars={'i'}, params=['vet']
--> Parâmetros para 'main': ['vet']
--> Variáveis Locais para 'main': ['i']
--> Criando o layout da pilha para 'main'...
    -> Mapeando 'vet' para o offset [fp, #-1] (size=1)
    -> Mapeando 'i' para o offset [fp, #-2] (size=1)
--> Tamanho total do frame para 'main': 13 palavras.
[ADD_INSTR] Adicionando instrução para 'main': subi: r30 = r31, 1
[ADD_INSTR] Adicionando instrução para 'main': store: [r30] = r1

--- [TRANSLATE] Processando IR: i := 0 ---
[TRANSLATE] -> Detalhes: Destino='i', Expressão='0'
[TRANSLATE] -> Caminho: Atribuição Simples
[ENSURE] Tentando garantir '0' em um registrador.
[GET_FREE] -> Encontrado registrador livre: r4. Restantes: 22.
[ENSURE] -> Alocando r4 para a constante '0'.
[ADD_INSTR] Adicionando instrução para 'main': movi: r4 = 0
[TRANSLATE_ASSIGN] -> Armazenando 'i' na sua posição da pilha.
[ADD_INSTR] Adicionando instrução para 'main': subi: r30 = r31, 2
[ADD_INSTR] Adicionando instrução para 'main': store: [r30] = r4
[UPDATE_MAP] Mapeando 'i' para o registrador r4 (que contém o valor de origem).
[ASSIGN_REG] Mapeando 'i' para r4.

--- [TRANSLATE] Processando IR: L6: ---
[TRANSLATE] -> Rótulo detectado: L6:
[SPILL_ALL] Verificando registradores sujos para salvar. Sujos: set()
[ADD_INSTR] Adicionando instrução para 'main': L6:

--- [TRANSLATE] Processando IR: t20 := i < 2 ---
[TRANSLATE] -> Detalhes: Destino='t20', Expressão='i < 2'
[TRANSLATE] -> Caminho: Comparação (condicional)
[ENSURE] Tentando garantir 'i' em um registrador.
[ENSURE] -> Sucesso! 'i' já está em r4.
[ENSURE] Tentando garantir '2' em um registrador.
[GET_FREE] -> Encontrado registrador livre: r5. Restantes: 21.
[ENSURE] -> Alocando r5 para a constante '2'.
[ADD_INSTR] Adicionando instrução para 'main': movi: r5 = 2
[ADD_INSTR] Adicionando instrução para 'main': subs: r0 = r4, r5

--- [TRANSLATE] Processando IR: if_false t20 goto L7 ---
[TRANSLATE] -> Caminho: Desvio Condicional (if_false)
[ADD_INSTR] Adicionando instrução para 'main': bigteq: L7

--- [TRANSLATE] Processando IR: t21 := call input, 0 ---
[TRANSLATE] -> Detalhes: Destino='t21', Expressão='call input, 0'
[TRANSLATE] -> Caminho: Chamada de Função
[SPILL_ALL] Verificando registradores sujos para salvar. Sujos: set()
	[TRANSLATE] -> Caminho: Chamada de Função Input
[GET_TEMP] Solicitando registrador para o temporário 't21'.
[GET_FREE] -> Encontrado registrador livre: r6. Restantes: 20.
[ASSIGN_REG] Mapeando 't21' para r6.
[GET_TEMP] -> 't21' alocado no registrador r6.
[ADD_INSTR] Adicionando instrução para 'main': in: r6

--- [TRANSLATE] Processando IR: t22 := &vet ---
[TRANSLATE] -> Detalhes: Destino='t22', Expressão='&vet'
[GET_TEMP] Solicitando registrador para o temporário 't22'.
[GET_FREE] -> Encontrado registrador livre: r7. Restantes: 19.
[ASSIGN_REG] Mapeando 't22' para r7.
[GET_TEMP] -> 't22' alocado no registrador r7.
[GET_ADDR] Obtendo endereço para 'vet'.
[GET_FREE] -> Encontrado registrador livre: r8. Restantes: 18.
[GET_ADDR] -> 'vet' está na pilha. Calculando endereço [fp, #-1].
[ADD_INSTR] Adicionando instrução para 'main': subi: r8 = r31, 1
[ADD_INSTR] Adicionando instrução para 'main': mov: r7 = r8

--- [TRANSLATE] Processando IR: t23 := t22 + i ---
[TRANSLATE] -> Detalhes: Destino='t23', Expressão='t22 + i'
[TRANSLATE] -> Caminho: Operação Aritmética
[ENSURE] Tentando garantir 't22' em um registrador.
[ENSURE] -> Sucesso! 't22' já está em r7.
[ENSURE] Tentando garantir 'i' em um registrador.
[ENSURE] -> Sucesso! 'i' já está em r4.
[GET_TEMP] Solicitando registrador para o temporário 't23'.
[GET_FREE] -> Encontrado registrador livre: r9. Restantes: 17.
[ASSIGN_REG] Mapeando 't23' para r9.
[GET_TEMP] -> 't23' alocado no registrador r9.
[ADD_INSTR] Adicionando instrução para 'main': add: r9 = r7, r4
[FREE_TEMP] Liberando registrador r7 que continha o temporário 't22'.
[UNASSIGN_REG] Desmapeado r7 de 't22'.
[UNASSIGN_REG] -> Estado atual: 18 registradores livres. Mapeamentos: {'i': 'r4', 't21': 'r6', 't23': 'r9'}

--- [TRANSLATE] Processando IR: *t23 := t21 ---
[TRANSLATE] -> Detalhes: Destino='*t23', Expressão='t21'
[TRANSLATE] -> Caminho: Armazenar em Ponteiro (*)
[ENSURE] Tentando garantir 't21' em um registrador.
[ENSURE] -> Sucesso! 't21' já está em r6.
[TRANSLATE] -> Endereço de destino é uma variável temporária. Usando registrador temporário.
[ENSURE] Tentando garantir 't23' em um registrador.
[ENSURE] -> Sucesso! 't23' já está em r9.
[ADD_INSTR] Adicionando instrução para 'main': store: [r9] = r6
[UNASSIGN_REG] Desmapeado r6 de 't21'.
[UNASSIGN_REG] -> Estado atual: 19 registradores livres. Mapeamentos: {'i': 'r4', 't23': 'r9'}
[UNASSIGN_REG] Desmapeado r9 de 't23'.
[UNASSIGN_REG] -> Estado atual: 20 registradores livres. Mapeamentos: {'i': 'r4'}

--- [TRANSLATE] Processando IR: t24 := i + 1 ---
[TRANSLATE] -> Detalhes: Destino='t24', Expressão='i + 1'
[TRANSLATE] -> Caminho: Operação Aritmética
[ENSURE] Tentando garantir 'i' em um registrador.
[ENSURE] -> Sucesso! 'i' já está em r4.
[TRANSLATE] -> Operando 2 é um imediato: 1
[GET_TEMP] Solicitando registrador para o temporário 't24'.
[GET_FREE] -> Encontrado registrador livre: r10. Restantes: 19.
[ASSIGN_REG] Mapeando 't24' para r10.
[GET_TEMP] -> 't24' alocado no registrador r10.
[ADD_INSTR] Adicionando instrução para 'main': addi: r10 = r4, 1

--- [TRANSLATE] Processando IR: i := t24 ---
[TRANSLATE] -> Detalhes: Destino='i', Expressão='t24'
[TRANSLATE] -> Caminho: Atribuição Simples
[ENSURE] Tentando garantir 't24' em um registrador.
[ENSURE] -> Sucesso! 't24' já está em r10.
[TRANSLATE_ASSIGN] -> Armazenando 'i' na sua posição da pilha.
[ADD_INSTR] Adicionando instrução para 'main': subi: r30 = r31, 2
[ADD_INSTR] Adicionando instrução para 'main': store: [r30] = r10
[UPDATE_MAP] Mapeando 'i' para o registrador r10 (que contém o valor de origem).
[ASSIGN_REG] Mapeando 'i' para r10.
[ASSIGN_REG] -> Variável 'i' já estava em r4. Liberando o mapeamento antigo.
[UNASSIGN_REG] Desmapeado r4 de 'i'.
[UNASSIGN_REG] -> Estado atual: 20 registradores livres. Mapeamentos: {'t24': 'r10'}
[ASSIGN_REG] -> Registrador r10 já continha 't24'. Liberando o mapeamento antigo.
[UNASSIGN_REG] Desmapeado r10 de 't24'.
[UNASSIGN_REG] -> Estado atual: 21 registradores livres. Mapeamentos: {}

--- [TRANSLATE] Processando IR: goto L6 ---
[TRANSLATE] -> Desvio incondicional detectado: L6
[SPILL_ALL] Verificando registradores sujos para salvar. Sujos: {'r7', 'r6', 'r10', 'r9'}
[SPILL_ALL] -> Salvando variável local 'i' do registrador r10 na pilha [fp, #-2].
[ADD_INSTR] Adicionando instrução para 'main': subi: r30 = r31, 2
[ADD_INSTR] Adicionando instrução para 'main': store: [r30] = r10
[ADD_INSTR] Adicionando instrução para 'main': bi: L6

--- [TRANSLATE] Processando IR: L7: ---
[TRANSLATE] -> Rótulo detectado: L7:
[SPILL_ALL] Verificando registradores sujos para salvar. Sujos: {'r7', 'r6', 'r9'}
[ADD_INSTR] Adicionando instrução para 'main': L7:

--- [TRANSLATE] Processando IR: t25 := &vet ---
[TRANSLATE] -> Detalhes: Destino='t25', Expressão='&vet'
[GET_TEMP] Solicitando registrador para o temporário 't25'.
[GET_FREE] -> Encontrado registrador livre: r11. Restantes: 20.
[ASSIGN_REG] Mapeando 't25' para r11.
[GET_TEMP] -> 't25' alocado no registrador r11.
[GET_ADDR] Obtendo endereço para 'vet'.
[GET_FREE] -> Encontrado registrador livre: r12. Restantes: 19.
[GET_ADDR] -> 'vet' está na pilha. Calculando endereço [fp, #-1].
[ADD_INSTR] Adicionando instrução para 'main': subi: r12 = r31, 1
[ADD_INSTR] Adicionando instrução para 'main': mov: r11 = r12

--- [TRANSLATE] Processando IR: arg t25 ---
[TRANSLATE] -> Caminho: Passagem de Argumento (arg 1)
[ENSURE] Tentando garantir 't25' em um registrador.
[ENSURE] -> Sucesso! 't25' já está em r11.
[ADD_INSTR] Adicionando instrução para 'main': mov: r1 = r11

--- [TRANSLATE] Processando IR: arg 0 ---
[TRANSLATE] -> Caminho: Passagem de Argumento (arg 2)
[ENSURE] Tentando garantir '0' em um registrador.
[GET_FREE] -> Encontrado registrador livre: r13. Restantes: 18.
[ENSURE] -> Alocando r13 para a constante '0'.
[ADD_INSTR] Adicionando instrução para 'main': movi: r13 = 0
[ADD_INSTR] Adicionando instrução para 'main': mov: r2 = r13

--- [TRANSLATE] Processando IR: arg 2 ---
[TRANSLATE] -> Caminho: Passagem de Argumento (arg 3)
[ENSURE] Tentando garantir '2' em um registrador.
[GET_FREE] -> Encontrado registrador livre: r14. Restantes: 17.
[ENSURE] -> Alocando r14 para a constante '2'.
[ADD_INSTR] Adicionando instrução para 'main': movi: r14 = 2
[ADD_INSTR] Adicionando instrução para 'main': mov: r3 = r14

--- [TRANSLATE] Processando IR: call sort, 3 ---
[TRANSLATE] -> Caminho: Chamada de Procedimento
[SPILL_ALL] Verificando registradores sujos para salvar. Sujos: {'r7', 'r9', 'r11', 'r6'}
[ADD_INSTR] Adicionando instrução para 'main': movi: r28 = main_Lret0
[ADD_INSTR] Adicionando instrução para 'main': bl: sort
[ADD_INSTR] Adicionando instrução para 'main': main_Lret0:
[UNASSIGN_REG] Desmapeado r11 de 't25'.
[UNASSIGN_REG] -> Estado atual: 18 registradores livres. Mapeamentos: {'i': 'r10'}

--- [TRANSLATE] Processando IR: i := 0 ---
[TRANSLATE] -> Detalhes: Destino='i', Expressão='0'
[TRANSLATE] -> Caminho: Atribuição Simples
[ENSURE] Tentando garantir '0' em um registrador.
[GET_FREE] -> Encontrado registrador livre: r15. Restantes: 17.
[ENSURE] -> Alocando r15 para a constante '0'.
[ADD_INSTR] Adicionando instrução para 'main': movi: r15 = 0
[TRANSLATE_ASSIGN] -> Armazenando 'i' na sua posição da pilha.
[ADD_INSTR] Adicionando instrução para 'main': subi: r30 = r31, 2
[ADD_INSTR] Adicionando instrução para 'main': store: [r30] = r15
[UPDATE_MAP] Mapeando 'i' para o registrador r15 (que contém o valor de origem).
[ASSIGN_REG] Mapeando 'i' para r15.
[ASSIGN_REG] -> Variável 'i' já estava em r10. Liberando o mapeamento antigo.
[UNASSIGN_REG] Desmapeado r10 de 'i'.
[UNASSIGN_REG] -> Estado atual: 17 registradores livres. Mapeamentos: {}

--- [TRANSLATE] Processando IR: L8: ---
[TRANSLATE] -> Rótulo detectado: L8:
[SPILL_ALL] Verificando registradores sujos para salvar. Sujos: {'r7', 'r9', 'r6'}
[ADD_INSTR] Adicionando instrução para 'main': L8:

--- [TRANSLATE] Processando IR: t26 := i < 2 ---
[TRANSLATE] -> Detalhes: Destino='t26', Expressão='i < 2'
[TRANSLATE] -> Caminho: Comparação (condicional)
[ENSURE] Tentando garantir 'i' em um registrador.
[ENSURE] -> Sucesso! 'i' já está em r15.
[ENSURE] Tentando garantir '2' em um registrador.
[GET_FREE] -> Encontrado registrador livre: r16. Restantes: 16.
[ENSURE] -> Alocando r16 para a constante '2'.
[ADD_INSTR] Adicionando instrução para 'main': movi: r16 = 2
[ADD_INSTR] Adicionando instrução para 'main': subs: r0 = r15, r16

--- [TRANSLATE] Processando IR: if_false t26 goto L9 ---
[TRANSLATE] -> Caminho: Desvio Condicional (if_false)
[ADD_INSTR] Adicionando instrução para 'main': bigteq: L9

--- [TRANSLATE] Processando IR: t27 := &vet ---
[TRANSLATE] -> Detalhes: Destino='t27', Expressão='&vet'
[GET_TEMP] Solicitando registrador para o temporário 't27'.
[GET_FREE] -> Encontrado registrador livre: r17. Restantes: 15.
[ASSIGN_REG] Mapeando 't27' para r17.
[GET_TEMP] -> 't27' alocado no registrador r17.
[GET_ADDR] Obtendo endereço para 'vet'.
[GET_FREE] -> Encontrado registrador livre: r18. Restantes: 14.
[GET_ADDR] -> 'vet' está na pilha. Calculando endereço [fp, #-1].
[ADD_INSTR] Adicionando instrução para 'main': subi: r18 = r31, 1
[ADD_INSTR] Adicionando instrução para 'main': mov: r17 = r18

--- [TRANSLATE] Processando IR: t28 := t27 + i ---
[TRANSLATE] -> Detalhes: Destino='t28', Expressão='t27 + i'
[TRANSLATE] -> Caminho: Operação Aritmética
[ENSURE] Tentando garantir 't27' em um registrador.
[ENSURE] -> Sucesso! 't27' já está em r17.
[ENSURE] Tentando garantir 'i' em um registrador.
[ENSURE] -> Sucesso! 'i' já está em r15.
[GET_TEMP] Solicitando registrador para o temporário 't28'.
[GET_FREE] -> Encontrado registrador livre: r19. Restantes: 13.
[ASSIGN_REG] Mapeando 't28' para r19.
[GET_TEMP] -> 't28' alocado no registrador r19.
[ADD_INSTR] Adicionando instrução para 'main': add: r19 = r17, r15
[FREE_TEMP] Liberando registrador r17 que continha o temporário 't27'.
[UNASSIGN_REG] Desmapeado r17 de 't27'.
[UNASSIGN_REG] -> Estado atual: 14 registradores livres. Mapeamentos: {'i': 'r15', 't28': 'r19'}

--- [TRANSLATE] Processando IR: t29 := *t28 ---
[TRANSLATE] -> Detalhes: Destino='t29', Expressão='*t28'
[TRANSLATE] -> Caminho: Carregar de Ponteiro (*)
[TRANSLATE] -> Ponteiro é uma temporária ('t28'). Usando seu valor como endereço.
[ENSURE] Tentando garantir 't28' em um registrador.
[ENSURE] -> Sucesso! 't28' já está em r19.
[GET_TEMP] Solicitando registrador para o temporário 't29'.
[GET_FREE] -> Encontrado registrador livre: r20. Restantes: 13.
[ASSIGN_REG] Mapeando 't29' para r20.
[GET_TEMP] -> 't29' alocado no registrador r20.
[ADD_INSTR] Adicionando instrução para 'main': load: r20 = [r19]
[FREE_TEMP] Liberando registrador r19 que continha o temporário 't28'.
[UNASSIGN_REG] Desmapeado r19 de 't28'.
[UNASSIGN_REG] -> Estado atual: 14 registradores livres. Mapeamentos: {'i': 'r15', 't29': 'r20'}

--- [TRANSLATE] Processando IR: arg t29 ---
[TRANSLATE] -> Caminho: Passagem de Argumento (arg 1)
[ENSURE] Tentando garantir 't29' em um registrador.
[ENSURE] -> Sucesso! 't29' já está em r20.
[ADD_INSTR] Adicionando instrução para 'main': mov: r1 = r20

--- [TRANSLATE] Processando IR: call output, 1 ---
[TRANSLATE] -> Caminho: Chamada de Procedimento
[SPILL_ALL] Verificando registradores sujos para salvar. Sujos: {'r7', 'r20', 'r17', 'r9', 'r19', 'r6'}
[ADD_INSTR] Adicionando instrução para 'main': out: r1
[UNASSIGN_REG] Desmapeado r20 de 't29'.
[UNASSIGN_REG] -> Estado atual: 15 registradores livres. Mapeamentos: {'i': 'r15'}

--- [TRANSLATE] Processando IR: t30 := i + 1 ---
[TRANSLATE] -> Detalhes: Destino='t30', Expressão='i + 1'
[TRANSLATE] -> Caminho: Operação Aritmética
[ENSURE] Tentando garantir 'i' em um registrador.
[ENSURE] -> Sucesso! 'i' já está em r15.
[TRANSLATE] -> Operando 2 é um imediato: 1
[GET_TEMP] Solicitando registrador para o temporário 't30'.
[GET_FREE] -> Encontrado registrador livre: r21. Restantes: 14.
[ASSIGN_REG] Mapeando 't30' para r21.
[GET_TEMP] -> 't30' alocado no registrador r21.
[ADD_INSTR] Adicionando instrução para 'main': addi: r21 = r15, 1

--- [TRANSLATE] Processando IR: i := t30 ---
[TRANSLATE] -> Detalhes: Destino='i', Expressão='t30'
[TRANSLATE] -> Caminho: Atribuição Simples
[ENSURE] Tentando garantir 't30' em um registrador.
[ENSURE] -> Sucesso! 't30' já está em r21.
[TRANSLATE_ASSIGN] -> Armazenando 'i' na sua posição da pilha.
[ADD_INSTR] Adicionando instrução para 'main': subi: r30 = r31, 2
[ADD_INSTR] Adicionando instrução para 'main': store: [r30] = r21
[UPDATE_MAP] Mapeando 'i' para o registrador r21 (que contém o valor de origem).
[ASSIGN_REG] Mapeando 'i' para r21.
[ASSIGN_REG] -> Variável 'i' já estava em r15. Liberando o mapeamento antigo.
[UNASSIGN_REG] Desmapeado r15 de 'i'.
[UNASSIGN_REG] -> Estado atual: 15 registradores livres. Mapeamentos: {'t30': 'r21'}
[ASSIGN_REG] -> Registrador r21 já continha 't30'. Liberando o mapeamento antigo.
[UNASSIGN_REG] Desmapeado r21 de 't30'.
[UNASSIGN_REG] -> Estado atual: 16 registradores livres. Mapeamentos: {}

--- [TRANSLATE] Processando IR: goto L8 ---
[TRANSLATE_SKIP] -> Ignorando 'goto' redundante após um 'goto'.

--- [TRANSLATE] Processando IR: L9: ---
[TRANSLATE] -> Rótulo detectado: L9:
[SPILL_ALL] Verificando registradores sujos para salvar. Sujos: {'r7', 'r17', 'r9', 'r19', 'r21', 'r6'}
[SPILL_ALL] -> Salvando variável local 'i' do registrador r21 na pilha [fp, #-2].
[ADD_INSTR] Adicionando instrução para 'main': subi: r30 = r31, 2
[ADD_INSTR] Adicionando instrução para 'main': store: [r30] = r21
[ADD_INSTR] Adicionando instrução para 'main': L9:

--- [TRANSLATE] Processando IR: return _ ---
[TRANSLATE] -> Caminho: Retorno de Função
[SPILL_ALL] Verificando registradores sujos para salvar. Sujos: {'r7', 'r17', 'r9', 'r19', 'r6'}
[TRANSLATE] -> Pular para a seção de epílogo.
[ADD_INSTR] Adicionando instrução para 'main': bi: main_epilogue
-> Finalizando a função 'main', fazendo spill de todos os registradores sujos.
[SPILL_ALL] Verificando registradores sujos para salvar. Sujos: {'r7', 'r17', 'r9', 'r19', 'r6'}
--- Fim da Passagem 2 ---

--- Montagem Final: Construindo o arquivo assembly completo ---
[Montagem] Processando função 'minloc' com 55 instruções.
[Montagem] Processando função 'sort' com 50 instruções.
[Montagem] Processando função 'main' com 51 instruções.
[Montagem] Adicionando a seção .data.
[Montagem] -> Variáveis a serem declaradas: ['vet']
=== GERAÇÃO DE ASSEMBLY CONCLUÍDA ===
--- ASSEMBLY CODE READY FOR YOUR ASSEMBLER ---
.text
.global main

	bi: main
minloc:
	subi: r29 = r29, 1
	store: [r29] = r28
	subi: r29 = r29, 1
	store: [r29] = r31
	mov: r31 = r29
	subi: r29 = r29, 16
	subi: r30 = r31, 1
	store: [r30] = r1
	subi: r30 = r31, 2
	store: [r30] = r2
	subi: r30 = r31, 3
	store: [r30] = r3
	subi: r30 = r31, 3
	load: r4 = [r30]
	subi: r30 = r31, 5
	store: [r30] = r4
	subi: r30 = r31, 2
	load: r5 = [r30]
	subi: r30 = r31, 3
	load: r6 = [r30]
	add: r7 = r5, r6
	load: r8 = [r7]
	subi: r30 = r31, 6
	store: [r30] = r8
	addi: r9 = r6, 1
	subi: r30 = r31, 4
	store: [r30] = r9
	subi: r30 = r31, 4
	store: [r30] = r9
	subi: r30 = r31, 6
	store: [r30] = r8
L0:
	subi: r30 = r31, 1
	load: r10 = [r30]
	subs: r0 = r9, r10
	bigteq: L1
	add: r11 = r5, r9
	load: r12 = [r11]
	subs: r0 = r12, r8
	bigteq: L2
	add: r13 = r5, r9
	load: r14 = [r13]
	subi: r30 = r31, 6
	store: [r30] = r14
	subi: r30 = r31, 5
	store: [r30] = r9
	subi: r30 = r31, 6
	store: [r30] = r14
	bi: L3
L2:
L3:
	subi: r30 = r31, 4
	load: r15 = [r30]
	addi: r16 = r15, 1
	subi: r30 = r31, 4
	store: [r30] = r16
	subi: r30 = r31, 4
	store: [r30] = r16
L1:
	mov: r0 = r9
	bi: minloc_epilogue
minloc_epilogue:
	mov: r29 = r31
	load: r31 = [r29]
	addi: r29 = r29, 1
	load: r28 = [r29]
	addi: r29 = r29, 1
	b: r28

sort:
	subi: r29 = r29, 1
	store: [r29] = r28
	subi: r29 = r29, 1
	store: [r29] = r31
	mov: r31 = r29
	subi: r29 = r29, 15
	subi: r30 = r31, 1
	store: [r30] = r1
	subi: r30 = r31, 2
	store: [r30] = r2
	subi: r30 = r31, 3
	store: [r30] = r3
	subi: r30 = r31, 3
	load: r4 = [r30]
	subi: r30 = r31, 4
	store: [r30] = r4
L4:
	subi: r30 = r31, 1
	load: r5 = [r30]
	subi: r6 = r5, 1
	subs: r0 = r4, r6
	bigteq: L5
	subi: r30 = r31, 2
	load: r7 = [r30]
	mov: r1 = r7
	mov: r2 = r4
	mov: r3 = r5
	movi: r8 = sort_Lret0
	mov: r28 = r8
	bl: minloc
sort_Lret0:
	mov: r9 = r0
	subi: r30 = r31, 5
	store: [r30] = r9
	subi: r30 = r31, 2
	load: r10 = [r30]
	add: r11 = r10, r9
	load: r12 = [r11]
	subi: r30 = r31, 4
	load: r13 = [r30]
	add: r14 = r10, r13
	load: r15 = [r14]
	add: r16 = r10, r9
	store: [r16] = r15
	add: r17 = r10, r13
	store: [r17] = r18
	addi: r19 = r13, 1
	subi: r30 = r31, 4
	store: [r30] = r19
	subi: r30 = r31, 5
	store: [r30] = r9
	subi: r30 = r31, 4
	store: [r30] = r19
	bi: L4
L5:
	bi: sort_epilogue
sort_epilogue:
	mov: r29 = r31
	load: r31 = [r29]
	addi: r29 = r29, 1
	load: r28 = [r29]
	addi: r29 = r29, 1
	b: r28

main:
	movi: r29 = 255
	mov: r31 = r29
	subi: r29 = r29, 13
	subi: r30 = r31, 1
	store: [r30] = r1
	movi: r4 = 0
	subi: r30 = r31, 2
	store: [r30] = r4
L6:
	movi: r5 = 2
	subs: r0 = r4, r5
	bigteq: L7
	in: r6
	subi: r8 = r31, 1
	mov: r7 = r8
	add: r9 = r7, r4
	store: [r9] = r6
	addi: r10 = r4, 1
	subi: r30 = r31, 2
	store: [r30] = r10
	subi: r30 = r31, 2
	store: [r30] = r10
	bi: L6
L7:
	subi: r12 = r31, 1
	mov: r11 = r12
	mov: r1 = r11
	movi: r13 = 0
	mov: r2 = r13
	movi: r14 = 2
	mov: r3 = r14
	movi: r28 = main_Lret0
	bl: sort
main_Lret0:
	movi: r15 = 0
	subi: r30 = r31, 2
	store: [r30] = r15
L8:
	movi: r16 = 2
	subs: r0 = r15, r16
	bigteq: L9
	subi: r18 = r31, 1
	mov: r17 = r18
	add: r19 = r17, r15
	load: r20 = [r19]
	mov: r1 = r20
	out: r1
	addi: r21 = r15, 1
	subi: r30 = r31, 2
	store: [r30] = r21
	subi: r30 = r31, 2
	store: [r30] = r21
L9:
	bi: main_epilogue
main_epilogue:
	ret:

.data
stack_space: .space 256
var_vet: .space 2
---------------------------------------------


=== INICIANDO PROCESSO DE MONTAGEM (FullCode) ===
[INIT] Executando a primeira passagem para construir a tabela de símbolos...

--- [PASS 1] Iniciando a Primeira Passagem ---
[PASS 1] Etapa 1: Prevendo o tamanho de cada instrução na seção .text...

[DEBUG PASS 1] Tabela de Símbolos Final:
{
  "output": 1
}
--- Fim do Debug ---


[PASS 1] Etapa 2: Mapeando os rótulos de código para endereços...
[PASS 1] -> Rótulo 'minloc' mapeado para o endereço 1.
[PASS 1] -> Rótulo 'L0' mapeado para o endereço 32.
[PASS 1] -> Rótulo 'L2' mapeado para o endereço 49.
[PASS 1] -> Rótulo 'L3' mapeado para o endereço 49.
[PASS 1] -> Rótulo 'L1' mapeado para o endereço 56.
[PASS 1] -> Rótulo 'minloc_epilogue' mapeado para o endereço 58.
[PASS 1] -> Rótulo 'sort' mapeado para o endereço 64.
[PASS 1] -> Rótulo 'L4' mapeado para o endereço 80.
[PASS 1] -> Rótulo 'sort_Lret0' mapeado para o endereço 93.
[PASS 1] -> Rótulo 'L5' mapeado para o endereço 116.
[PASS 1] -> Rótulo 'sort_epilogue' mapeado para o endereço 117.
[PASS 1] -> Rótulo 'main' mapeado para o endereço 123.
[PASS 1] -> Rótulo 'L6' mapeado para o endereço 131.
[PASS 1] -> Rótulo 'L7' mapeado para o endereço 145.
[PASS 1] -> Rótulo 'main_Lret0' mapeado para o endereço 154.
[PASS 1] -> Rótulo 'L8' mapeado para o endereço 157.
[PASS 1] -> Rótulo 'L9' mapeado para o endereço 171.
[PASS 1] -> Rótulo 'main_epilogue' mapeado para o endereço 172.

[PASS 1] Etapa 3: A seção de código termina no endereço 172. A seção .data começará em [0].

[PASS 1] Etapa 4: Mapeando os rótulos da seção .data...
[PASS 1] -> Rótulo de dados 'stack_space' mapeado para o endereço 0.
[PASS 1] -> Rótulo de dados 'var_vet' mapeado para o endereço 256.
--- Fim da Primeira Passagem ---
[INIT] Tabela de símbolos após a primeira passagem: {'output': 1, 'minloc': 1, 'L0': 32, 'L2': 49, 'L3': 49, 'L1': 56, 'minloc_epilogue': 58, 'sort': 64, 'L4': 80, 'sort_Lret0': 93, 'L5': 116, 'sort_epilogue': 117, 'main': 123, 'L6': 131, 'L7': 145, 'main_Lret0': 154, 'L8': 157, 'L9': 171, 'main_epilogue': 172, 'stack_space': 0, 'var_vet': 256}
[INIT] Executando a segunda passagem para codificar as instruções...

--- [PASS 2] Iniciando a Segunda Passagem ---
[PASS 2] Etapa 1: Coletando literais grandes e atribuindo endereços a eles...
[PASS 2] -> Linha 9 ('mov: r31 = r29') é uma instrução 'mov' sem imediato. Ignorando para literais.
[PASS 2] -> Linha 64 ('mov: r0 = r9') é uma instrução 'mov' sem imediato. Ignorando para literais.
[PASS 2] -> Linha 67 ('mov: r29 = r31') é uma instrução 'mov' sem imediato. Ignorando para literais.
[PASS 2] -> Linha 78 ('mov: r31 = r29') é uma instrução 'mov' sem imediato. Ignorando para literais.
[PASS 2] -> Linha 98 ('mov: r1 = r7') é uma instrução 'mov' sem imediato. Ignorando para literais.
[PASS 2] -> Linha 99 ('mov: r2 = r4') é uma instrução 'mov' sem imediato. Ignorando para literais.
[PASS 2] -> Linha 100 ('mov: r3 = r5') é uma instrução 'mov' sem imediato. Ignorando para literais.
[PASS 2] -> Linha 102 ('mov: r28 = r8') é uma instrução 'mov' sem imediato. Ignorando para literais.
[PASS 2] -> Linha 105 ('mov: r9 = r0') é uma instrução 'mov' sem imediato. Ignorando para literais.
[PASS 2] -> Linha 131 ('mov: r29 = r31') é uma instrução 'mov' sem imediato. Ignorando para literais.
[PASS 2] -> Linha 139 ('mov: r31 = r29') é uma instrução 'mov' sem imediato. Ignorando para literais.
[PASS 2] -> Linha 152 ('mov: r7 = r8') é uma instrução 'mov' sem imediato. Ignorando para literais.
[PASS 2] -> Linha 163 ('mov: r11 = r12') é uma instrução 'mov' sem imediato. Ignorando para literais.
[PASS 2] -> Linha 164 ('mov: r1 = r11') é uma instrução 'mov' sem imediato. Ignorando para literais.
[PASS 2] -> Linha 166 ('mov: r2 = r13') é uma instrução 'mov' sem imediato. Ignorando para literais.
[PASS 2] -> Linha 168 ('mov: r3 = r14') é uma instrução 'mov' sem imediato. Ignorando para literais.
[PASS 2] -> Linha 180 ('mov: r17 = r18') é uma instrução 'mov' sem imediato. Ignorando para literais.
[PASS 2] -> Linha 183 ('mov: r1 = r20') é uma instrução 'mov' sem imediato. Ignorando para literais.
[PASS 2] -> Linha 184 ('out: r1') é uma instrução 'out'. Ignorando para literais.
[PASS 2] -> Nenhum literal grande encontrado.

[PASS 2] Etapa 2: Codificando cada linha de instrução para binário...

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'bi: main' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'bi: main'
[DISASSEMBLE] -> Parte do opcode: 'bi', Parte dos operandos: 'main'
[DISASSEMBLE] -> Instrução de branch identificada: 'bi'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'i', 'opcode': 'b', 'type': '11', 'op2': 'main'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'b', 'type': '11', 'op2': 'main'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'b', 'type': '11', 'op2': 'main'}
[ENCODE] -> Instrução de branch detectada: b com condição do
[INSTRUCTION] -> Codificação concluída. Binário: 00001110000000000000000001111010

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'subi: r29 = r29, 1' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'subi: r29 = r29, 1'
[DISASSEMBLE] -> Parte do opcode: 'subi', Parte dos operandos: 'r29 = r29, 1'
[DISASSEMBLE] -> Sufixo de suporte encontrado: 'i'. Opcode final é 'sub'
[DISASSEMBLE] -> Opcode final: 'sub', Tipo: 00
[DISASSEMBLE] -> Instrução com atribuição. Destino: 'r29', Origem: 'r29, 1'
[DISASSEMBLE] -> Operandos finais: Rd='r29', Rh='r29', Op2='1'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'i', 'opcode': 'sub', 'type': '00', 'rd': 'r29', 'rh': 'r29', 'op2': '1'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'sub', 'type': '00', 'rd': 'r29', 'rh': 'r29', 'op2': '1'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'sub', 'type': '00', 'rd': 'r29', 'rh': 'r29', 'op2': '1'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000010000111101111010000000001

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'store: [r29] = r28' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'store: [r29] = r28'
[DISASSEMBLE] -> Parte do opcode: 'store', Parte dos operandos: '[r29] = r28'
[DISASSEMBLE] -> Opcode final: 'store', Tipo: 01
[DISASSEMBLE] -> Instrução Store com endereçamento por registrador. Dest detectado: [r29]. Source detectado: 'r28'
[DISASSEMBLE] -> Instrução Load/Store com endereçamento por registrador.
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'na', 'opcode': 'store', 'type': '01', 'rd': 'r0', 'op2': 'r29', 'rh': 'r28'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'store', 'type': '01', 'rd': 'r0', 'op2': 'r29', 'rh': 'r28'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'store', 'type': '01', 'rd': 'r0', 'op2': 'r29', 'rh': 'r28'}
[ENCODE] -> Instrução Store detectada.
[ENCODE] -> rd_bin, rh_bin calculados: Rd(r0)=:00000 e Rh(r28)=:11100
[ENCODE] -> Op2 é um registrador: r29, convertido para binário: 1110100000
[INSTRUCTION] -> Codificação concluída. Binário: 00000100000000000111001110100000

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'subi: r29 = r29, 1' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'subi: r29 = r29, 1'
[DISASSEMBLE] -> Parte do opcode: 'subi', Parte dos operandos: 'r29 = r29, 1'
[DISASSEMBLE] -> Sufixo de suporte encontrado: 'i'. Opcode final é 'sub'
[DISASSEMBLE] -> Opcode final: 'sub', Tipo: 00
[DISASSEMBLE] -> Instrução com atribuição. Destino: 'r29', Origem: 'r29, 1'
[DISASSEMBLE] -> Operandos finais: Rd='r29', Rh='r29', Op2='1'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'i', 'opcode': 'sub', 'type': '00', 'rd': 'r29', 'rh': 'r29', 'op2': '1'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'sub', 'type': '00', 'rd': 'r29', 'rh': 'r29', 'op2': '1'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'sub', 'type': '00', 'rd': 'r29', 'rh': 'r29', 'op2': '1'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000010000111101111010000000001

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'store: [r29] = r31' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'store: [r29] = r31'
[DISASSEMBLE] -> Parte do opcode: 'store', Parte dos operandos: '[r29] = r31'
[DISASSEMBLE] -> Opcode final: 'store', Tipo: 01
[DISASSEMBLE] -> Instrução Store com endereçamento por registrador. Dest detectado: [r29]. Source detectado: 'r31'
[DISASSEMBLE] -> Instrução Load/Store com endereçamento por registrador.
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'na', 'opcode': 'store', 'type': '01', 'rd': 'r0', 'op2': 'r29', 'rh': 'r31'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'store', 'type': '01', 'rd': 'r0', 'op2': 'r29', 'rh': 'r31'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'store', 'type': '01', 'rd': 'r0', 'op2': 'r29', 'rh': 'r31'}
[ENCODE] -> Instrução Store detectada.
[ENCODE] -> rd_bin, rh_bin calculados: Rd(r0)=:00000 e Rh(r31)=:11111
[ENCODE] -> Op2 é um registrador: r29, convertido para binário: 1110100000
[INSTRUCTION] -> Codificação concluída. Binário: 00000100000000000111111110100000

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'mov: r31 = r29' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'mov: r31 = r29'
[DISASSEMBLE] -> Parte do opcode: 'mov', Parte dos operandos: 'r31 = r29'
[DISASSEMBLE] -> Opcode final: 'mov', Tipo: 00
[DISASSEMBLE] -> Instrução 'mov' identificada. Destino: 'r31', Origem: 'r29'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'na', 'opcode': 'mov', 'type': '00', 'rd': 'r31', 'rh': 'r0', 'op2': 'r29'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'mov', 'type': '00', 'rd': 'r31', 'rh': 'r0', 'op2': 'r29'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'mov', 'type': '00', 'rd': 'r31', 'rh': 'r0', 'op2': 'r29'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000000100011111000001110100000

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'subi: r29 = r29, 16' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'subi: r29 = r29, 16'
[DISASSEMBLE] -> Parte do opcode: 'subi', Parte dos operandos: 'r29 = r29, 16'
[DISASSEMBLE] -> Sufixo de suporte encontrado: 'i'. Opcode final é 'sub'
[DISASSEMBLE] -> Opcode final: 'sub', Tipo: 00
[DISASSEMBLE] -> Instrução com atribuição. Destino: 'r29', Origem: 'r29, 16'
[DISASSEMBLE] -> Operandos finais: Rd='r29', Rh='r29', Op2='16'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'i', 'opcode': 'sub', 'type': '00', 'rd': 'r29', 'rh': 'r29', 'op2': '16'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'sub', 'type': '00', 'rd': 'r29', 'rh': 'r29', 'op2': '16'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'sub', 'type': '00', 'rd': 'r29', 'rh': 'r29', 'op2': '16'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000010000111101111010000010000

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'subi: r30 = r31, 1' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'subi: r30 = r31, 1'
[DISASSEMBLE] -> Parte do opcode: 'subi', Parte dos operandos: 'r30 = r31, 1'
[DISASSEMBLE] -> Sufixo de suporte encontrado: 'i'. Opcode final é 'sub'
[DISASSEMBLE] -> Opcode final: 'sub', Tipo: 00
[DISASSEMBLE] -> Instrução com atribuição. Destino: 'r30', Origem: 'r31, 1'
[DISASSEMBLE] -> Operandos finais: Rd='r30', Rh='r31', Op2='1'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'i', 'opcode': 'sub', 'type': '00', 'rd': 'r30', 'rh': 'r31', 'op2': '1'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'sub', 'type': '00', 'rd': 'r30', 'rh': 'r31', 'op2': '1'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'sub', 'type': '00', 'rd': 'r30', 'rh': 'r31', 'op2': '1'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000010000111110111110000000001

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'store: [r30] = r1' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'store: [r30] = r1'
[DISASSEMBLE] -> Parte do opcode: 'store', Parte dos operandos: '[r30] = r1'
[DISASSEMBLE] -> Opcode final: 'store', Tipo: 01
[DISASSEMBLE] -> Instrução Store com endereçamento por registrador. Dest detectado: [r30]. Source detectado: 'r1'
[DISASSEMBLE] -> Instrução Load/Store com endereçamento por registrador.
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'na', 'opcode': 'store', 'type': '01', 'rd': 'r0', 'op2': 'r30', 'rh': 'r1'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'store', 'type': '01', 'rd': 'r0', 'op2': 'r30', 'rh': 'r1'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'store', 'type': '01', 'rd': 'r0', 'op2': 'r30', 'rh': 'r1'}
[ENCODE] -> Instrução Store detectada.
[ENCODE] -> rd_bin, rh_bin calculados: Rd(r0)=:00000 e Rh(r1)=:00001
[ENCODE] -> Op2 é um registrador: r30, convertido para binário: 1111000000
[INSTRUCTION] -> Codificação concluída. Binário: 00000100000000000000011111000000

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'subi: r30 = r31, 2' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'subi: r30 = r31, 2'
[DISASSEMBLE] -> Parte do opcode: 'subi', Parte dos operandos: 'r30 = r31, 2'
[DISASSEMBLE] -> Sufixo de suporte encontrado: 'i'. Opcode final é 'sub'
[DISASSEMBLE] -> Opcode final: 'sub', Tipo: 00
[DISASSEMBLE] -> Instrução com atribuição. Destino: 'r30', Origem: 'r31, 2'
[DISASSEMBLE] -> Operandos finais: Rd='r30', Rh='r31', Op2='2'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'i', 'opcode': 'sub', 'type': '00', 'rd': 'r30', 'rh': 'r31', 'op2': '2'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'sub', 'type': '00', 'rd': 'r30', 'rh': 'r31', 'op2': '2'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'sub', 'type': '00', 'rd': 'r30', 'rh': 'r31', 'op2': '2'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000010000111110111110000000010

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'store: [r30] = r2' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'store: [r30] = r2'
[DISASSEMBLE] -> Parte do opcode: 'store', Parte dos operandos: '[r30] = r2'
[DISASSEMBLE] -> Opcode final: 'store', Tipo: 01
[DISASSEMBLE] -> Instrução Store com endereçamento por registrador. Dest detectado: [r30]. Source detectado: 'r2'
[DISASSEMBLE] -> Instrução Load/Store com endereçamento por registrador.
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'na', 'opcode': 'store', 'type': '01', 'rd': 'r0', 'op2': 'r30', 'rh': 'r2'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'store', 'type': '01', 'rd': 'r0', 'op2': 'r30', 'rh': 'r2'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'store', 'type': '01', 'rd': 'r0', 'op2': 'r30', 'rh': 'r2'}
[ENCODE] -> Instrução Store detectada.
[ENCODE] -> rd_bin, rh_bin calculados: Rd(r0)=:00000 e Rh(r2)=:00010
[ENCODE] -> Op2 é um registrador: r30, convertido para binário: 1111000000
[INSTRUCTION] -> Codificação concluída. Binário: 00000100000000000000101111000000

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'subi: r30 = r31, 3' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'subi: r30 = r31, 3'
[DISASSEMBLE] -> Parte do opcode: 'subi', Parte dos operandos: 'r30 = r31, 3'
[DISASSEMBLE] -> Sufixo de suporte encontrado: 'i'. Opcode final é 'sub'
[DISASSEMBLE] -> Opcode final: 'sub', Tipo: 00
[DISASSEMBLE] -> Instrução com atribuição. Destino: 'r30', Origem: 'r31, 3'
[DISASSEMBLE] -> Operandos finais: Rd='r30', Rh='r31', Op2='3'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'i', 'opcode': 'sub', 'type': '00', 'rd': 'r30', 'rh': 'r31', 'op2': '3'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'sub', 'type': '00', 'rd': 'r30', 'rh': 'r31', 'op2': '3'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'sub', 'type': '00', 'rd': 'r30', 'rh': 'r31', 'op2': '3'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000010000111110111110000000011

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'store: [r30] = r3' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'store: [r30] = r3'
[DISASSEMBLE] -> Parte do opcode: 'store', Parte dos operandos: '[r30] = r3'
[DISASSEMBLE] -> Opcode final: 'store', Tipo: 01
[DISASSEMBLE] -> Instrução Store com endereçamento por registrador. Dest detectado: [r30]. Source detectado: 'r3'
[DISASSEMBLE] -> Instrução Load/Store com endereçamento por registrador.
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'na', 'opcode': 'store', 'type': '01', 'rd': 'r0', 'op2': 'r30', 'rh': 'r3'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'store', 'type': '01', 'rd': 'r0', 'op2': 'r30', 'rh': 'r3'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'store', 'type': '01', 'rd': 'r0', 'op2': 'r30', 'rh': 'r3'}
[ENCODE] -> Instrução Store detectada.
[ENCODE] -> rd_bin, rh_bin calculados: Rd(r0)=:00000 e Rh(r3)=:00011
[ENCODE] -> Op2 é um registrador: r30, convertido para binário: 1111000000
[INSTRUCTION] -> Codificação concluída. Binário: 00000100000000000000111111000000

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'subi: r30 = r31, 3' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'subi: r30 = r31, 3'
[DISASSEMBLE] -> Parte do opcode: 'subi', Parte dos operandos: 'r30 = r31, 3'
[DISASSEMBLE] -> Sufixo de suporte encontrado: 'i'. Opcode final é 'sub'
[DISASSEMBLE] -> Opcode final: 'sub', Tipo: 00
[DISASSEMBLE] -> Instrução com atribuição. Destino: 'r30', Origem: 'r31, 3'
[DISASSEMBLE] -> Operandos finais: Rd='r30', Rh='r31', Op2='3'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'i', 'opcode': 'sub', 'type': '00', 'rd': 'r30', 'rh': 'r31', 'op2': '3'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'sub', 'type': '00', 'rd': 'r30', 'rh': 'r31', 'op2': '3'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'sub', 'type': '00', 'rd': 'r30', 'rh': 'r31', 'op2': '3'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000010000111110111110000000011

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'load: r4 = [r30]' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'load: r4 = [r30]'
[DISASSEMBLE] -> Parte do opcode: 'load', Parte dos operandos: 'r4 = [r30]'
[DISASSEMBLE] -> Opcode final: 'load', Tipo: 01
[DISASSEMBLE] -> Instrução Load/Store com endereçamento por registrador.
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'na', 'opcode': 'load', 'type': '01', 'rd': 'r4', 'rh': 'r0', 'op2': 'r30'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'load', 'type': '01', 'rd': 'r4', 'rh': 'r0', 'op2': 'r30'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'load', 'type': '01', 'rd': 'r4', 'rh': 'r0', 'op2': 'r30'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000100000100100000001111000000

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'subi: r30 = r31, 5' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'subi: r30 = r31, 5'
[DISASSEMBLE] -> Parte do opcode: 'subi', Parte dos operandos: 'r30 = r31, 5'
[DISASSEMBLE] -> Sufixo de suporte encontrado: 'i'. Opcode final é 'sub'
[DISASSEMBLE] -> Opcode final: 'sub', Tipo: 00
[DISASSEMBLE] -> Instrução com atribuição. Destino: 'r30', Origem: 'r31, 5'
[DISASSEMBLE] -> Operandos finais: Rd='r30', Rh='r31', Op2='5'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'i', 'opcode': 'sub', 'type': '00', 'rd': 'r30', 'rh': 'r31', 'op2': '5'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'sub', 'type': '00', 'rd': 'r30', 'rh': 'r31', 'op2': '5'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'sub', 'type': '00', 'rd': 'r30', 'rh': 'r31', 'op2': '5'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000010000111110111110000000101

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'store: [r30] = r4' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'store: [r30] = r4'
[DISASSEMBLE] -> Parte do opcode: 'store', Parte dos operandos: '[r30] = r4'
[DISASSEMBLE] -> Opcode final: 'store', Tipo: 01
[DISASSEMBLE] -> Instrução Store com endereçamento por registrador. Dest detectado: [r30]. Source detectado: 'r4'
[DISASSEMBLE] -> Instrução Load/Store com endereçamento por registrador.
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'na', 'opcode': 'store', 'type': '01', 'rd': 'r0', 'op2': 'r30', 'rh': 'r4'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'store', 'type': '01', 'rd': 'r0', 'op2': 'r30', 'rh': 'r4'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'store', 'type': '01', 'rd': 'r0', 'op2': 'r30', 'rh': 'r4'}
[ENCODE] -> Instrução Store detectada.
[ENCODE] -> rd_bin, rh_bin calculados: Rd(r0)=:00000 e Rh(r4)=:00100
[ENCODE] -> Op2 é um registrador: r30, convertido para binário: 1111000000
[INSTRUCTION] -> Codificação concluída. Binário: 00000100000000000001001111000000

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'subi: r30 = r31, 2' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'subi: r30 = r31, 2'
[DISASSEMBLE] -> Parte do opcode: 'subi', Parte dos operandos: 'r30 = r31, 2'
[DISASSEMBLE] -> Sufixo de suporte encontrado: 'i'. Opcode final é 'sub'
[DISASSEMBLE] -> Opcode final: 'sub', Tipo: 00
[DISASSEMBLE] -> Instrução com atribuição. Destino: 'r30', Origem: 'r31, 2'
[DISASSEMBLE] -> Operandos finais: Rd='r30', Rh='r31', Op2='2'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'i', 'opcode': 'sub', 'type': '00', 'rd': 'r30', 'rh': 'r31', 'op2': '2'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'sub', 'type': '00', 'rd': 'r30', 'rh': 'r31', 'op2': '2'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'sub', 'type': '00', 'rd': 'r30', 'rh': 'r31', 'op2': '2'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000010000111110111110000000010

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'load: r5 = [r30]' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'load: r5 = [r30]'
[DISASSEMBLE] -> Parte do opcode: 'load', Parte dos operandos: 'r5 = [r30]'
[DISASSEMBLE] -> Opcode final: 'load', Tipo: 01
[DISASSEMBLE] -> Instrução Load/Store com endereçamento por registrador.
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'na', 'opcode': 'load', 'type': '01', 'rd': 'r5', 'rh': 'r0', 'op2': 'r30'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'load', 'type': '01', 'rd': 'r5', 'rh': 'r0', 'op2': 'r30'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'load', 'type': '01', 'rd': 'r5', 'rh': 'r0', 'op2': 'r30'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000100000100101000001111000000

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'subi: r30 = r31, 3' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'subi: r30 = r31, 3'
[DISASSEMBLE] -> Parte do opcode: 'subi', Parte dos operandos: 'r30 = r31, 3'
[DISASSEMBLE] -> Sufixo de suporte encontrado: 'i'. Opcode final é 'sub'
[DISASSEMBLE] -> Opcode final: 'sub', Tipo: 00
[DISASSEMBLE] -> Instrução com atribuição. Destino: 'r30', Origem: 'r31, 3'
[DISASSEMBLE] -> Operandos finais: Rd='r30', Rh='r31', Op2='3'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'i', 'opcode': 'sub', 'type': '00', 'rd': 'r30', 'rh': 'r31', 'op2': '3'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'sub', 'type': '00', 'rd': 'r30', 'rh': 'r31', 'op2': '3'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'sub', 'type': '00', 'rd': 'r30', 'rh': 'r31', 'op2': '3'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000010000111110111110000000011

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'load: r6 = [r30]' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'load: r6 = [r30]'
[DISASSEMBLE] -> Parte do opcode: 'load', Parte dos operandos: 'r6 = [r30]'
[DISASSEMBLE] -> Opcode final: 'load', Tipo: 01
[DISASSEMBLE] -> Instrução Load/Store com endereçamento por registrador.
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'na', 'opcode': 'load', 'type': '01', 'rd': 'r6', 'rh': 'r0', 'op2': 'r30'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'load', 'type': '01', 'rd': 'r6', 'rh': 'r0', 'op2': 'r30'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'load', 'type': '01', 'rd': 'r6', 'rh': 'r0', 'op2': 'r30'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000100000100110000001111000000

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'add: r7 = r5, r6' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'add: r7 = r5, r6'
[DISASSEMBLE] -> Parte do opcode: 'add', Parte dos operandos: 'r7 = r5, r6'
[DISASSEMBLE] -> Opcode final: 'add', Tipo: 00
[DISASSEMBLE] -> Instrução com atribuição. Destino: 'r7', Origem: 'r5, r6'
[DISASSEMBLE] -> Operandos finais: Rd='r7', Rh='r5', Op2='r6'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'na', 'opcode': 'add', 'type': '00', 'rd': 'r7', 'rh': 'r5', 'op2': 'r6'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'add', 'type': '00', 'rd': 'r7', 'rh': 'r5', 'op2': 'r6'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'add', 'type': '00', 'rd': 'r7', 'rh': 'r5', 'op2': 'r6'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000000000000111001010011000000

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'load: r8 = [r7]' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'load: r8 = [r7]'
[DISASSEMBLE] -> Parte do opcode: 'load', Parte dos operandos: 'r8 = [r7]'
[DISASSEMBLE] -> Opcode final: 'load', Tipo: 01
[DISASSEMBLE] -> Instrução Load/Store com endereçamento por registrador.
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'na', 'opcode': 'load', 'type': '01', 'rd': 'r8', 'rh': 'r0', 'op2': 'r7'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'load', 'type': '01', 'rd': 'r8', 'rh': 'r0', 'op2': 'r7'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'load', 'type': '01', 'rd': 'r8', 'rh': 'r0', 'op2': 'r7'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000100000101000000000011100000

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'subi: r30 = r31, 6' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'subi: r30 = r31, 6'
[DISASSEMBLE] -> Parte do opcode: 'subi', Parte dos operandos: 'r30 = r31, 6'
[DISASSEMBLE] -> Sufixo de suporte encontrado: 'i'. Opcode final é 'sub'
[DISASSEMBLE] -> Opcode final: 'sub', Tipo: 00
[DISASSEMBLE] -> Instrução com atribuição. Destino: 'r30', Origem: 'r31, 6'
[DISASSEMBLE] -> Operandos finais: Rd='r30', Rh='r31', Op2='6'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'i', 'opcode': 'sub', 'type': '00', 'rd': 'r30', 'rh': 'r31', 'op2': '6'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'sub', 'type': '00', 'rd': 'r30', 'rh': 'r31', 'op2': '6'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'sub', 'type': '00', 'rd': 'r30', 'rh': 'r31', 'op2': '6'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000010000111110111110000000110

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'store: [r30] = r8' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'store: [r30] = r8'
[DISASSEMBLE] -> Parte do opcode: 'store', Parte dos operandos: '[r30] = r8'
[DISASSEMBLE] -> Opcode final: 'store', Tipo: 01
[DISASSEMBLE] -> Instrução Store com endereçamento por registrador. Dest detectado: [r30]. Source detectado: 'r8'
[DISASSEMBLE] -> Instrução Load/Store com endereçamento por registrador.
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'na', 'opcode': 'store', 'type': '01', 'rd': 'r0', 'op2': 'r30', 'rh': 'r8'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'store', 'type': '01', 'rd': 'r0', 'op2': 'r30', 'rh': 'r8'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'store', 'type': '01', 'rd': 'r0', 'op2': 'r30', 'rh': 'r8'}
[ENCODE] -> Instrução Store detectada.
[ENCODE] -> rd_bin, rh_bin calculados: Rd(r0)=:00000 e Rh(r8)=:01000
[ENCODE] -> Op2 é um registrador: r30, convertido para binário: 1111000000
[INSTRUCTION] -> Codificação concluída. Binário: 00000100000000000010001111000000

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'addi: r9 = r6, 1' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'addi: r9 = r6, 1'
[DISASSEMBLE] -> Parte do opcode: 'addi', Parte dos operandos: 'r9 = r6, 1'
[DISASSEMBLE] -> Sufixo de suporte encontrado: 'i'. Opcode final é 'add'
[DISASSEMBLE] -> Opcode final: 'add', Tipo: 00
[DISASSEMBLE] -> Instrução com atribuição. Destino: 'r9', Origem: 'r6, 1'
[DISASSEMBLE] -> Operandos finais: Rd='r9', Rh='r6', Op2='1'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'i', 'opcode': 'add', 'type': '00', 'rd': 'r9', 'rh': 'r6', 'op2': '1'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'add', 'type': '00', 'rd': 'r9', 'rh': 'r6', 'op2': '1'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'add', 'type': '00', 'rd': 'r9', 'rh': 'r6', 'op2': '1'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000010000001001001100000000001

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'subi: r30 = r31, 4' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'subi: r30 = r31, 4'
[DISASSEMBLE] -> Parte do opcode: 'subi', Parte dos operandos: 'r30 = r31, 4'
[DISASSEMBLE] -> Sufixo de suporte encontrado: 'i'. Opcode final é 'sub'
[DISASSEMBLE] -> Opcode final: 'sub', Tipo: 00
[DISASSEMBLE] -> Instrução com atribuição. Destino: 'r30', Origem: 'r31, 4'
[DISASSEMBLE] -> Operandos finais: Rd='r30', Rh='r31', Op2='4'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'i', 'opcode': 'sub', 'type': '00', 'rd': 'r30', 'rh': 'r31', 'op2': '4'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'sub', 'type': '00', 'rd': 'r30', 'rh': 'r31', 'op2': '4'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'sub', 'type': '00', 'rd': 'r30', 'rh': 'r31', 'op2': '4'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000010000111110111110000000100

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'store: [r30] = r9' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'store: [r30] = r9'
[DISASSEMBLE] -> Parte do opcode: 'store', Parte dos operandos: '[r30] = r9'
[DISASSEMBLE] -> Opcode final: 'store', Tipo: 01
[DISASSEMBLE] -> Instrução Store com endereçamento por registrador. Dest detectado: [r30]. Source detectado: 'r9'
[DISASSEMBLE] -> Instrução Load/Store com endereçamento por registrador.
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'na', 'opcode': 'store', 'type': '01', 'rd': 'r0', 'op2': 'r30', 'rh': 'r9'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'store', 'type': '01', 'rd': 'r0', 'op2': 'r30', 'rh': 'r9'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'store', 'type': '01', 'rd': 'r0', 'op2': 'r30', 'rh': 'r9'}
[ENCODE] -> Instrução Store detectada.
[ENCODE] -> rd_bin, rh_bin calculados: Rd(r0)=:00000 e Rh(r9)=:01001
[ENCODE] -> Op2 é um registrador: r30, convertido para binário: 1111000000
[INSTRUCTION] -> Codificação concluída. Binário: 00000100000000000010011111000000

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'subi: r30 = r31, 4' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'subi: r30 = r31, 4'
[DISASSEMBLE] -> Parte do opcode: 'subi', Parte dos operandos: 'r30 = r31, 4'
[DISASSEMBLE] -> Sufixo de suporte encontrado: 'i'. Opcode final é 'sub'
[DISASSEMBLE] -> Opcode final: 'sub', Tipo: 00
[DISASSEMBLE] -> Instrução com atribuição. Destino: 'r30', Origem: 'r31, 4'
[DISASSEMBLE] -> Operandos finais: Rd='r30', Rh='r31', Op2='4'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'i', 'opcode': 'sub', 'type': '00', 'rd': 'r30', 'rh': 'r31', 'op2': '4'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'sub', 'type': '00', 'rd': 'r30', 'rh': 'r31', 'op2': '4'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'sub', 'type': '00', 'rd': 'r30', 'rh': 'r31', 'op2': '4'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000010000111110111110000000100

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'store: [r30] = r9' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'store: [r30] = r9'
[DISASSEMBLE] -> Parte do opcode: 'store', Parte dos operandos: '[r30] = r9'
[DISASSEMBLE] -> Opcode final: 'store', Tipo: 01
[DISASSEMBLE] -> Instrução Store com endereçamento por registrador. Dest detectado: [r30]. Source detectado: 'r9'
[DISASSEMBLE] -> Instrução Load/Store com endereçamento por registrador.
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'na', 'opcode': 'store', 'type': '01', 'rd': 'r0', 'op2': 'r30', 'rh': 'r9'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'store', 'type': '01', 'rd': 'r0', 'op2': 'r30', 'rh': 'r9'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'store', 'type': '01', 'rd': 'r0', 'op2': 'r30', 'rh': 'r9'}
[ENCODE] -> Instrução Store detectada.
[ENCODE] -> rd_bin, rh_bin calculados: Rd(r0)=:00000 e Rh(r9)=:01001
[ENCODE] -> Op2 é um registrador: r30, convertido para binário: 1111000000
[INSTRUCTION] -> Codificação concluída. Binário: 00000100000000000010011111000000

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'subi: r30 = r31, 6' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'subi: r30 = r31, 6'
[DISASSEMBLE] -> Parte do opcode: 'subi', Parte dos operandos: 'r30 = r31, 6'
[DISASSEMBLE] -> Sufixo de suporte encontrado: 'i'. Opcode final é 'sub'
[DISASSEMBLE] -> Opcode final: 'sub', Tipo: 00
[DISASSEMBLE] -> Instrução com atribuição. Destino: 'r30', Origem: 'r31, 6'
[DISASSEMBLE] -> Operandos finais: Rd='r30', Rh='r31', Op2='6'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'i', 'opcode': 'sub', 'type': '00', 'rd': 'r30', 'rh': 'r31', 'op2': '6'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'sub', 'type': '00', 'rd': 'r30', 'rh': 'r31', 'op2': '6'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'sub', 'type': '00', 'rd': 'r30', 'rh': 'r31', 'op2': '6'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000010000111110111110000000110

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'store: [r30] = r8' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'store: [r30] = r8'
[DISASSEMBLE] -> Parte do opcode: 'store', Parte dos operandos: '[r30] = r8'
[DISASSEMBLE] -> Opcode final: 'store', Tipo: 01
[DISASSEMBLE] -> Instrução Store com endereçamento por registrador. Dest detectado: [r30]. Source detectado: 'r8'
[DISASSEMBLE] -> Instrução Load/Store com endereçamento por registrador.
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'na', 'opcode': 'store', 'type': '01', 'rd': 'r0', 'op2': 'r30', 'rh': 'r8'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'store', 'type': '01', 'rd': 'r0', 'op2': 'r30', 'rh': 'r8'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'store', 'type': '01', 'rd': 'r0', 'op2': 'r30', 'rh': 'r8'}
[ENCODE] -> Instrução Store detectada.
[ENCODE] -> rd_bin, rh_bin calculados: Rd(r0)=:00000 e Rh(r8)=:01000
[ENCODE] -> Op2 é um registrador: r30, convertido para binário: 1111000000
[INSTRUCTION] -> Codificação concluída. Binário: 00000100000000000010001111000000

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'subi: r30 = r31, 1' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'subi: r30 = r31, 1'
[DISASSEMBLE] -> Parte do opcode: 'subi', Parte dos operandos: 'r30 = r31, 1'
[DISASSEMBLE] -> Sufixo de suporte encontrado: 'i'. Opcode final é 'sub'
[DISASSEMBLE] -> Opcode final: 'sub', Tipo: 00
[DISASSEMBLE] -> Instrução com atribuição. Destino: 'r30', Origem: 'r31, 1'
[DISASSEMBLE] -> Operandos finais: Rd='r30', Rh='r31', Op2='1'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'i', 'opcode': 'sub', 'type': '00', 'rd': 'r30', 'rh': 'r31', 'op2': '1'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'sub', 'type': '00', 'rd': 'r30', 'rh': 'r31', 'op2': '1'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'sub', 'type': '00', 'rd': 'r30', 'rh': 'r31', 'op2': '1'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000010000111110111110000000001

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'load: r10 = [r30]' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'load: r10 = [r30]'
[DISASSEMBLE] -> Parte do opcode: 'load', Parte dos operandos: 'r10 = [r30]'
[DISASSEMBLE] -> Opcode final: 'load', Tipo: 01
[DISASSEMBLE] -> Instrução Load/Store com endereçamento por registrador.
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'na', 'opcode': 'load', 'type': '01', 'rd': 'r10', 'rh': 'r0', 'op2': 'r30'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'load', 'type': '01', 'rd': 'r10', 'rh': 'r0', 'op2': 'r30'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'load', 'type': '01', 'rd': 'r10', 'rh': 'r0', 'op2': 'r30'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000100000101010000001111000000

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'subs: r0 = r9, r10' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'subs: r0 = r9, r10'
[DISASSEMBLE] -> Parte do opcode: 'subs', Parte dos operandos: 'r0 = r9, r10'
[DISASSEMBLE] -> Sufixo de suporte encontrado: 's'. Opcode final é 'sub'
[DISASSEMBLE] -> Opcode final: 'sub', Tipo: 00
[DISASSEMBLE] -> Instrução com atribuição. Destino: 'r0', Origem: 'r9, r10'
[DISASSEMBLE] -> Operandos finais: Rd='r0', Rh='r9', Op2='r10'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 's', 'opcode': 'sub', 'type': '00', 'rd': 'r0', 'rh': 'r9', 'op2': 'r10'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 's', 'opcode': 'sub', 'type': '00', 'rd': 'r0', 'rh': 'r9', 'op2': 'r10'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 's', 'opcode': 'sub', 'type': '00', 'rd': 'r0', 'rh': 'r9', 'op2': 'r10'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000001000100000010010101000000

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'bigteq: L1' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'bigteq: L1'
[DISASSEMBLE] -> Parte do opcode: 'bigteq', Parte dos operandos: 'L1'
[DISASSEMBLE] -> Instrução de branch identificada: 'bigteq'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'gteq', 'supp': 'i', 'opcode': 'b', 'type': '11', 'op2': 'L1'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'gteq', 'supp': 'i', 'opcode': 'b', 'type': '11', 'op2': 'L1'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'gteq', 'supp': 'i', 'opcode': 'b', 'type': '11', 'op2': 'L1'}
[ENCODE] -> Instrução de branch detectada: b com condição gteq
[INSTRUCTION] -> Codificação concluída. Binário: 01001110000000000000000000010100

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'add: r11 = r5, r9' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'add: r11 = r5, r9'
[DISASSEMBLE] -> Parte do opcode: 'add', Parte dos operandos: 'r11 = r5, r9'
[DISASSEMBLE] -> Opcode final: 'add', Tipo: 00
[DISASSEMBLE] -> Instrução com atribuição. Destino: 'r11', Origem: 'r5, r9'
[DISASSEMBLE] -> Operandos finais: Rd='r11', Rh='r5', Op2='r9'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'na', 'opcode': 'add', 'type': '00', 'rd': 'r11', 'rh': 'r5', 'op2': 'r9'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'add', 'type': '00', 'rd': 'r11', 'rh': 'r5', 'op2': 'r9'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'add', 'type': '00', 'rd': 'r11', 'rh': 'r5', 'op2': 'r9'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000000000001011001010100100000

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'load: r12 = [r11]' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'load: r12 = [r11]'
[DISASSEMBLE] -> Parte do opcode: 'load', Parte dos operandos: 'r12 = [r11]'
[DISASSEMBLE] -> Opcode final: 'load', Tipo: 01
[DISASSEMBLE] -> Instrução Load/Store com endereçamento por registrador.
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'na', 'opcode': 'load', 'type': '01', 'rd': 'r12', 'rh': 'r0', 'op2': 'r11'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'load', 'type': '01', 'rd': 'r12', 'rh': 'r0', 'op2': 'r11'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'load', 'type': '01', 'rd': 'r12', 'rh': 'r0', 'op2': 'r11'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000100000101100000000101100000

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'subs: r0 = r12, r8' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'subs: r0 = r12, r8'
[DISASSEMBLE] -> Parte do opcode: 'subs', Parte dos operandos: 'r0 = r12, r8'
[DISASSEMBLE] -> Sufixo de suporte encontrado: 's'. Opcode final é 'sub'
[DISASSEMBLE] -> Opcode final: 'sub', Tipo: 00
[DISASSEMBLE] -> Instrução com atribuição. Destino: 'r0', Origem: 'r12, r8'
[DISASSEMBLE] -> Operandos finais: Rd='r0', Rh='r12', Op2='r8'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 's', 'opcode': 'sub', 'type': '00', 'rd': 'r0', 'rh': 'r12', 'op2': 'r8'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 's', 'opcode': 'sub', 'type': '00', 'rd': 'r0', 'rh': 'r12', 'op2': 'r8'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 's', 'opcode': 'sub', 'type': '00', 'rd': 'r0', 'rh': 'r12', 'op2': 'r8'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000001000100000011000100000000

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'bigteq: L2' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'bigteq: L2'
[DISASSEMBLE] -> Parte do opcode: 'bigteq', Parte dos operandos: 'L2'
[DISASSEMBLE] -> Instrução de branch identificada: 'bigteq'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'gteq', 'supp': 'i', 'opcode': 'b', 'type': '11', 'op2': 'L2'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'gteq', 'supp': 'i', 'opcode': 'b', 'type': '11', 'op2': 'L2'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'gteq', 'supp': 'i', 'opcode': 'b', 'type': '11', 'op2': 'L2'}
[ENCODE] -> Instrução de branch detectada: b com condição gteq
[INSTRUCTION] -> Codificação concluída. Binário: 01001110000000000000000000001001

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'add: r13 = r5, r9' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'add: r13 = r5, r9'
[DISASSEMBLE] -> Parte do opcode: 'add', Parte dos operandos: 'r13 = r5, r9'
[DISASSEMBLE] -> Opcode final: 'add', Tipo: 00
[DISASSEMBLE] -> Instrução com atribuição. Destino: 'r13', Origem: 'r5, r9'
[DISASSEMBLE] -> Operandos finais: Rd='r13', Rh='r5', Op2='r9'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'na', 'opcode': 'add', 'type': '00', 'rd': 'r13', 'rh': 'r5', 'op2': 'r9'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'add', 'type': '00', 'rd': 'r13', 'rh': 'r5', 'op2': 'r9'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'add', 'type': '00', 'rd': 'r13', 'rh': 'r5', 'op2': 'r9'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000000000001101001010100100000

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'load: r14 = [r13]' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'load: r14 = [r13]'
[DISASSEMBLE] -> Parte do opcode: 'load', Parte dos operandos: 'r14 = [r13]'
[DISASSEMBLE] -> Opcode final: 'load', Tipo: 01
[DISASSEMBLE] -> Instrução Load/Store com endereçamento por registrador.
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'na', 'opcode': 'load', 'type': '01', 'rd': 'r14', 'rh': 'r0', 'op2': 'r13'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'load', 'type': '01', 'rd': 'r14', 'rh': 'r0', 'op2': 'r13'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'load', 'type': '01', 'rd': 'r14', 'rh': 'r0', 'op2': 'r13'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000100000101110000000110100000

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'subi: r30 = r31, 6' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'subi: r30 = r31, 6'
[DISASSEMBLE] -> Parte do opcode: 'subi', Parte dos operandos: 'r30 = r31, 6'
[DISASSEMBLE] -> Sufixo de suporte encontrado: 'i'. Opcode final é 'sub'
[DISASSEMBLE] -> Opcode final: 'sub', Tipo: 00
[DISASSEMBLE] -> Instrução com atribuição. Destino: 'r30', Origem: 'r31, 6'
[DISASSEMBLE] -> Operandos finais: Rd='r30', Rh='r31', Op2='6'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'i', 'opcode': 'sub', 'type': '00', 'rd': 'r30', 'rh': 'r31', 'op2': '6'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'sub', 'type': '00', 'rd': 'r30', 'rh': 'r31', 'op2': '6'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'sub', 'type': '00', 'rd': 'r30', 'rh': 'r31', 'op2': '6'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000010000111110111110000000110

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'store: [r30] = r14' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'store: [r30] = r14'
[DISASSEMBLE] -> Parte do opcode: 'store', Parte dos operandos: '[r30] = r14'
[DISASSEMBLE] -> Opcode final: 'store', Tipo: 01
[DISASSEMBLE] -> Instrução Store com endereçamento por registrador. Dest detectado: [r30]. Source detectado: 'r14'
[DISASSEMBLE] -> Instrução Load/Store com endereçamento por registrador.
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'na', 'opcode': 'store', 'type': '01', 'rd': 'r0', 'op2': 'r30', 'rh': 'r14'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'store', 'type': '01', 'rd': 'r0', 'op2': 'r30', 'rh': 'r14'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'store', 'type': '01', 'rd': 'r0', 'op2': 'r30', 'rh': 'r14'}
[ENCODE] -> Instrução Store detectada.
[ENCODE] -> rd_bin, rh_bin calculados: Rd(r0)=:00000 e Rh(r14)=:01110
[ENCODE] -> Op2 é um registrador: r30, convertido para binário: 1111000000
[INSTRUCTION] -> Codificação concluída. Binário: 00000100000000000011101111000000

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'subi: r30 = r31, 5' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'subi: r30 = r31, 5'
[DISASSEMBLE] -> Parte do opcode: 'subi', Parte dos operandos: 'r30 = r31, 5'
[DISASSEMBLE] -> Sufixo de suporte encontrado: 'i'. Opcode final é 'sub'
[DISASSEMBLE] -> Opcode final: 'sub', Tipo: 00
[DISASSEMBLE] -> Instrução com atribuição. Destino: 'r30', Origem: 'r31, 5'
[DISASSEMBLE] -> Operandos finais: Rd='r30', Rh='r31', Op2='5'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'i', 'opcode': 'sub', 'type': '00', 'rd': 'r30', 'rh': 'r31', 'op2': '5'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'sub', 'type': '00', 'rd': 'r30', 'rh': 'r31', 'op2': '5'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'sub', 'type': '00', 'rd': 'r30', 'rh': 'r31', 'op2': '5'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000010000111110111110000000101

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'store: [r30] = r9' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'store: [r30] = r9'
[DISASSEMBLE] -> Parte do opcode: 'store', Parte dos operandos: '[r30] = r9'
[DISASSEMBLE] -> Opcode final: 'store', Tipo: 01
[DISASSEMBLE] -> Instrução Store com endereçamento por registrador. Dest detectado: [r30]. Source detectado: 'r9'
[DISASSEMBLE] -> Instrução Load/Store com endereçamento por registrador.
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'na', 'opcode': 'store', 'type': '01', 'rd': 'r0', 'op2': 'r30', 'rh': 'r9'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'store', 'type': '01', 'rd': 'r0', 'op2': 'r30', 'rh': 'r9'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'store', 'type': '01', 'rd': 'r0', 'op2': 'r30', 'rh': 'r9'}
[ENCODE] -> Instrução Store detectada.
[ENCODE] -> rd_bin, rh_bin calculados: Rd(r0)=:00000 e Rh(r9)=:01001
[ENCODE] -> Op2 é um registrador: r30, convertido para binário: 1111000000
[INSTRUCTION] -> Codificação concluída. Binário: 00000100000000000010011111000000

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'subi: r30 = r31, 6' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'subi: r30 = r31, 6'
[DISASSEMBLE] -> Parte do opcode: 'subi', Parte dos operandos: 'r30 = r31, 6'
[DISASSEMBLE] -> Sufixo de suporte encontrado: 'i'. Opcode final é 'sub'
[DISASSEMBLE] -> Opcode final: 'sub', Tipo: 00
[DISASSEMBLE] -> Instrução com atribuição. Destino: 'r30', Origem: 'r31, 6'
[DISASSEMBLE] -> Operandos finais: Rd='r30', Rh='r31', Op2='6'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'i', 'opcode': 'sub', 'type': '00', 'rd': 'r30', 'rh': 'r31', 'op2': '6'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'sub', 'type': '00', 'rd': 'r30', 'rh': 'r31', 'op2': '6'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'sub', 'type': '00', 'rd': 'r30', 'rh': 'r31', 'op2': '6'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000010000111110111110000000110

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'store: [r30] = r14' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'store: [r30] = r14'
[DISASSEMBLE] -> Parte do opcode: 'store', Parte dos operandos: '[r30] = r14'
[DISASSEMBLE] -> Opcode final: 'store', Tipo: 01
[DISASSEMBLE] -> Instrução Store com endereçamento por registrador. Dest detectado: [r30]. Source detectado: 'r14'
[DISASSEMBLE] -> Instrução Load/Store com endereçamento por registrador.
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'na', 'opcode': 'store', 'type': '01', 'rd': 'r0', 'op2': 'r30', 'rh': 'r14'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'store', 'type': '01', 'rd': 'r0', 'op2': 'r30', 'rh': 'r14'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'store', 'type': '01', 'rd': 'r0', 'op2': 'r30', 'rh': 'r14'}
[ENCODE] -> Instrução Store detectada.
[ENCODE] -> rd_bin, rh_bin calculados: Rd(r0)=:00000 e Rh(r14)=:01110
[ENCODE] -> Op2 é um registrador: r30, convertido para binário: 1111000000
[INSTRUCTION] -> Codificação concluída. Binário: 00000100000000000011101111000000

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'bi: L3' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'bi: L3'
[DISASSEMBLE] -> Parte do opcode: 'bi', Parte dos operandos: 'L3'
[DISASSEMBLE] -> Instrução de branch identificada: 'bi'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'i', 'opcode': 'b', 'type': '11', 'op2': 'L3'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'b', 'type': '11', 'op2': 'L3'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'b', 'type': '11', 'op2': 'L3'}
[ENCODE] -> Instrução de branch detectada: b com condição do
[INSTRUCTION] -> Codificação concluída. Binário: 00001110000000000000000000000000

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'subi: r30 = r31, 4' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'subi: r30 = r31, 4'
[DISASSEMBLE] -> Parte do opcode: 'subi', Parte dos operandos: 'r30 = r31, 4'
[DISASSEMBLE] -> Sufixo de suporte encontrado: 'i'. Opcode final é 'sub'
[DISASSEMBLE] -> Opcode final: 'sub', Tipo: 00
[DISASSEMBLE] -> Instrução com atribuição. Destino: 'r30', Origem: 'r31, 4'
[DISASSEMBLE] -> Operandos finais: Rd='r30', Rh='r31', Op2='4'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'i', 'opcode': 'sub', 'type': '00', 'rd': 'r30', 'rh': 'r31', 'op2': '4'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'sub', 'type': '00', 'rd': 'r30', 'rh': 'r31', 'op2': '4'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'sub', 'type': '00', 'rd': 'r30', 'rh': 'r31', 'op2': '4'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000010000111110111110000000100

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'load: r15 = [r30]' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'load: r15 = [r30]'
[DISASSEMBLE] -> Parte do opcode: 'load', Parte dos operandos: 'r15 = [r30]'
[DISASSEMBLE] -> Opcode final: 'load', Tipo: 01
[DISASSEMBLE] -> Instrução Load/Store com endereçamento por registrador.
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'na', 'opcode': 'load', 'type': '01', 'rd': 'r15', 'rh': 'r0', 'op2': 'r30'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'load', 'type': '01', 'rd': 'r15', 'rh': 'r0', 'op2': 'r30'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'load', 'type': '01', 'rd': 'r15', 'rh': 'r0', 'op2': 'r30'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000100000101111000001111000000

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'addi: r16 = r15, 1' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'addi: r16 = r15, 1'
[DISASSEMBLE] -> Parte do opcode: 'addi', Parte dos operandos: 'r16 = r15, 1'
[DISASSEMBLE] -> Sufixo de suporte encontrado: 'i'. Opcode final é 'add'
[DISASSEMBLE] -> Opcode final: 'add', Tipo: 00
[DISASSEMBLE] -> Instrução com atribuição. Destino: 'r16', Origem: 'r15, 1'
[DISASSEMBLE] -> Operandos finais: Rd='r16', Rh='r15', Op2='1'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'i', 'opcode': 'add', 'type': '00', 'rd': 'r16', 'rh': 'r15', 'op2': '1'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'add', 'type': '00', 'rd': 'r16', 'rh': 'r15', 'op2': '1'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'add', 'type': '00', 'rd': 'r16', 'rh': 'r15', 'op2': '1'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000010000010000011110000000001

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'subi: r30 = r31, 4' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'subi: r30 = r31, 4'
[DISASSEMBLE] -> Parte do opcode: 'subi', Parte dos operandos: 'r30 = r31, 4'
[DISASSEMBLE] -> Sufixo de suporte encontrado: 'i'. Opcode final é 'sub'
[DISASSEMBLE] -> Opcode final: 'sub', Tipo: 00
[DISASSEMBLE] -> Instrução com atribuição. Destino: 'r30', Origem: 'r31, 4'
[DISASSEMBLE] -> Operandos finais: Rd='r30', Rh='r31', Op2='4'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'i', 'opcode': 'sub', 'type': '00', 'rd': 'r30', 'rh': 'r31', 'op2': '4'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'sub', 'type': '00', 'rd': 'r30', 'rh': 'r31', 'op2': '4'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'sub', 'type': '00', 'rd': 'r30', 'rh': 'r31', 'op2': '4'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000010000111110111110000000100

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'store: [r30] = r16' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'store: [r30] = r16'
[DISASSEMBLE] -> Parte do opcode: 'store', Parte dos operandos: '[r30] = r16'
[DISASSEMBLE] -> Opcode final: 'store', Tipo: 01
[DISASSEMBLE] -> Instrução Store com endereçamento por registrador. Dest detectado: [r30]. Source detectado: 'r16'
[DISASSEMBLE] -> Instrução Load/Store com endereçamento por registrador.
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'na', 'opcode': 'store', 'type': '01', 'rd': 'r0', 'op2': 'r30', 'rh': 'r16'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'store', 'type': '01', 'rd': 'r0', 'op2': 'r30', 'rh': 'r16'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'store', 'type': '01', 'rd': 'r0', 'op2': 'r30', 'rh': 'r16'}
[ENCODE] -> Instrução Store detectada.
[ENCODE] -> rd_bin, rh_bin calculados: Rd(r0)=:00000 e Rh(r16)=:10000
[ENCODE] -> Op2 é um registrador: r30, convertido para binário: 1111000000
[INSTRUCTION] -> Codificação concluída. Binário: 00000100000000000100001111000000

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'subi: r30 = r31, 4' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'subi: r30 = r31, 4'
[DISASSEMBLE] -> Parte do opcode: 'subi', Parte dos operandos: 'r30 = r31, 4'
[DISASSEMBLE] -> Sufixo de suporte encontrado: 'i'. Opcode final é 'sub'
[DISASSEMBLE] -> Opcode final: 'sub', Tipo: 00
[DISASSEMBLE] -> Instrução com atribuição. Destino: 'r30', Origem: 'r31, 4'
[DISASSEMBLE] -> Operandos finais: Rd='r30', Rh='r31', Op2='4'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'i', 'opcode': 'sub', 'type': '00', 'rd': 'r30', 'rh': 'r31', 'op2': '4'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'sub', 'type': '00', 'rd': 'r30', 'rh': 'r31', 'op2': '4'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'sub', 'type': '00', 'rd': 'r30', 'rh': 'r31', 'op2': '4'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000010000111110111110000000100

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'store: [r30] = r16' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'store: [r30] = r16'
[DISASSEMBLE] -> Parte do opcode: 'store', Parte dos operandos: '[r30] = r16'
[DISASSEMBLE] -> Opcode final: 'store', Tipo: 01
[DISASSEMBLE] -> Instrução Store com endereçamento por registrador. Dest detectado: [r30]. Source detectado: 'r16'
[DISASSEMBLE] -> Instrução Load/Store com endereçamento por registrador.
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'na', 'opcode': 'store', 'type': '01', 'rd': 'r0', 'op2': 'r30', 'rh': 'r16'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'store', 'type': '01', 'rd': 'r0', 'op2': 'r30', 'rh': 'r16'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'store', 'type': '01', 'rd': 'r0', 'op2': 'r30', 'rh': 'r16'}
[ENCODE] -> Instrução Store detectada.
[ENCODE] -> rd_bin, rh_bin calculados: Rd(r0)=:00000 e Rh(r16)=:10000
[ENCODE] -> Op2 é um registrador: r30, convertido para binário: 1111000000
[INSTRUCTION] -> Codificação concluída. Binário: 00000100000000000100001111000000

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'mov: r0 = r9' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'mov: r0 = r9'
[DISASSEMBLE] -> Parte do opcode: 'mov', Parte dos operandos: 'r0 = r9'
[DISASSEMBLE] -> Opcode final: 'mov', Tipo: 00
[DISASSEMBLE] -> Instrução 'mov' identificada. Destino: 'r0', Origem: 'r9'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'na', 'opcode': 'mov', 'type': '00', 'rd': 'r0', 'rh': 'r0', 'op2': 'r9'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'mov', 'type': '00', 'rd': 'r0', 'rh': 'r0', 'op2': 'r9'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'mov', 'type': '00', 'rd': 'r0', 'rh': 'r0', 'op2': 'r9'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000000100000000000000100100000

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'bi: minloc_epilogue' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'bi: minloc_epilogue'
[DISASSEMBLE] -> Parte do opcode: 'bi', Parte dos operandos: 'minloc_epilogue'
[DISASSEMBLE] -> Instrução de branch identificada: 'bi'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'i', 'opcode': 'b', 'type': '11', 'op2': 'minloc_epilogue'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'b', 'type': '11', 'op2': 'minloc_epilogue'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'b', 'type': '11', 'op2': 'minloc_epilogue'}
[ENCODE] -> Instrução de branch detectada: b com condição do
[INSTRUCTION] -> Codificação concluída. Binário: 00001110000000000000000000000000

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'mov: r29 = r31' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'mov: r29 = r31'
[DISASSEMBLE] -> Parte do opcode: 'mov', Parte dos operandos: 'r29 = r31'
[DISASSEMBLE] -> Opcode final: 'mov', Tipo: 00
[DISASSEMBLE] -> Instrução 'mov' identificada. Destino: 'r29', Origem: 'r31'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'na', 'opcode': 'mov', 'type': '00', 'rd': 'r29', 'rh': 'r0', 'op2': 'r31'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'mov', 'type': '00', 'rd': 'r29', 'rh': 'r0', 'op2': 'r31'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'mov', 'type': '00', 'rd': 'r29', 'rh': 'r0', 'op2': 'r31'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000000100011101000001111100000

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'load: r31 = [r29]' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'load: r31 = [r29]'
[DISASSEMBLE] -> Parte do opcode: 'load', Parte dos operandos: 'r31 = [r29]'
[DISASSEMBLE] -> Opcode final: 'load', Tipo: 01
[DISASSEMBLE] -> Instrução Load/Store com endereçamento por registrador.
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'na', 'opcode': 'load', 'type': '01', 'rd': 'r31', 'rh': 'r0', 'op2': 'r29'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'load', 'type': '01', 'rd': 'r31', 'rh': 'r0', 'op2': 'r29'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'load', 'type': '01', 'rd': 'r31', 'rh': 'r0', 'op2': 'r29'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000100000111111000001110100000

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'addi: r29 = r29, 1' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'addi: r29 = r29, 1'
[DISASSEMBLE] -> Parte do opcode: 'addi', Parte dos operandos: 'r29 = r29, 1'
[DISASSEMBLE] -> Sufixo de suporte encontrado: 'i'. Opcode final é 'add'
[DISASSEMBLE] -> Opcode final: 'add', Tipo: 00
[DISASSEMBLE] -> Instrução com atribuição. Destino: 'r29', Origem: 'r29, 1'
[DISASSEMBLE] -> Operandos finais: Rd='r29', Rh='r29', Op2='1'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'i', 'opcode': 'add', 'type': '00', 'rd': 'r29', 'rh': 'r29', 'op2': '1'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'add', 'type': '00', 'rd': 'r29', 'rh': 'r29', 'op2': '1'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'add', 'type': '00', 'rd': 'r29', 'rh': 'r29', 'op2': '1'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000010000011101111010000000001

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'load: r28 = [r29]' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'load: r28 = [r29]'
[DISASSEMBLE] -> Parte do opcode: 'load', Parte dos operandos: 'r28 = [r29]'
[DISASSEMBLE] -> Opcode final: 'load', Tipo: 01
[DISASSEMBLE] -> Instrução Load/Store com endereçamento por registrador.
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'na', 'opcode': 'load', 'type': '01', 'rd': 'r28', 'rh': 'r0', 'op2': 'r29'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'load', 'type': '01', 'rd': 'r28', 'rh': 'r0', 'op2': 'r29'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'load', 'type': '01', 'rd': 'r28', 'rh': 'r0', 'op2': 'r29'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000100000111100000001110100000

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'addi: r29 = r29, 1' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'addi: r29 = r29, 1'
[DISASSEMBLE] -> Parte do opcode: 'addi', Parte dos operandos: 'r29 = r29, 1'
[DISASSEMBLE] -> Sufixo de suporte encontrado: 'i'. Opcode final é 'add'
[DISASSEMBLE] -> Opcode final: 'add', Tipo: 00
[DISASSEMBLE] -> Instrução com atribuição. Destino: 'r29', Origem: 'r29, 1'
[DISASSEMBLE] -> Operandos finais: Rd='r29', Rh='r29', Op2='1'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'i', 'opcode': 'add', 'type': '00', 'rd': 'r29', 'rh': 'r29', 'op2': '1'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'add', 'type': '00', 'rd': 'r29', 'rh': 'r29', 'op2': '1'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'add', 'type': '00', 'rd': 'r29', 'rh': 'r29', 'op2': '1'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000010000011101111010000000001

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'b: r28' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'b: r28'
[DISASSEMBLE] -> Parte do opcode: 'b', Parte dos operandos: 'r28'
[DISASSEMBLE] -> Instrução de branch identificada: 'b'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'na', 'opcode': 'b', 'type': '11', 'op2': 'r28'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'b', 'type': '11', 'op2': 'r28'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'b', 'type': '11', 'op2': 'r28'}
[ENCODE] -> Instrução de branch detectada: b com condição do
[ENCODE] -> Branch para registrador detectado: r28
[INSTRUCTION] -> Codificação concluída. Binário: 00001100000000000000001110000000

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'subi: r29 = r29, 1' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'subi: r29 = r29, 1'
[DISASSEMBLE] -> Parte do opcode: 'subi', Parte dos operandos: 'r29 = r29, 1'
[DISASSEMBLE] -> Sufixo de suporte encontrado: 'i'. Opcode final é 'sub'
[DISASSEMBLE] -> Opcode final: 'sub', Tipo: 00
[DISASSEMBLE] -> Instrução com atribuição. Destino: 'r29', Origem: 'r29, 1'
[DISASSEMBLE] -> Operandos finais: Rd='r29', Rh='r29', Op2='1'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'i', 'opcode': 'sub', 'type': '00', 'rd': 'r29', 'rh': 'r29', 'op2': '1'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'sub', 'type': '00', 'rd': 'r29', 'rh': 'r29', 'op2': '1'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'sub', 'type': '00', 'rd': 'r29', 'rh': 'r29', 'op2': '1'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000010000111101111010000000001

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'store: [r29] = r28' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'store: [r29] = r28'
[DISASSEMBLE] -> Parte do opcode: 'store', Parte dos operandos: '[r29] = r28'
[DISASSEMBLE] -> Opcode final: 'store', Tipo: 01
[DISASSEMBLE] -> Instrução Store com endereçamento por registrador. Dest detectado: [r29]. Source detectado: 'r28'
[DISASSEMBLE] -> Instrução Load/Store com endereçamento por registrador.
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'na', 'opcode': 'store', 'type': '01', 'rd': 'r0', 'op2': 'r29', 'rh': 'r28'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'store', 'type': '01', 'rd': 'r0', 'op2': 'r29', 'rh': 'r28'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'store', 'type': '01', 'rd': 'r0', 'op2': 'r29', 'rh': 'r28'}
[ENCODE] -> Instrução Store detectada.
[ENCODE] -> rd_bin, rh_bin calculados: Rd(r0)=:00000 e Rh(r28)=:11100
[ENCODE] -> Op2 é um registrador: r29, convertido para binário: 1110100000
[INSTRUCTION] -> Codificação concluída. Binário: 00000100000000000111001110100000

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'subi: r29 = r29, 1' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'subi: r29 = r29, 1'
[DISASSEMBLE] -> Parte do opcode: 'subi', Parte dos operandos: 'r29 = r29, 1'
[DISASSEMBLE] -> Sufixo de suporte encontrado: 'i'. Opcode final é 'sub'
[DISASSEMBLE] -> Opcode final: 'sub', Tipo: 00
[DISASSEMBLE] -> Instrução com atribuição. Destino: 'r29', Origem: 'r29, 1'
[DISASSEMBLE] -> Operandos finais: Rd='r29', Rh='r29', Op2='1'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'i', 'opcode': 'sub', 'type': '00', 'rd': 'r29', 'rh': 'r29', 'op2': '1'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'sub', 'type': '00', 'rd': 'r29', 'rh': 'r29', 'op2': '1'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'sub', 'type': '00', 'rd': 'r29', 'rh': 'r29', 'op2': '1'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000010000111101111010000000001

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'store: [r29] = r31' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'store: [r29] = r31'
[DISASSEMBLE] -> Parte do opcode: 'store', Parte dos operandos: '[r29] = r31'
[DISASSEMBLE] -> Opcode final: 'store', Tipo: 01
[DISASSEMBLE] -> Instrução Store com endereçamento por registrador. Dest detectado: [r29]. Source detectado: 'r31'
[DISASSEMBLE] -> Instrução Load/Store com endereçamento por registrador.
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'na', 'opcode': 'store', 'type': '01', 'rd': 'r0', 'op2': 'r29', 'rh': 'r31'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'store', 'type': '01', 'rd': 'r0', 'op2': 'r29', 'rh': 'r31'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'store', 'type': '01', 'rd': 'r0', 'op2': 'r29', 'rh': 'r31'}
[ENCODE] -> Instrução Store detectada.
[ENCODE] -> rd_bin, rh_bin calculados: Rd(r0)=:00000 e Rh(r31)=:11111
[ENCODE] -> Op2 é um registrador: r29, convertido para binário: 1110100000
[INSTRUCTION] -> Codificação concluída. Binário: 00000100000000000111111110100000

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'mov: r31 = r29' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'mov: r31 = r29'
[DISASSEMBLE] -> Parte do opcode: 'mov', Parte dos operandos: 'r31 = r29'
[DISASSEMBLE] -> Opcode final: 'mov', Tipo: 00
[DISASSEMBLE] -> Instrução 'mov' identificada. Destino: 'r31', Origem: 'r29'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'na', 'opcode': 'mov', 'type': '00', 'rd': 'r31', 'rh': 'r0', 'op2': 'r29'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'mov', 'type': '00', 'rd': 'r31', 'rh': 'r0', 'op2': 'r29'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'mov', 'type': '00', 'rd': 'r31', 'rh': 'r0', 'op2': 'r29'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000000100011111000001110100000

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'subi: r29 = r29, 15' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'subi: r29 = r29, 15'
[DISASSEMBLE] -> Parte do opcode: 'subi', Parte dos operandos: 'r29 = r29, 15'
[DISASSEMBLE] -> Sufixo de suporte encontrado: 'i'. Opcode final é 'sub'
[DISASSEMBLE] -> Opcode final: 'sub', Tipo: 00
[DISASSEMBLE] -> Instrução com atribuição. Destino: 'r29', Origem: 'r29, 15'
[DISASSEMBLE] -> Operandos finais: Rd='r29', Rh='r29', Op2='15'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'i', 'opcode': 'sub', 'type': '00', 'rd': 'r29', 'rh': 'r29', 'op2': '15'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'sub', 'type': '00', 'rd': 'r29', 'rh': 'r29', 'op2': '15'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'sub', 'type': '00', 'rd': 'r29', 'rh': 'r29', 'op2': '15'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000010000111101111010000001111

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'subi: r30 = r31, 1' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'subi: r30 = r31, 1'
[DISASSEMBLE] -> Parte do opcode: 'subi', Parte dos operandos: 'r30 = r31, 1'
[DISASSEMBLE] -> Sufixo de suporte encontrado: 'i'. Opcode final é 'sub'
[DISASSEMBLE] -> Opcode final: 'sub', Tipo: 00
[DISASSEMBLE] -> Instrução com atribuição. Destino: 'r30', Origem: 'r31, 1'
[DISASSEMBLE] -> Operandos finais: Rd='r30', Rh='r31', Op2='1'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'i', 'opcode': 'sub', 'type': '00', 'rd': 'r30', 'rh': 'r31', 'op2': '1'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'sub', 'type': '00', 'rd': 'r30', 'rh': 'r31', 'op2': '1'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'sub', 'type': '00', 'rd': 'r30', 'rh': 'r31', 'op2': '1'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000010000111110111110000000001

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'store: [r30] = r1' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'store: [r30] = r1'
[DISASSEMBLE] -> Parte do opcode: 'store', Parte dos operandos: '[r30] = r1'
[DISASSEMBLE] -> Opcode final: 'store', Tipo: 01
[DISASSEMBLE] -> Instrução Store com endereçamento por registrador. Dest detectado: [r30]. Source detectado: 'r1'
[DISASSEMBLE] -> Instrução Load/Store com endereçamento por registrador.
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'na', 'opcode': 'store', 'type': '01', 'rd': 'r0', 'op2': 'r30', 'rh': 'r1'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'store', 'type': '01', 'rd': 'r0', 'op2': 'r30', 'rh': 'r1'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'store', 'type': '01', 'rd': 'r0', 'op2': 'r30', 'rh': 'r1'}
[ENCODE] -> Instrução Store detectada.
[ENCODE] -> rd_bin, rh_bin calculados: Rd(r0)=:00000 e Rh(r1)=:00001
[ENCODE] -> Op2 é um registrador: r30, convertido para binário: 1111000000
[INSTRUCTION] -> Codificação concluída. Binário: 00000100000000000000011111000000

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'subi: r30 = r31, 2' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'subi: r30 = r31, 2'
[DISASSEMBLE] -> Parte do opcode: 'subi', Parte dos operandos: 'r30 = r31, 2'
[DISASSEMBLE] -> Sufixo de suporte encontrado: 'i'. Opcode final é 'sub'
[DISASSEMBLE] -> Opcode final: 'sub', Tipo: 00
[DISASSEMBLE] -> Instrução com atribuição. Destino: 'r30', Origem: 'r31, 2'
[DISASSEMBLE] -> Operandos finais: Rd='r30', Rh='r31', Op2='2'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'i', 'opcode': 'sub', 'type': '00', 'rd': 'r30', 'rh': 'r31', 'op2': '2'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'sub', 'type': '00', 'rd': 'r30', 'rh': 'r31', 'op2': '2'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'sub', 'type': '00', 'rd': 'r30', 'rh': 'r31', 'op2': '2'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000010000111110111110000000010

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'store: [r30] = r2' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'store: [r30] = r2'
[DISASSEMBLE] -> Parte do opcode: 'store', Parte dos operandos: '[r30] = r2'
[DISASSEMBLE] -> Opcode final: 'store', Tipo: 01
[DISASSEMBLE] -> Instrução Store com endereçamento por registrador. Dest detectado: [r30]. Source detectado: 'r2'
[DISASSEMBLE] -> Instrução Load/Store com endereçamento por registrador.
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'na', 'opcode': 'store', 'type': '01', 'rd': 'r0', 'op2': 'r30', 'rh': 'r2'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'store', 'type': '01', 'rd': 'r0', 'op2': 'r30', 'rh': 'r2'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'store', 'type': '01', 'rd': 'r0', 'op2': 'r30', 'rh': 'r2'}
[ENCODE] -> Instrução Store detectada.
[ENCODE] -> rd_bin, rh_bin calculados: Rd(r0)=:00000 e Rh(r2)=:00010
[ENCODE] -> Op2 é um registrador: r30, convertido para binário: 1111000000
[INSTRUCTION] -> Codificação concluída. Binário: 00000100000000000000101111000000

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'subi: r30 = r31, 3' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'subi: r30 = r31, 3'
[DISASSEMBLE] -> Parte do opcode: 'subi', Parte dos operandos: 'r30 = r31, 3'
[DISASSEMBLE] -> Sufixo de suporte encontrado: 'i'. Opcode final é 'sub'
[DISASSEMBLE] -> Opcode final: 'sub', Tipo: 00
[DISASSEMBLE] -> Instrução com atribuição. Destino: 'r30', Origem: 'r31, 3'
[DISASSEMBLE] -> Operandos finais: Rd='r30', Rh='r31', Op2='3'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'i', 'opcode': 'sub', 'type': '00', 'rd': 'r30', 'rh': 'r31', 'op2': '3'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'sub', 'type': '00', 'rd': 'r30', 'rh': 'r31', 'op2': '3'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'sub', 'type': '00', 'rd': 'r30', 'rh': 'r31', 'op2': '3'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000010000111110111110000000011

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'store: [r30] = r3' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'store: [r30] = r3'
[DISASSEMBLE] -> Parte do opcode: 'store', Parte dos operandos: '[r30] = r3'
[DISASSEMBLE] -> Opcode final: 'store', Tipo: 01
[DISASSEMBLE] -> Instrução Store com endereçamento por registrador. Dest detectado: [r30]. Source detectado: 'r3'
[DISASSEMBLE] -> Instrução Load/Store com endereçamento por registrador.
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'na', 'opcode': 'store', 'type': '01', 'rd': 'r0', 'op2': 'r30', 'rh': 'r3'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'store', 'type': '01', 'rd': 'r0', 'op2': 'r30', 'rh': 'r3'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'store', 'type': '01', 'rd': 'r0', 'op2': 'r30', 'rh': 'r3'}
[ENCODE] -> Instrução Store detectada.
[ENCODE] -> rd_bin, rh_bin calculados: Rd(r0)=:00000 e Rh(r3)=:00011
[ENCODE] -> Op2 é um registrador: r30, convertido para binário: 1111000000
[INSTRUCTION] -> Codificação concluída. Binário: 00000100000000000000111111000000

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'subi: r30 = r31, 3' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'subi: r30 = r31, 3'
[DISASSEMBLE] -> Parte do opcode: 'subi', Parte dos operandos: 'r30 = r31, 3'
[DISASSEMBLE] -> Sufixo de suporte encontrado: 'i'. Opcode final é 'sub'
[DISASSEMBLE] -> Opcode final: 'sub', Tipo: 00
[DISASSEMBLE] -> Instrução com atribuição. Destino: 'r30', Origem: 'r31, 3'
[DISASSEMBLE] -> Operandos finais: Rd='r30', Rh='r31', Op2='3'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'i', 'opcode': 'sub', 'type': '00', 'rd': 'r30', 'rh': 'r31', 'op2': '3'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'sub', 'type': '00', 'rd': 'r30', 'rh': 'r31', 'op2': '3'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'sub', 'type': '00', 'rd': 'r30', 'rh': 'r31', 'op2': '3'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000010000111110111110000000011

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'load: r4 = [r30]' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'load: r4 = [r30]'
[DISASSEMBLE] -> Parte do opcode: 'load', Parte dos operandos: 'r4 = [r30]'
[DISASSEMBLE] -> Opcode final: 'load', Tipo: 01
[DISASSEMBLE] -> Instrução Load/Store com endereçamento por registrador.
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'na', 'opcode': 'load', 'type': '01', 'rd': 'r4', 'rh': 'r0', 'op2': 'r30'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'load', 'type': '01', 'rd': 'r4', 'rh': 'r0', 'op2': 'r30'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'load', 'type': '01', 'rd': 'r4', 'rh': 'r0', 'op2': 'r30'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000100000100100000001111000000

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'subi: r30 = r31, 4' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'subi: r30 = r31, 4'
[DISASSEMBLE] -> Parte do opcode: 'subi', Parte dos operandos: 'r30 = r31, 4'
[DISASSEMBLE] -> Sufixo de suporte encontrado: 'i'. Opcode final é 'sub'
[DISASSEMBLE] -> Opcode final: 'sub', Tipo: 00
[DISASSEMBLE] -> Instrução com atribuição. Destino: 'r30', Origem: 'r31, 4'
[DISASSEMBLE] -> Operandos finais: Rd='r30', Rh='r31', Op2='4'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'i', 'opcode': 'sub', 'type': '00', 'rd': 'r30', 'rh': 'r31', 'op2': '4'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'sub', 'type': '00', 'rd': 'r30', 'rh': 'r31', 'op2': '4'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'sub', 'type': '00', 'rd': 'r30', 'rh': 'r31', 'op2': '4'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000010000111110111110000000100

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'store: [r30] = r4' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'store: [r30] = r4'
[DISASSEMBLE] -> Parte do opcode: 'store', Parte dos operandos: '[r30] = r4'
[DISASSEMBLE] -> Opcode final: 'store', Tipo: 01
[DISASSEMBLE] -> Instrução Store com endereçamento por registrador. Dest detectado: [r30]. Source detectado: 'r4'
[DISASSEMBLE] -> Instrução Load/Store com endereçamento por registrador.
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'na', 'opcode': 'store', 'type': '01', 'rd': 'r0', 'op2': 'r30', 'rh': 'r4'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'store', 'type': '01', 'rd': 'r0', 'op2': 'r30', 'rh': 'r4'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'store', 'type': '01', 'rd': 'r0', 'op2': 'r30', 'rh': 'r4'}
[ENCODE] -> Instrução Store detectada.
[ENCODE] -> rd_bin, rh_bin calculados: Rd(r0)=:00000 e Rh(r4)=:00100
[ENCODE] -> Op2 é um registrador: r30, convertido para binário: 1111000000
[INSTRUCTION] -> Codificação concluída. Binário: 00000100000000000001001111000000

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'subi: r30 = r31, 1' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'subi: r30 = r31, 1'
[DISASSEMBLE] -> Parte do opcode: 'subi', Parte dos operandos: 'r30 = r31, 1'
[DISASSEMBLE] -> Sufixo de suporte encontrado: 'i'. Opcode final é 'sub'
[DISASSEMBLE] -> Opcode final: 'sub', Tipo: 00
[DISASSEMBLE] -> Instrução com atribuição. Destino: 'r30', Origem: 'r31, 1'
[DISASSEMBLE] -> Operandos finais: Rd='r30', Rh='r31', Op2='1'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'i', 'opcode': 'sub', 'type': '00', 'rd': 'r30', 'rh': 'r31', 'op2': '1'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'sub', 'type': '00', 'rd': 'r30', 'rh': 'r31', 'op2': '1'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'sub', 'type': '00', 'rd': 'r30', 'rh': 'r31', 'op2': '1'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000010000111110111110000000001

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'load: r5 = [r30]' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'load: r5 = [r30]'
[DISASSEMBLE] -> Parte do opcode: 'load', Parte dos operandos: 'r5 = [r30]'
[DISASSEMBLE] -> Opcode final: 'load', Tipo: 01
[DISASSEMBLE] -> Instrução Load/Store com endereçamento por registrador.
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'na', 'opcode': 'load', 'type': '01', 'rd': 'r5', 'rh': 'r0', 'op2': 'r30'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'load', 'type': '01', 'rd': 'r5', 'rh': 'r0', 'op2': 'r30'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'load', 'type': '01', 'rd': 'r5', 'rh': 'r0', 'op2': 'r30'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000100000100101000001111000000

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'subi: r6 = r5, 1' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'subi: r6 = r5, 1'
[DISASSEMBLE] -> Parte do opcode: 'subi', Parte dos operandos: 'r6 = r5, 1'
[DISASSEMBLE] -> Sufixo de suporte encontrado: 'i'. Opcode final é 'sub'
[DISASSEMBLE] -> Opcode final: 'sub', Tipo: 00
[DISASSEMBLE] -> Instrução com atribuição. Destino: 'r6', Origem: 'r5, 1'
[DISASSEMBLE] -> Operandos finais: Rd='r6', Rh='r5', Op2='1'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'i', 'opcode': 'sub', 'type': '00', 'rd': 'r6', 'rh': 'r5', 'op2': '1'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'sub', 'type': '00', 'rd': 'r6', 'rh': 'r5', 'op2': '1'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'sub', 'type': '00', 'rd': 'r6', 'rh': 'r5', 'op2': '1'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000010000100110001010000000001

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'subs: r0 = r4, r6' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'subs: r0 = r4, r6'
[DISASSEMBLE] -> Parte do opcode: 'subs', Parte dos operandos: 'r0 = r4, r6'
[DISASSEMBLE] -> Sufixo de suporte encontrado: 's'. Opcode final é 'sub'
[DISASSEMBLE] -> Opcode final: 'sub', Tipo: 00
[DISASSEMBLE] -> Instrução com atribuição. Destino: 'r0', Origem: 'r4, r6'
[DISASSEMBLE] -> Operandos finais: Rd='r0', Rh='r4', Op2='r6'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 's', 'opcode': 'sub', 'type': '00', 'rd': 'r0', 'rh': 'r4', 'op2': 'r6'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 's', 'opcode': 'sub', 'type': '00', 'rd': 'r0', 'rh': 'r4', 'op2': 'r6'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 's', 'opcode': 'sub', 'type': '00', 'rd': 'r0', 'rh': 'r4', 'op2': 'r6'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000001000100000001000011000000

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'bigteq: L5' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'bigteq: L5'
[DISASSEMBLE] -> Parte do opcode: 'bigteq', Parte dos operandos: 'L5'
[DISASSEMBLE] -> Instrução de branch identificada: 'bigteq'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'gteq', 'supp': 'i', 'opcode': 'b', 'type': '11', 'op2': 'L5'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'gteq', 'supp': 'i', 'opcode': 'b', 'type': '11', 'op2': 'L5'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'gteq', 'supp': 'i', 'opcode': 'b', 'type': '11', 'op2': 'L5'}
[ENCODE] -> Instrução de branch detectada: b com condição gteq
[INSTRUCTION] -> Codificação concluída. Binário: 01001110000000000000000000011111

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'subi: r30 = r31, 2' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'subi: r30 = r31, 2'
[DISASSEMBLE] -> Parte do opcode: 'subi', Parte dos operandos: 'r30 = r31, 2'
[DISASSEMBLE] -> Sufixo de suporte encontrado: 'i'. Opcode final é 'sub'
[DISASSEMBLE] -> Opcode final: 'sub', Tipo: 00
[DISASSEMBLE] -> Instrução com atribuição. Destino: 'r30', Origem: 'r31, 2'
[DISASSEMBLE] -> Operandos finais: Rd='r30', Rh='r31', Op2='2'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'i', 'opcode': 'sub', 'type': '00', 'rd': 'r30', 'rh': 'r31', 'op2': '2'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'sub', 'type': '00', 'rd': 'r30', 'rh': 'r31', 'op2': '2'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'sub', 'type': '00', 'rd': 'r30', 'rh': 'r31', 'op2': '2'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000010000111110111110000000010

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'load: r7 = [r30]' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'load: r7 = [r30]'
[DISASSEMBLE] -> Parte do opcode: 'load', Parte dos operandos: 'r7 = [r30]'
[DISASSEMBLE] -> Opcode final: 'load', Tipo: 01
[DISASSEMBLE] -> Instrução Load/Store com endereçamento por registrador.
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'na', 'opcode': 'load', 'type': '01', 'rd': 'r7', 'rh': 'r0', 'op2': 'r30'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'load', 'type': '01', 'rd': 'r7', 'rh': 'r0', 'op2': 'r30'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'load', 'type': '01', 'rd': 'r7', 'rh': 'r0', 'op2': 'r30'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000100000100111000001111000000

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'mov: r1 = r7' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'mov: r1 = r7'
[DISASSEMBLE] -> Parte do opcode: 'mov', Parte dos operandos: 'r1 = r7'
[DISASSEMBLE] -> Opcode final: 'mov', Tipo: 00
[DISASSEMBLE] -> Instrução 'mov' identificada. Destino: 'r1', Origem: 'r7'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'na', 'opcode': 'mov', 'type': '00', 'rd': 'r1', 'rh': 'r0', 'op2': 'r7'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'mov', 'type': '00', 'rd': 'r1', 'rh': 'r0', 'op2': 'r7'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'mov', 'type': '00', 'rd': 'r1', 'rh': 'r0', 'op2': 'r7'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000000100000001000000011100000

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'mov: r2 = r4' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'mov: r2 = r4'
[DISASSEMBLE] -> Parte do opcode: 'mov', Parte dos operandos: 'r2 = r4'
[DISASSEMBLE] -> Opcode final: 'mov', Tipo: 00
[DISASSEMBLE] -> Instrução 'mov' identificada. Destino: 'r2', Origem: 'r4'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'na', 'opcode': 'mov', 'type': '00', 'rd': 'r2', 'rh': 'r0', 'op2': 'r4'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'mov', 'type': '00', 'rd': 'r2', 'rh': 'r0', 'op2': 'r4'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'mov', 'type': '00', 'rd': 'r2', 'rh': 'r0', 'op2': 'r4'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000000100000010000000010000000

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'mov: r3 = r5' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'mov: r3 = r5'
[DISASSEMBLE] -> Parte do opcode: 'mov', Parte dos operandos: 'r3 = r5'
[DISASSEMBLE] -> Opcode final: 'mov', Tipo: 00
[DISASSEMBLE] -> Instrução 'mov' identificada. Destino: 'r3', Origem: 'r5'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'na', 'opcode': 'mov', 'type': '00', 'rd': 'r3', 'rh': 'r0', 'op2': 'r5'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'mov', 'type': '00', 'rd': 'r3', 'rh': 'r0', 'op2': 'r5'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'mov', 'type': '00', 'rd': 'r3', 'rh': 'r0', 'op2': 'r5'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000000100000011000000010100000

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'movi: r8 = sort_Lret0' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'movi: r8 = sort_Lret0'
[DISASSEMBLE] -> Parte do opcode: 'movi', Parte dos operandos: 'r8 = sort_Lret0'
[DISASSEMBLE] -> Sufixo de suporte encontrado: 'i'. Opcode final é 'mov'
[DISASSEMBLE] -> Opcode final: 'mov', Tipo: 00
[DISASSEMBLE] -> Instrução 'mov' identificada. Destino: 'r8', Origem: 'sort_Lret0'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'i', 'opcode': 'mov', 'type': '00', 'rd': 'r8', 'rh': 'r0', 'op2': 'sort_Lret0'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'mov', 'type': '00', 'rd': 'r8', 'rh': 'r0', 'op2': 'sort_Lret0'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'mov', 'type': '00', 'rd': 'r8', 'rh': 'r0', 'op2': 'sort_Lret0'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000010100001000000000001011101

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'mov: r28 = r8' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'mov: r28 = r8'
[DISASSEMBLE] -> Parte do opcode: 'mov', Parte dos operandos: 'r28 = r8'
[DISASSEMBLE] -> Opcode final: 'mov', Tipo: 00
[DISASSEMBLE] -> Instrução 'mov' identificada. Destino: 'r28', Origem: 'r8'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'na', 'opcode': 'mov', 'type': '00', 'rd': 'r28', 'rh': 'r0', 'op2': 'r8'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'mov', 'type': '00', 'rd': 'r28', 'rh': 'r0', 'op2': 'r8'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'mov', 'type': '00', 'rd': 'r28', 'rh': 'r0', 'op2': 'r8'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000000100011100000000100000000

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'bl: minloc' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'bl: minloc'
[DISASSEMBLE] -> Parte do opcode: 'bl', Parte dos operandos: 'minloc'
[DISASSEMBLE] -> Instrução de branch com link identificada: 'bl'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'i', 'opcode': 'bl', 'type': '11', 'op2': 'minloc'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'bl', 'type': '11', 'op2': 'minloc'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'bl', 'type': '11', 'op2': 'minloc'}
[ENCODE] -> Instrução de branch detectada: bl com condição do
[INSTRUCTION] -> Codificação concluída. Binário: 00001110100011111111111110100100

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'mov: r9 = r0' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'mov: r9 = r0'
[DISASSEMBLE] -> Parte do opcode: 'mov', Parte dos operandos: 'r9 = r0'
[DISASSEMBLE] -> Opcode final: 'mov', Tipo: 00
[DISASSEMBLE] -> Instrução 'mov' identificada. Destino: 'r9', Origem: 'r0'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'na', 'opcode': 'mov', 'type': '00', 'rd': 'r9', 'rh': 'r0', 'op2': 'r0'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'mov', 'type': '00', 'rd': 'r9', 'rh': 'r0', 'op2': 'r0'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'mov', 'type': '00', 'rd': 'r9', 'rh': 'r0', 'op2': 'r0'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000000100001001000000000000000

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'subi: r30 = r31, 5' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'subi: r30 = r31, 5'
[DISASSEMBLE] -> Parte do opcode: 'subi', Parte dos operandos: 'r30 = r31, 5'
[DISASSEMBLE] -> Sufixo de suporte encontrado: 'i'. Opcode final é 'sub'
[DISASSEMBLE] -> Opcode final: 'sub', Tipo: 00
[DISASSEMBLE] -> Instrução com atribuição. Destino: 'r30', Origem: 'r31, 5'
[DISASSEMBLE] -> Operandos finais: Rd='r30', Rh='r31', Op2='5'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'i', 'opcode': 'sub', 'type': '00', 'rd': 'r30', 'rh': 'r31', 'op2': '5'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'sub', 'type': '00', 'rd': 'r30', 'rh': 'r31', 'op2': '5'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'sub', 'type': '00', 'rd': 'r30', 'rh': 'r31', 'op2': '5'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000010000111110111110000000101

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'store: [r30] = r9' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'store: [r30] = r9'
[DISASSEMBLE] -> Parte do opcode: 'store', Parte dos operandos: '[r30] = r9'
[DISASSEMBLE] -> Opcode final: 'store', Tipo: 01
[DISASSEMBLE] -> Instrução Store com endereçamento por registrador. Dest detectado: [r30]. Source detectado: 'r9'
[DISASSEMBLE] -> Instrução Load/Store com endereçamento por registrador.
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'na', 'opcode': 'store', 'type': '01', 'rd': 'r0', 'op2': 'r30', 'rh': 'r9'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'store', 'type': '01', 'rd': 'r0', 'op2': 'r30', 'rh': 'r9'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'store', 'type': '01', 'rd': 'r0', 'op2': 'r30', 'rh': 'r9'}
[ENCODE] -> Instrução Store detectada.
[ENCODE] -> rd_bin, rh_bin calculados: Rd(r0)=:00000 e Rh(r9)=:01001
[ENCODE] -> Op2 é um registrador: r30, convertido para binário: 1111000000
[INSTRUCTION] -> Codificação concluída. Binário: 00000100000000000010011111000000

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'subi: r30 = r31, 2' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'subi: r30 = r31, 2'
[DISASSEMBLE] -> Parte do opcode: 'subi', Parte dos operandos: 'r30 = r31, 2'
[DISASSEMBLE] -> Sufixo de suporte encontrado: 'i'. Opcode final é 'sub'
[DISASSEMBLE] -> Opcode final: 'sub', Tipo: 00
[DISASSEMBLE] -> Instrução com atribuição. Destino: 'r30', Origem: 'r31, 2'
[DISASSEMBLE] -> Operandos finais: Rd='r30', Rh='r31', Op2='2'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'i', 'opcode': 'sub', 'type': '00', 'rd': 'r30', 'rh': 'r31', 'op2': '2'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'sub', 'type': '00', 'rd': 'r30', 'rh': 'r31', 'op2': '2'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'sub', 'type': '00', 'rd': 'r30', 'rh': 'r31', 'op2': '2'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000010000111110111110000000010

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'load: r10 = [r30]' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'load: r10 = [r30]'
[DISASSEMBLE] -> Parte do opcode: 'load', Parte dos operandos: 'r10 = [r30]'
[DISASSEMBLE] -> Opcode final: 'load', Tipo: 01
[DISASSEMBLE] -> Instrução Load/Store com endereçamento por registrador.
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'na', 'opcode': 'load', 'type': '01', 'rd': 'r10', 'rh': 'r0', 'op2': 'r30'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'load', 'type': '01', 'rd': 'r10', 'rh': 'r0', 'op2': 'r30'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'load', 'type': '01', 'rd': 'r10', 'rh': 'r0', 'op2': 'r30'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000100000101010000001111000000

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'add: r11 = r10, r9' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'add: r11 = r10, r9'
[DISASSEMBLE] -> Parte do opcode: 'add', Parte dos operandos: 'r11 = r10, r9'
[DISASSEMBLE] -> Opcode final: 'add', Tipo: 00
[DISASSEMBLE] -> Instrução com atribuição. Destino: 'r11', Origem: 'r10, r9'
[DISASSEMBLE] -> Operandos finais: Rd='r11', Rh='r10', Op2='r9'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'na', 'opcode': 'add', 'type': '00', 'rd': 'r11', 'rh': 'r10', 'op2': 'r9'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'add', 'type': '00', 'rd': 'r11', 'rh': 'r10', 'op2': 'r9'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'add', 'type': '00', 'rd': 'r11', 'rh': 'r10', 'op2': 'r9'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000000000001011010100100100000

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'load: r12 = [r11]' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'load: r12 = [r11]'
[DISASSEMBLE] -> Parte do opcode: 'load', Parte dos operandos: 'r12 = [r11]'
[DISASSEMBLE] -> Opcode final: 'load', Tipo: 01
[DISASSEMBLE] -> Instrução Load/Store com endereçamento por registrador.
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'na', 'opcode': 'load', 'type': '01', 'rd': 'r12', 'rh': 'r0', 'op2': 'r11'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'load', 'type': '01', 'rd': 'r12', 'rh': 'r0', 'op2': 'r11'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'load', 'type': '01', 'rd': 'r12', 'rh': 'r0', 'op2': 'r11'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000100000101100000000101100000

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'subi: r30 = r31, 4' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'subi: r30 = r31, 4'
[DISASSEMBLE] -> Parte do opcode: 'subi', Parte dos operandos: 'r30 = r31, 4'
[DISASSEMBLE] -> Sufixo de suporte encontrado: 'i'. Opcode final é 'sub'
[DISASSEMBLE] -> Opcode final: 'sub', Tipo: 00
[DISASSEMBLE] -> Instrução com atribuição. Destino: 'r30', Origem: 'r31, 4'
[DISASSEMBLE] -> Operandos finais: Rd='r30', Rh='r31', Op2='4'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'i', 'opcode': 'sub', 'type': '00', 'rd': 'r30', 'rh': 'r31', 'op2': '4'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'sub', 'type': '00', 'rd': 'r30', 'rh': 'r31', 'op2': '4'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'sub', 'type': '00', 'rd': 'r30', 'rh': 'r31', 'op2': '4'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000010000111110111110000000100

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'load: r13 = [r30]' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'load: r13 = [r30]'
[DISASSEMBLE] -> Parte do opcode: 'load', Parte dos operandos: 'r13 = [r30]'
[DISASSEMBLE] -> Opcode final: 'load', Tipo: 01
[DISASSEMBLE] -> Instrução Load/Store com endereçamento por registrador.
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'na', 'opcode': 'load', 'type': '01', 'rd': 'r13', 'rh': 'r0', 'op2': 'r30'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'load', 'type': '01', 'rd': 'r13', 'rh': 'r0', 'op2': 'r30'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'load', 'type': '01', 'rd': 'r13', 'rh': 'r0', 'op2': 'r30'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000100000101101000001111000000

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'add: r14 = r10, r13' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'add: r14 = r10, r13'
[DISASSEMBLE] -> Parte do opcode: 'add', Parte dos operandos: 'r14 = r10, r13'
[DISASSEMBLE] -> Opcode final: 'add', Tipo: 00
[DISASSEMBLE] -> Instrução com atribuição. Destino: 'r14', Origem: 'r10, r13'
[DISASSEMBLE] -> Operandos finais: Rd='r14', Rh='r10', Op2='r13'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'na', 'opcode': 'add', 'type': '00', 'rd': 'r14', 'rh': 'r10', 'op2': 'r13'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'add', 'type': '00', 'rd': 'r14', 'rh': 'r10', 'op2': 'r13'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'add', 'type': '00', 'rd': 'r14', 'rh': 'r10', 'op2': 'r13'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000000000001110010100110100000

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'load: r15 = [r14]' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'load: r15 = [r14]'
[DISASSEMBLE] -> Parte do opcode: 'load', Parte dos operandos: 'r15 = [r14]'
[DISASSEMBLE] -> Opcode final: 'load', Tipo: 01
[DISASSEMBLE] -> Instrução Load/Store com endereçamento por registrador.
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'na', 'opcode': 'load', 'type': '01', 'rd': 'r15', 'rh': 'r0', 'op2': 'r14'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'load', 'type': '01', 'rd': 'r15', 'rh': 'r0', 'op2': 'r14'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'load', 'type': '01', 'rd': 'r15', 'rh': 'r0', 'op2': 'r14'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000100000101111000000111000000

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'add: r16 = r10, r9' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'add: r16 = r10, r9'
[DISASSEMBLE] -> Parte do opcode: 'add', Parte dos operandos: 'r16 = r10, r9'
[DISASSEMBLE] -> Opcode final: 'add', Tipo: 00
[DISASSEMBLE] -> Instrução com atribuição. Destino: 'r16', Origem: 'r10, r9'
[DISASSEMBLE] -> Operandos finais: Rd='r16', Rh='r10', Op2='r9'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'na', 'opcode': 'add', 'type': '00', 'rd': 'r16', 'rh': 'r10', 'op2': 'r9'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'add', 'type': '00', 'rd': 'r16', 'rh': 'r10', 'op2': 'r9'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'add', 'type': '00', 'rd': 'r16', 'rh': 'r10', 'op2': 'r9'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000000000010000010100100100000

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'store: [r16] = r15' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'store: [r16] = r15'
[DISASSEMBLE] -> Parte do opcode: 'store', Parte dos operandos: '[r16] = r15'
[DISASSEMBLE] -> Opcode final: 'store', Tipo: 01
[DISASSEMBLE] -> Instrução Store com endereçamento por registrador. Dest detectado: [r16]. Source detectado: 'r15'
[DISASSEMBLE] -> Instrução Load/Store com endereçamento por registrador.
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'na', 'opcode': 'store', 'type': '01', 'rd': 'r0', 'op2': 'r16', 'rh': 'r15'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'store', 'type': '01', 'rd': 'r0', 'op2': 'r16', 'rh': 'r15'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'store', 'type': '01', 'rd': 'r0', 'op2': 'r16', 'rh': 'r15'}
[ENCODE] -> Instrução Store detectada.
[ENCODE] -> rd_bin, rh_bin calculados: Rd(r0)=:00000 e Rh(r15)=:01111
[ENCODE] -> Op2 é um registrador: r16, convertido para binário: 1000000000
[INSTRUCTION] -> Codificação concluída. Binário: 00000100000000000011111000000000

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'add: r17 = r10, r13' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'add: r17 = r10, r13'
[DISASSEMBLE] -> Parte do opcode: 'add', Parte dos operandos: 'r17 = r10, r13'
[DISASSEMBLE] -> Opcode final: 'add', Tipo: 00
[DISASSEMBLE] -> Instrução com atribuição. Destino: 'r17', Origem: 'r10, r13'
[DISASSEMBLE] -> Operandos finais: Rd='r17', Rh='r10', Op2='r13'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'na', 'opcode': 'add', 'type': '00', 'rd': 'r17', 'rh': 'r10', 'op2': 'r13'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'add', 'type': '00', 'rd': 'r17', 'rh': 'r10', 'op2': 'r13'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'add', 'type': '00', 'rd': 'r17', 'rh': 'r10', 'op2': 'r13'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000000000010001010100110100000

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'store: [r17] = r18' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'store: [r17] = r18'
[DISASSEMBLE] -> Parte do opcode: 'store', Parte dos operandos: '[r17] = r18'
[DISASSEMBLE] -> Opcode final: 'store', Tipo: 01
[DISASSEMBLE] -> Instrução Store com endereçamento por registrador. Dest detectado: [r17]. Source detectado: 'r18'
[DISASSEMBLE] -> Instrução Load/Store com endereçamento por registrador.
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'na', 'opcode': 'store', 'type': '01', 'rd': 'r0', 'op2': 'r17', 'rh': 'r18'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'store', 'type': '01', 'rd': 'r0', 'op2': 'r17', 'rh': 'r18'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'store', 'type': '01', 'rd': 'r0', 'op2': 'r17', 'rh': 'r18'}
[ENCODE] -> Instrução Store detectada.
[ENCODE] -> rd_bin, rh_bin calculados: Rd(r0)=:00000 e Rh(r18)=:10010
[ENCODE] -> Op2 é um registrador: r17, convertido para binário: 1000100000
[INSTRUCTION] -> Codificação concluída. Binário: 00000100000000000100101000100000

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'addi: r19 = r13, 1' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'addi: r19 = r13, 1'
[DISASSEMBLE] -> Parte do opcode: 'addi', Parte dos operandos: 'r19 = r13, 1'
[DISASSEMBLE] -> Sufixo de suporte encontrado: 'i'. Opcode final é 'add'
[DISASSEMBLE] -> Opcode final: 'add', Tipo: 00
[DISASSEMBLE] -> Instrução com atribuição. Destino: 'r19', Origem: 'r13, 1'
[DISASSEMBLE] -> Operandos finais: Rd='r19', Rh='r13', Op2='1'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'i', 'opcode': 'add', 'type': '00', 'rd': 'r19', 'rh': 'r13', 'op2': '1'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'add', 'type': '00', 'rd': 'r19', 'rh': 'r13', 'op2': '1'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'add', 'type': '00', 'rd': 'r19', 'rh': 'r13', 'op2': '1'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000010000010011011010000000001

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'subi: r30 = r31, 4' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'subi: r30 = r31, 4'
[DISASSEMBLE] -> Parte do opcode: 'subi', Parte dos operandos: 'r30 = r31, 4'
[DISASSEMBLE] -> Sufixo de suporte encontrado: 'i'. Opcode final é 'sub'
[DISASSEMBLE] -> Opcode final: 'sub', Tipo: 00
[DISASSEMBLE] -> Instrução com atribuição. Destino: 'r30', Origem: 'r31, 4'
[DISASSEMBLE] -> Operandos finais: Rd='r30', Rh='r31', Op2='4'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'i', 'opcode': 'sub', 'type': '00', 'rd': 'r30', 'rh': 'r31', 'op2': '4'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'sub', 'type': '00', 'rd': 'r30', 'rh': 'r31', 'op2': '4'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'sub', 'type': '00', 'rd': 'r30', 'rh': 'r31', 'op2': '4'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000010000111110111110000000100

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'store: [r30] = r19' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'store: [r30] = r19'
[DISASSEMBLE] -> Parte do opcode: 'store', Parte dos operandos: '[r30] = r19'
[DISASSEMBLE] -> Opcode final: 'store', Tipo: 01
[DISASSEMBLE] -> Instrução Store com endereçamento por registrador. Dest detectado: [r30]. Source detectado: 'r19'
[DISASSEMBLE] -> Instrução Load/Store com endereçamento por registrador.
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'na', 'opcode': 'store', 'type': '01', 'rd': 'r0', 'op2': 'r30', 'rh': 'r19'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'store', 'type': '01', 'rd': 'r0', 'op2': 'r30', 'rh': 'r19'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'store', 'type': '01', 'rd': 'r0', 'op2': 'r30', 'rh': 'r19'}
[ENCODE] -> Instrução Store detectada.
[ENCODE] -> rd_bin, rh_bin calculados: Rd(r0)=:00000 e Rh(r19)=:10011
[ENCODE] -> Op2 é um registrador: r30, convertido para binário: 1111000000
[INSTRUCTION] -> Codificação concluída. Binário: 00000100000000000100111111000000

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'subi: r30 = r31, 5' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'subi: r30 = r31, 5'
[DISASSEMBLE] -> Parte do opcode: 'subi', Parte dos operandos: 'r30 = r31, 5'
[DISASSEMBLE] -> Sufixo de suporte encontrado: 'i'. Opcode final é 'sub'
[DISASSEMBLE] -> Opcode final: 'sub', Tipo: 00
[DISASSEMBLE] -> Instrução com atribuição. Destino: 'r30', Origem: 'r31, 5'
[DISASSEMBLE] -> Operandos finais: Rd='r30', Rh='r31', Op2='5'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'i', 'opcode': 'sub', 'type': '00', 'rd': 'r30', 'rh': 'r31', 'op2': '5'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'sub', 'type': '00', 'rd': 'r30', 'rh': 'r31', 'op2': '5'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'sub', 'type': '00', 'rd': 'r30', 'rh': 'r31', 'op2': '5'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000010000111110111110000000101

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'store: [r30] = r9' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'store: [r30] = r9'
[DISASSEMBLE] -> Parte do opcode: 'store', Parte dos operandos: '[r30] = r9'
[DISASSEMBLE] -> Opcode final: 'store', Tipo: 01
[DISASSEMBLE] -> Instrução Store com endereçamento por registrador. Dest detectado: [r30]. Source detectado: 'r9'
[DISASSEMBLE] -> Instrução Load/Store com endereçamento por registrador.
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'na', 'opcode': 'store', 'type': '01', 'rd': 'r0', 'op2': 'r30', 'rh': 'r9'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'store', 'type': '01', 'rd': 'r0', 'op2': 'r30', 'rh': 'r9'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'store', 'type': '01', 'rd': 'r0', 'op2': 'r30', 'rh': 'r9'}
[ENCODE] -> Instrução Store detectada.
[ENCODE] -> rd_bin, rh_bin calculados: Rd(r0)=:00000 e Rh(r9)=:01001
[ENCODE] -> Op2 é um registrador: r30, convertido para binário: 1111000000
[INSTRUCTION] -> Codificação concluída. Binário: 00000100000000000010011111000000

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'subi: r30 = r31, 4' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'subi: r30 = r31, 4'
[DISASSEMBLE] -> Parte do opcode: 'subi', Parte dos operandos: 'r30 = r31, 4'
[DISASSEMBLE] -> Sufixo de suporte encontrado: 'i'. Opcode final é 'sub'
[DISASSEMBLE] -> Opcode final: 'sub', Tipo: 00
[DISASSEMBLE] -> Instrução com atribuição. Destino: 'r30', Origem: 'r31, 4'
[DISASSEMBLE] -> Operandos finais: Rd='r30', Rh='r31', Op2='4'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'i', 'opcode': 'sub', 'type': '00', 'rd': 'r30', 'rh': 'r31', 'op2': '4'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'sub', 'type': '00', 'rd': 'r30', 'rh': 'r31', 'op2': '4'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'sub', 'type': '00', 'rd': 'r30', 'rh': 'r31', 'op2': '4'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000010000111110111110000000100

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'store: [r30] = r19' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'store: [r30] = r19'
[DISASSEMBLE] -> Parte do opcode: 'store', Parte dos operandos: '[r30] = r19'
[DISASSEMBLE] -> Opcode final: 'store', Tipo: 01
[DISASSEMBLE] -> Instrução Store com endereçamento por registrador. Dest detectado: [r30]. Source detectado: 'r19'
[DISASSEMBLE] -> Instrução Load/Store com endereçamento por registrador.
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'na', 'opcode': 'store', 'type': '01', 'rd': 'r0', 'op2': 'r30', 'rh': 'r19'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'store', 'type': '01', 'rd': 'r0', 'op2': 'r30', 'rh': 'r19'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'store', 'type': '01', 'rd': 'r0', 'op2': 'r30', 'rh': 'r19'}
[ENCODE] -> Instrução Store detectada.
[ENCODE] -> rd_bin, rh_bin calculados: Rd(r0)=:00000 e Rh(r19)=:10011
[ENCODE] -> Op2 é um registrador: r30, convertido para binário: 1111000000
[INSTRUCTION] -> Codificação concluída. Binário: 00000100000000000100111111000000

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'bi: L4' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'bi: L4'
[DISASSEMBLE] -> Parte do opcode: 'bi', Parte dos operandos: 'L4'
[DISASSEMBLE] -> Instrução de branch identificada: 'bi'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'i', 'opcode': 'b', 'type': '11', 'op2': 'L4'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'b', 'type': '11', 'op2': 'L4'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'b', 'type': '11', 'op2': 'L4'}
[ENCODE] -> Instrução de branch detectada: b com condição do
[INSTRUCTION] -> Codificação concluída. Binário: 00001110000011111111111111011100

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'bi: sort_epilogue' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'bi: sort_epilogue'
[DISASSEMBLE] -> Parte do opcode: 'bi', Parte dos operandos: 'sort_epilogue'
[DISASSEMBLE] -> Instrução de branch identificada: 'bi'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'i', 'opcode': 'b', 'type': '11', 'op2': 'sort_epilogue'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'b', 'type': '11', 'op2': 'sort_epilogue'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'b', 'type': '11', 'op2': 'sort_epilogue'}
[ENCODE] -> Instrução de branch detectada: b com condição do
[INSTRUCTION] -> Codificação concluída. Binário: 00001110000000000000000000000000

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'mov: r29 = r31' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'mov: r29 = r31'
[DISASSEMBLE] -> Parte do opcode: 'mov', Parte dos operandos: 'r29 = r31'
[DISASSEMBLE] -> Opcode final: 'mov', Tipo: 00
[DISASSEMBLE] -> Instrução 'mov' identificada. Destino: 'r29', Origem: 'r31'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'na', 'opcode': 'mov', 'type': '00', 'rd': 'r29', 'rh': 'r0', 'op2': 'r31'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'mov', 'type': '00', 'rd': 'r29', 'rh': 'r0', 'op2': 'r31'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'mov', 'type': '00', 'rd': 'r29', 'rh': 'r0', 'op2': 'r31'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000000100011101000001111100000

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'load: r31 = [r29]' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'load: r31 = [r29]'
[DISASSEMBLE] -> Parte do opcode: 'load', Parte dos operandos: 'r31 = [r29]'
[DISASSEMBLE] -> Opcode final: 'load', Tipo: 01
[DISASSEMBLE] -> Instrução Load/Store com endereçamento por registrador.
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'na', 'opcode': 'load', 'type': '01', 'rd': 'r31', 'rh': 'r0', 'op2': 'r29'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'load', 'type': '01', 'rd': 'r31', 'rh': 'r0', 'op2': 'r29'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'load', 'type': '01', 'rd': 'r31', 'rh': 'r0', 'op2': 'r29'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000100000111111000001110100000

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'addi: r29 = r29, 1' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'addi: r29 = r29, 1'
[DISASSEMBLE] -> Parte do opcode: 'addi', Parte dos operandos: 'r29 = r29, 1'
[DISASSEMBLE] -> Sufixo de suporte encontrado: 'i'. Opcode final é 'add'
[DISASSEMBLE] -> Opcode final: 'add', Tipo: 00
[DISASSEMBLE] -> Instrução com atribuição. Destino: 'r29', Origem: 'r29, 1'
[DISASSEMBLE] -> Operandos finais: Rd='r29', Rh='r29', Op2='1'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'i', 'opcode': 'add', 'type': '00', 'rd': 'r29', 'rh': 'r29', 'op2': '1'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'add', 'type': '00', 'rd': 'r29', 'rh': 'r29', 'op2': '1'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'add', 'type': '00', 'rd': 'r29', 'rh': 'r29', 'op2': '1'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000010000011101111010000000001

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'load: r28 = [r29]' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'load: r28 = [r29]'
[DISASSEMBLE] -> Parte do opcode: 'load', Parte dos operandos: 'r28 = [r29]'
[DISASSEMBLE] -> Opcode final: 'load', Tipo: 01
[DISASSEMBLE] -> Instrução Load/Store com endereçamento por registrador.
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'na', 'opcode': 'load', 'type': '01', 'rd': 'r28', 'rh': 'r0', 'op2': 'r29'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'load', 'type': '01', 'rd': 'r28', 'rh': 'r0', 'op2': 'r29'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'load', 'type': '01', 'rd': 'r28', 'rh': 'r0', 'op2': 'r29'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000100000111100000001110100000

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'addi: r29 = r29, 1' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'addi: r29 = r29, 1'
[DISASSEMBLE] -> Parte do opcode: 'addi', Parte dos operandos: 'r29 = r29, 1'
[DISASSEMBLE] -> Sufixo de suporte encontrado: 'i'. Opcode final é 'add'
[DISASSEMBLE] -> Opcode final: 'add', Tipo: 00
[DISASSEMBLE] -> Instrução com atribuição. Destino: 'r29', Origem: 'r29, 1'
[DISASSEMBLE] -> Operandos finais: Rd='r29', Rh='r29', Op2='1'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'i', 'opcode': 'add', 'type': '00', 'rd': 'r29', 'rh': 'r29', 'op2': '1'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'add', 'type': '00', 'rd': 'r29', 'rh': 'r29', 'op2': '1'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'add', 'type': '00', 'rd': 'r29', 'rh': 'r29', 'op2': '1'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000010000011101111010000000001

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'b: r28' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'b: r28'
[DISASSEMBLE] -> Parte do opcode: 'b', Parte dos operandos: 'r28'
[DISASSEMBLE] -> Instrução de branch identificada: 'b'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'na', 'opcode': 'b', 'type': '11', 'op2': 'r28'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'b', 'type': '11', 'op2': 'r28'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'b', 'type': '11', 'op2': 'r28'}
[ENCODE] -> Instrução de branch detectada: b com condição do
[ENCODE] -> Branch para registrador detectado: r28
[INSTRUCTION] -> Codificação concluída. Binário: 00001100000000000000001110000000

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'movi: r29 = 255' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'movi: r29 = 255'
[DISASSEMBLE] -> Parte do opcode: 'movi', Parte dos operandos: 'r29 = 255'
[DISASSEMBLE] -> Sufixo de suporte encontrado: 'i'. Opcode final é 'mov'
[DISASSEMBLE] -> Opcode final: 'mov', Tipo: 00
[DISASSEMBLE] -> Instrução 'mov' identificada. Destino: 'r29', Origem: '255'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'i', 'opcode': 'mov', 'type': '00', 'rd': 'r29', 'rh': 'r0', 'op2': '255'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'mov', 'type': '00', 'rd': 'r29', 'rh': 'r0', 'op2': '255'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'mov', 'type': '00', 'rd': 'r29', 'rh': 'r0', 'op2': '255'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000010100011101000000011111111

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'mov: r31 = r29' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'mov: r31 = r29'
[DISASSEMBLE] -> Parte do opcode: 'mov', Parte dos operandos: 'r31 = r29'
[DISASSEMBLE] -> Opcode final: 'mov', Tipo: 00
[DISASSEMBLE] -> Instrução 'mov' identificada. Destino: 'r31', Origem: 'r29'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'na', 'opcode': 'mov', 'type': '00', 'rd': 'r31', 'rh': 'r0', 'op2': 'r29'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'mov', 'type': '00', 'rd': 'r31', 'rh': 'r0', 'op2': 'r29'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'mov', 'type': '00', 'rd': 'r31', 'rh': 'r0', 'op2': 'r29'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000000100011111000001110100000

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'subi: r29 = r29, 13' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'subi: r29 = r29, 13'
[DISASSEMBLE] -> Parte do opcode: 'subi', Parte dos operandos: 'r29 = r29, 13'
[DISASSEMBLE] -> Sufixo de suporte encontrado: 'i'. Opcode final é 'sub'
[DISASSEMBLE] -> Opcode final: 'sub', Tipo: 00
[DISASSEMBLE] -> Instrução com atribuição. Destino: 'r29', Origem: 'r29, 13'
[DISASSEMBLE] -> Operandos finais: Rd='r29', Rh='r29', Op2='13'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'i', 'opcode': 'sub', 'type': '00', 'rd': 'r29', 'rh': 'r29', 'op2': '13'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'sub', 'type': '00', 'rd': 'r29', 'rh': 'r29', 'op2': '13'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'sub', 'type': '00', 'rd': 'r29', 'rh': 'r29', 'op2': '13'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000010000111101111010000001101

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'subi: r30 = r31, 1' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'subi: r30 = r31, 1'
[DISASSEMBLE] -> Parte do opcode: 'subi', Parte dos operandos: 'r30 = r31, 1'
[DISASSEMBLE] -> Sufixo de suporte encontrado: 'i'. Opcode final é 'sub'
[DISASSEMBLE] -> Opcode final: 'sub', Tipo: 00
[DISASSEMBLE] -> Instrução com atribuição. Destino: 'r30', Origem: 'r31, 1'
[DISASSEMBLE] -> Operandos finais: Rd='r30', Rh='r31', Op2='1'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'i', 'opcode': 'sub', 'type': '00', 'rd': 'r30', 'rh': 'r31', 'op2': '1'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'sub', 'type': '00', 'rd': 'r30', 'rh': 'r31', 'op2': '1'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'sub', 'type': '00', 'rd': 'r30', 'rh': 'r31', 'op2': '1'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000010000111110111110000000001

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'store: [r30] = r1' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'store: [r30] = r1'
[DISASSEMBLE] -> Parte do opcode: 'store', Parte dos operandos: '[r30] = r1'
[DISASSEMBLE] -> Opcode final: 'store', Tipo: 01
[DISASSEMBLE] -> Instrução Store com endereçamento por registrador. Dest detectado: [r30]. Source detectado: 'r1'
[DISASSEMBLE] -> Instrução Load/Store com endereçamento por registrador.
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'na', 'opcode': 'store', 'type': '01', 'rd': 'r0', 'op2': 'r30', 'rh': 'r1'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'store', 'type': '01', 'rd': 'r0', 'op2': 'r30', 'rh': 'r1'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'store', 'type': '01', 'rd': 'r0', 'op2': 'r30', 'rh': 'r1'}
[ENCODE] -> Instrução Store detectada.
[ENCODE] -> rd_bin, rh_bin calculados: Rd(r0)=:00000 e Rh(r1)=:00001
[ENCODE] -> Op2 é um registrador: r30, convertido para binário: 1111000000
[INSTRUCTION] -> Codificação concluída. Binário: 00000100000000000000011111000000

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'movi: r4 = 0' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'movi: r4 = 0'
[DISASSEMBLE] -> Parte do opcode: 'movi', Parte dos operandos: 'r4 = 0'
[DISASSEMBLE] -> Sufixo de suporte encontrado: 'i'. Opcode final é 'mov'
[DISASSEMBLE] -> Opcode final: 'mov', Tipo: 00
[DISASSEMBLE] -> Instrução 'mov' identificada. Destino: 'r4', Origem: '0'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'i', 'opcode': 'mov', 'type': '00', 'rd': 'r4', 'rh': 'r0', 'op2': '0'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'mov', 'type': '00', 'rd': 'r4', 'rh': 'r0', 'op2': '0'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'mov', 'type': '00', 'rd': 'r4', 'rh': 'r0', 'op2': '0'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000010100000100000000000000000

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'subi: r30 = r31, 2' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'subi: r30 = r31, 2'
[DISASSEMBLE] -> Parte do opcode: 'subi', Parte dos operandos: 'r30 = r31, 2'
[DISASSEMBLE] -> Sufixo de suporte encontrado: 'i'. Opcode final é 'sub'
[DISASSEMBLE] -> Opcode final: 'sub', Tipo: 00
[DISASSEMBLE] -> Instrução com atribuição. Destino: 'r30', Origem: 'r31, 2'
[DISASSEMBLE] -> Operandos finais: Rd='r30', Rh='r31', Op2='2'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'i', 'opcode': 'sub', 'type': '00', 'rd': 'r30', 'rh': 'r31', 'op2': '2'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'sub', 'type': '00', 'rd': 'r30', 'rh': 'r31', 'op2': '2'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'sub', 'type': '00', 'rd': 'r30', 'rh': 'r31', 'op2': '2'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000010000111110111110000000010

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'store: [r30] = r4' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'store: [r30] = r4'
[DISASSEMBLE] -> Parte do opcode: 'store', Parte dos operandos: '[r30] = r4'
[DISASSEMBLE] -> Opcode final: 'store', Tipo: 01
[DISASSEMBLE] -> Instrução Store com endereçamento por registrador. Dest detectado: [r30]. Source detectado: 'r4'
[DISASSEMBLE] -> Instrução Load/Store com endereçamento por registrador.
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'na', 'opcode': 'store', 'type': '01', 'rd': 'r0', 'op2': 'r30', 'rh': 'r4'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'store', 'type': '01', 'rd': 'r0', 'op2': 'r30', 'rh': 'r4'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'store', 'type': '01', 'rd': 'r0', 'op2': 'r30', 'rh': 'r4'}
[ENCODE] -> Instrução Store detectada.
[ENCODE] -> rd_bin, rh_bin calculados: Rd(r0)=:00000 e Rh(r4)=:00100
[ENCODE] -> Op2 é um registrador: r30, convertido para binário: 1111000000
[INSTRUCTION] -> Codificação concluída. Binário: 00000100000000000001001111000000

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'movi: r5 = 2' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'movi: r5 = 2'
[DISASSEMBLE] -> Parte do opcode: 'movi', Parte dos operandos: 'r5 = 2'
[DISASSEMBLE] -> Sufixo de suporte encontrado: 'i'. Opcode final é 'mov'
[DISASSEMBLE] -> Opcode final: 'mov', Tipo: 00
[DISASSEMBLE] -> Instrução 'mov' identificada. Destino: 'r5', Origem: '2'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'i', 'opcode': 'mov', 'type': '00', 'rd': 'r5', 'rh': 'r0', 'op2': '2'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'mov', 'type': '00', 'rd': 'r5', 'rh': 'r0', 'op2': '2'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'mov', 'type': '00', 'rd': 'r5', 'rh': 'r0', 'op2': '2'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000010100000101000000000000010

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'subs: r0 = r4, r5' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'subs: r0 = r4, r5'
[DISASSEMBLE] -> Parte do opcode: 'subs', Parte dos operandos: 'r0 = r4, r5'
[DISASSEMBLE] -> Sufixo de suporte encontrado: 's'. Opcode final é 'sub'
[DISASSEMBLE] -> Opcode final: 'sub', Tipo: 00
[DISASSEMBLE] -> Instrução com atribuição. Destino: 'r0', Origem: 'r4, r5'
[DISASSEMBLE] -> Operandos finais: Rd='r0', Rh='r4', Op2='r5'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 's', 'opcode': 'sub', 'type': '00', 'rd': 'r0', 'rh': 'r4', 'op2': 'r5'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 's', 'opcode': 'sub', 'type': '00', 'rd': 'r0', 'rh': 'r4', 'op2': 'r5'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 's', 'opcode': 'sub', 'type': '00', 'rd': 'r0', 'rh': 'r4', 'op2': 'r5'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000001000100000001000010100000

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'bigteq: L7' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'bigteq: L7'
[DISASSEMBLE] -> Parte do opcode: 'bigteq', Parte dos operandos: 'L7'
[DISASSEMBLE] -> Instrução de branch identificada: 'bigteq'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'gteq', 'supp': 'i', 'opcode': 'b', 'type': '11', 'op2': 'L7'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'gteq', 'supp': 'i', 'opcode': 'b', 'type': '11', 'op2': 'L7'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'gteq', 'supp': 'i', 'opcode': 'b', 'type': '11', 'op2': 'L7'}
[ENCODE] -> Instrução de branch detectada: b com condição gteq
[INSTRUCTION] -> Codificação concluída. Binário: 01001110000000000000000000001011

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'in: r6' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'in: r6'
[DISASSEMBLE] -> Parte do opcode: 'in', Parte dos operandos: 'r6'
[DISASSEMBLE] -> Opcode final: 'in', Tipo: 00
[DISASSEMBLE] -> Instrução de operando único. Rd: 'r6'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'na', 'opcode': 'in', 'type': '00', 'rd': 'r6', 'rh': 'r0', 'op2': '0'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'in', 'type': '00', 'rd': 'r6', 'rh': 'r0', 'op2': '0'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'in', 'type': '00', 'rd': 'r6', 'rh': 'r0', 'op2': '0'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000000100100110000000000000000

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'subi: r8 = r31, 1' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'subi: r8 = r31, 1'
[DISASSEMBLE] -> Parte do opcode: 'subi', Parte dos operandos: 'r8 = r31, 1'
[DISASSEMBLE] -> Sufixo de suporte encontrado: 'i'. Opcode final é 'sub'
[DISASSEMBLE] -> Opcode final: 'sub', Tipo: 00
[DISASSEMBLE] -> Instrução com atribuição. Destino: 'r8', Origem: 'r31, 1'
[DISASSEMBLE] -> Operandos finais: Rd='r8', Rh='r31', Op2='1'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'i', 'opcode': 'sub', 'type': '00', 'rd': 'r8', 'rh': 'r31', 'op2': '1'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'sub', 'type': '00', 'rd': 'r8', 'rh': 'r31', 'op2': '1'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'sub', 'type': '00', 'rd': 'r8', 'rh': 'r31', 'op2': '1'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000010000101000111110000000001

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'mov: r7 = r8' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'mov: r7 = r8'
[DISASSEMBLE] -> Parte do opcode: 'mov', Parte dos operandos: 'r7 = r8'
[DISASSEMBLE] -> Opcode final: 'mov', Tipo: 00
[DISASSEMBLE] -> Instrução 'mov' identificada. Destino: 'r7', Origem: 'r8'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'na', 'opcode': 'mov', 'type': '00', 'rd': 'r7', 'rh': 'r0', 'op2': 'r8'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'mov', 'type': '00', 'rd': 'r7', 'rh': 'r0', 'op2': 'r8'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'mov', 'type': '00', 'rd': 'r7', 'rh': 'r0', 'op2': 'r8'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000000100000111000000100000000

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'add: r9 = r7, r4' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'add: r9 = r7, r4'
[DISASSEMBLE] -> Parte do opcode: 'add', Parte dos operandos: 'r9 = r7, r4'
[DISASSEMBLE] -> Opcode final: 'add', Tipo: 00
[DISASSEMBLE] -> Instrução com atribuição. Destino: 'r9', Origem: 'r7, r4'
[DISASSEMBLE] -> Operandos finais: Rd='r9', Rh='r7', Op2='r4'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'na', 'opcode': 'add', 'type': '00', 'rd': 'r9', 'rh': 'r7', 'op2': 'r4'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'add', 'type': '00', 'rd': 'r9', 'rh': 'r7', 'op2': 'r4'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'add', 'type': '00', 'rd': 'r9', 'rh': 'r7', 'op2': 'r4'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000000000001001001110010000000

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'store: [r9] = r6' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'store: [r9] = r6'
[DISASSEMBLE] -> Parte do opcode: 'store', Parte dos operandos: '[r9] = r6'
[DISASSEMBLE] -> Opcode final: 'store', Tipo: 01
[DISASSEMBLE] -> Instrução Store com endereçamento por registrador. Dest detectado: [r9]. Source detectado: 'r6'
[DISASSEMBLE] -> Instrução Load/Store com endereçamento por registrador.
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'na', 'opcode': 'store', 'type': '01', 'rd': 'r0', 'op2': 'r9', 'rh': 'r6'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'store', 'type': '01', 'rd': 'r0', 'op2': 'r9', 'rh': 'r6'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'store', 'type': '01', 'rd': 'r0', 'op2': 'r9', 'rh': 'r6'}
[ENCODE] -> Instrução Store detectada.
[ENCODE] -> rd_bin, rh_bin calculados: Rd(r0)=:00000 e Rh(r6)=:00110
[ENCODE] -> Op2 é um registrador: r9, convertido para binário: 0100100000
[INSTRUCTION] -> Codificação concluída. Binário: 00000100000000000001100100100000

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'addi: r10 = r4, 1' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'addi: r10 = r4, 1'
[DISASSEMBLE] -> Parte do opcode: 'addi', Parte dos operandos: 'r10 = r4, 1'
[DISASSEMBLE] -> Sufixo de suporte encontrado: 'i'. Opcode final é 'add'
[DISASSEMBLE] -> Opcode final: 'add', Tipo: 00
[DISASSEMBLE] -> Instrução com atribuição. Destino: 'r10', Origem: 'r4, 1'
[DISASSEMBLE] -> Operandos finais: Rd='r10', Rh='r4', Op2='1'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'i', 'opcode': 'add', 'type': '00', 'rd': 'r10', 'rh': 'r4', 'op2': '1'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'add', 'type': '00', 'rd': 'r10', 'rh': 'r4', 'op2': '1'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'add', 'type': '00', 'rd': 'r10', 'rh': 'r4', 'op2': '1'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000010000001010001000000000001

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'subi: r30 = r31, 2' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'subi: r30 = r31, 2'
[DISASSEMBLE] -> Parte do opcode: 'subi', Parte dos operandos: 'r30 = r31, 2'
[DISASSEMBLE] -> Sufixo de suporte encontrado: 'i'. Opcode final é 'sub'
[DISASSEMBLE] -> Opcode final: 'sub', Tipo: 00
[DISASSEMBLE] -> Instrução com atribuição. Destino: 'r30', Origem: 'r31, 2'
[DISASSEMBLE] -> Operandos finais: Rd='r30', Rh='r31', Op2='2'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'i', 'opcode': 'sub', 'type': '00', 'rd': 'r30', 'rh': 'r31', 'op2': '2'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'sub', 'type': '00', 'rd': 'r30', 'rh': 'r31', 'op2': '2'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'sub', 'type': '00', 'rd': 'r30', 'rh': 'r31', 'op2': '2'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000010000111110111110000000010

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'store: [r30] = r10' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'store: [r30] = r10'
[DISASSEMBLE] -> Parte do opcode: 'store', Parte dos operandos: '[r30] = r10'
[DISASSEMBLE] -> Opcode final: 'store', Tipo: 01
[DISASSEMBLE] -> Instrução Store com endereçamento por registrador. Dest detectado: [r30]. Source detectado: 'r10'
[DISASSEMBLE] -> Instrução Load/Store com endereçamento por registrador.
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'na', 'opcode': 'store', 'type': '01', 'rd': 'r0', 'op2': 'r30', 'rh': 'r10'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'store', 'type': '01', 'rd': 'r0', 'op2': 'r30', 'rh': 'r10'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'store', 'type': '01', 'rd': 'r0', 'op2': 'r30', 'rh': 'r10'}
[ENCODE] -> Instrução Store detectada.
[ENCODE] -> rd_bin, rh_bin calculados: Rd(r0)=:00000 e Rh(r10)=:01010
[ENCODE] -> Op2 é um registrador: r30, convertido para binário: 1111000000
[INSTRUCTION] -> Codificação concluída. Binário: 00000100000000000010101111000000

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'subi: r30 = r31, 2' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'subi: r30 = r31, 2'
[DISASSEMBLE] -> Parte do opcode: 'subi', Parte dos operandos: 'r30 = r31, 2'
[DISASSEMBLE] -> Sufixo de suporte encontrado: 'i'. Opcode final é 'sub'
[DISASSEMBLE] -> Opcode final: 'sub', Tipo: 00
[DISASSEMBLE] -> Instrução com atribuição. Destino: 'r30', Origem: 'r31, 2'
[DISASSEMBLE] -> Operandos finais: Rd='r30', Rh='r31', Op2='2'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'i', 'opcode': 'sub', 'type': '00', 'rd': 'r30', 'rh': 'r31', 'op2': '2'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'sub', 'type': '00', 'rd': 'r30', 'rh': 'r31', 'op2': '2'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'sub', 'type': '00', 'rd': 'r30', 'rh': 'r31', 'op2': '2'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000010000111110111110000000010

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'store: [r30] = r10' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'store: [r30] = r10'
[DISASSEMBLE] -> Parte do opcode: 'store', Parte dos operandos: '[r30] = r10'
[DISASSEMBLE] -> Opcode final: 'store', Tipo: 01
[DISASSEMBLE] -> Instrução Store com endereçamento por registrador. Dest detectado: [r30]. Source detectado: 'r10'
[DISASSEMBLE] -> Instrução Load/Store com endereçamento por registrador.
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'na', 'opcode': 'store', 'type': '01', 'rd': 'r0', 'op2': 'r30', 'rh': 'r10'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'store', 'type': '01', 'rd': 'r0', 'op2': 'r30', 'rh': 'r10'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'store', 'type': '01', 'rd': 'r0', 'op2': 'r30', 'rh': 'r10'}
[ENCODE] -> Instrução Store detectada.
[ENCODE] -> rd_bin, rh_bin calculados: Rd(r0)=:00000 e Rh(r10)=:01010
[ENCODE] -> Op2 é um registrador: r30, convertido para binário: 1111000000
[INSTRUCTION] -> Codificação concluída. Binário: 00000100000000000010101111000000

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'bi: L6' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'bi: L6'
[DISASSEMBLE] -> Parte do opcode: 'bi', Parte dos operandos: 'L6'
[DISASSEMBLE] -> Instrução de branch identificada: 'bi'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'i', 'opcode': 'b', 'type': '11', 'op2': 'L6'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'b', 'type': '11', 'op2': 'L6'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'b', 'type': '11', 'op2': 'L6'}
[ENCODE] -> Instrução de branch detectada: b com condição do
[INSTRUCTION] -> Codificação concluída. Binário: 00001110000011111111111111110010

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'subi: r12 = r31, 1' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'subi: r12 = r31, 1'
[DISASSEMBLE] -> Parte do opcode: 'subi', Parte dos operandos: 'r12 = r31, 1'
[DISASSEMBLE] -> Sufixo de suporte encontrado: 'i'. Opcode final é 'sub'
[DISASSEMBLE] -> Opcode final: 'sub', Tipo: 00
[DISASSEMBLE] -> Instrução com atribuição. Destino: 'r12', Origem: 'r31, 1'
[DISASSEMBLE] -> Operandos finais: Rd='r12', Rh='r31', Op2='1'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'i', 'opcode': 'sub', 'type': '00', 'rd': 'r12', 'rh': 'r31', 'op2': '1'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'sub', 'type': '00', 'rd': 'r12', 'rh': 'r31', 'op2': '1'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'sub', 'type': '00', 'rd': 'r12', 'rh': 'r31', 'op2': '1'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000010000101100111110000000001

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'mov: r11 = r12' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'mov: r11 = r12'
[DISASSEMBLE] -> Parte do opcode: 'mov', Parte dos operandos: 'r11 = r12'
[DISASSEMBLE] -> Opcode final: 'mov', Tipo: 00
[DISASSEMBLE] -> Instrução 'mov' identificada. Destino: 'r11', Origem: 'r12'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'na', 'opcode': 'mov', 'type': '00', 'rd': 'r11', 'rh': 'r0', 'op2': 'r12'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'mov', 'type': '00', 'rd': 'r11', 'rh': 'r0', 'op2': 'r12'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'mov', 'type': '00', 'rd': 'r11', 'rh': 'r0', 'op2': 'r12'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000000100001011000000110000000

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'mov: r1 = r11' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'mov: r1 = r11'
[DISASSEMBLE] -> Parte do opcode: 'mov', Parte dos operandos: 'r1 = r11'
[DISASSEMBLE] -> Opcode final: 'mov', Tipo: 00
[DISASSEMBLE] -> Instrução 'mov' identificada. Destino: 'r1', Origem: 'r11'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'na', 'opcode': 'mov', 'type': '00', 'rd': 'r1', 'rh': 'r0', 'op2': 'r11'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'mov', 'type': '00', 'rd': 'r1', 'rh': 'r0', 'op2': 'r11'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'mov', 'type': '00', 'rd': 'r1', 'rh': 'r0', 'op2': 'r11'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000000100000001000000101100000

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'movi: r13 = 0' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'movi: r13 = 0'
[DISASSEMBLE] -> Parte do opcode: 'movi', Parte dos operandos: 'r13 = 0'
[DISASSEMBLE] -> Sufixo de suporte encontrado: 'i'. Opcode final é 'mov'
[DISASSEMBLE] -> Opcode final: 'mov', Tipo: 00
[DISASSEMBLE] -> Instrução 'mov' identificada. Destino: 'r13', Origem: '0'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'i', 'opcode': 'mov', 'type': '00', 'rd': 'r13', 'rh': 'r0', 'op2': '0'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'mov', 'type': '00', 'rd': 'r13', 'rh': 'r0', 'op2': '0'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'mov', 'type': '00', 'rd': 'r13', 'rh': 'r0', 'op2': '0'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000010100001101000000000000000

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'mov: r2 = r13' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'mov: r2 = r13'
[DISASSEMBLE] -> Parte do opcode: 'mov', Parte dos operandos: 'r2 = r13'
[DISASSEMBLE] -> Opcode final: 'mov', Tipo: 00
[DISASSEMBLE] -> Instrução 'mov' identificada. Destino: 'r2', Origem: 'r13'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'na', 'opcode': 'mov', 'type': '00', 'rd': 'r2', 'rh': 'r0', 'op2': 'r13'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'mov', 'type': '00', 'rd': 'r2', 'rh': 'r0', 'op2': 'r13'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'mov', 'type': '00', 'rd': 'r2', 'rh': 'r0', 'op2': 'r13'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000000100000010000000110100000

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'movi: r14 = 2' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'movi: r14 = 2'
[DISASSEMBLE] -> Parte do opcode: 'movi', Parte dos operandos: 'r14 = 2'
[DISASSEMBLE] -> Sufixo de suporte encontrado: 'i'. Opcode final é 'mov'
[DISASSEMBLE] -> Opcode final: 'mov', Tipo: 00
[DISASSEMBLE] -> Instrução 'mov' identificada. Destino: 'r14', Origem: '2'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'i', 'opcode': 'mov', 'type': '00', 'rd': 'r14', 'rh': 'r0', 'op2': '2'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'mov', 'type': '00', 'rd': 'r14', 'rh': 'r0', 'op2': '2'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'mov', 'type': '00', 'rd': 'r14', 'rh': 'r0', 'op2': '2'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000010100001110000000000000010

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'mov: r3 = r14' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'mov: r3 = r14'
[DISASSEMBLE] -> Parte do opcode: 'mov', Parte dos operandos: 'r3 = r14'
[DISASSEMBLE] -> Opcode final: 'mov', Tipo: 00
[DISASSEMBLE] -> Instrução 'mov' identificada. Destino: 'r3', Origem: 'r14'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'na', 'opcode': 'mov', 'type': '00', 'rd': 'r3', 'rh': 'r0', 'op2': 'r14'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'mov', 'type': '00', 'rd': 'r3', 'rh': 'r0', 'op2': 'r14'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'mov', 'type': '00', 'rd': 'r3', 'rh': 'r0', 'op2': 'r14'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000000100000011000000111000000

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'movi: r28 = main_Lret0' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'movi: r28 = main_Lret0'
[DISASSEMBLE] -> Parte do opcode: 'movi', Parte dos operandos: 'r28 = main_Lret0'
[DISASSEMBLE] -> Sufixo de suporte encontrado: 'i'. Opcode final é 'mov'
[DISASSEMBLE] -> Opcode final: 'mov', Tipo: 00
[DISASSEMBLE] -> Instrução 'mov' identificada. Destino: 'r28', Origem: 'main_Lret0'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'i', 'opcode': 'mov', 'type': '00', 'rd': 'r28', 'rh': 'r0', 'op2': 'main_Lret0'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'mov', 'type': '00', 'rd': 'r28', 'rh': 'r0', 'op2': 'main_Lret0'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'mov', 'type': '00', 'rd': 'r28', 'rh': 'r0', 'op2': 'main_Lret0'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000010100011100000000010011010

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'bl: sort' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'bl: sort'
[DISASSEMBLE] -> Parte do opcode: 'bl', Parte dos operandos: 'sort'
[DISASSEMBLE] -> Instrução de branch com link identificada: 'bl'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'i', 'opcode': 'bl', 'type': '11', 'op2': 'sort'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'bl', 'type': '11', 'op2': 'sort'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'bl', 'type': '11', 'op2': 'sort'}
[ENCODE] -> Instrução de branch detectada: bl com condição do
[INSTRUCTION] -> Codificação concluída. Binário: 00001110100011111111111110100110

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'movi: r15 = 0' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'movi: r15 = 0'
[DISASSEMBLE] -> Parte do opcode: 'movi', Parte dos operandos: 'r15 = 0'
[DISASSEMBLE] -> Sufixo de suporte encontrado: 'i'. Opcode final é 'mov'
[DISASSEMBLE] -> Opcode final: 'mov', Tipo: 00
[DISASSEMBLE] -> Instrução 'mov' identificada. Destino: 'r15', Origem: '0'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'i', 'opcode': 'mov', 'type': '00', 'rd': 'r15', 'rh': 'r0', 'op2': '0'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'mov', 'type': '00', 'rd': 'r15', 'rh': 'r0', 'op2': '0'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'mov', 'type': '00', 'rd': 'r15', 'rh': 'r0', 'op2': '0'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000010100001111000000000000000

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'subi: r30 = r31, 2' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'subi: r30 = r31, 2'
[DISASSEMBLE] -> Parte do opcode: 'subi', Parte dos operandos: 'r30 = r31, 2'
[DISASSEMBLE] -> Sufixo de suporte encontrado: 'i'. Opcode final é 'sub'
[DISASSEMBLE] -> Opcode final: 'sub', Tipo: 00
[DISASSEMBLE] -> Instrução com atribuição. Destino: 'r30', Origem: 'r31, 2'
[DISASSEMBLE] -> Operandos finais: Rd='r30', Rh='r31', Op2='2'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'i', 'opcode': 'sub', 'type': '00', 'rd': 'r30', 'rh': 'r31', 'op2': '2'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'sub', 'type': '00', 'rd': 'r30', 'rh': 'r31', 'op2': '2'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'sub', 'type': '00', 'rd': 'r30', 'rh': 'r31', 'op2': '2'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000010000111110111110000000010

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'store: [r30] = r15' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'store: [r30] = r15'
[DISASSEMBLE] -> Parte do opcode: 'store', Parte dos operandos: '[r30] = r15'
[DISASSEMBLE] -> Opcode final: 'store', Tipo: 01
[DISASSEMBLE] -> Instrução Store com endereçamento por registrador. Dest detectado: [r30]. Source detectado: 'r15'
[DISASSEMBLE] -> Instrução Load/Store com endereçamento por registrador.
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'na', 'opcode': 'store', 'type': '01', 'rd': 'r0', 'op2': 'r30', 'rh': 'r15'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'store', 'type': '01', 'rd': 'r0', 'op2': 'r30', 'rh': 'r15'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'store', 'type': '01', 'rd': 'r0', 'op2': 'r30', 'rh': 'r15'}
[ENCODE] -> Instrução Store detectada.
[ENCODE] -> rd_bin, rh_bin calculados: Rd(r0)=:00000 e Rh(r15)=:01111
[ENCODE] -> Op2 é um registrador: r30, convertido para binário: 1111000000
[INSTRUCTION] -> Codificação concluída. Binário: 00000100000000000011111111000000

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'movi: r16 = 2' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'movi: r16 = 2'
[DISASSEMBLE] -> Parte do opcode: 'movi', Parte dos operandos: 'r16 = 2'
[DISASSEMBLE] -> Sufixo de suporte encontrado: 'i'. Opcode final é 'mov'
[DISASSEMBLE] -> Opcode final: 'mov', Tipo: 00
[DISASSEMBLE] -> Instrução 'mov' identificada. Destino: 'r16', Origem: '2'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'i', 'opcode': 'mov', 'type': '00', 'rd': 'r16', 'rh': 'r0', 'op2': '2'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'mov', 'type': '00', 'rd': 'r16', 'rh': 'r0', 'op2': '2'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'mov', 'type': '00', 'rd': 'r16', 'rh': 'r0', 'op2': '2'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000010100010000000000000000010

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'subs: r0 = r15, r16' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'subs: r0 = r15, r16'
[DISASSEMBLE] -> Parte do opcode: 'subs', Parte dos operandos: 'r0 = r15, r16'
[DISASSEMBLE] -> Sufixo de suporte encontrado: 's'. Opcode final é 'sub'
[DISASSEMBLE] -> Opcode final: 'sub', Tipo: 00
[DISASSEMBLE] -> Instrução com atribuição. Destino: 'r0', Origem: 'r15, r16'
[DISASSEMBLE] -> Operandos finais: Rd='r0', Rh='r15', Op2='r16'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 's', 'opcode': 'sub', 'type': '00', 'rd': 'r0', 'rh': 'r15', 'op2': 'r16'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 's', 'opcode': 'sub', 'type': '00', 'rd': 'r0', 'rh': 'r15', 'op2': 'r16'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 's', 'opcode': 'sub', 'type': '00', 'rd': 'r0', 'rh': 'r15', 'op2': 'r16'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000001000100000011111000000000

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'bigteq: L9' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'bigteq: L9'
[DISASSEMBLE] -> Parte do opcode: 'bigteq', Parte dos operandos: 'L9'
[DISASSEMBLE] -> Instrução de branch identificada: 'bigteq'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'gteq', 'supp': 'i', 'opcode': 'b', 'type': '11', 'op2': 'L9'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'gteq', 'supp': 'i', 'opcode': 'b', 'type': '11', 'op2': 'L9'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'gteq', 'supp': 'i', 'opcode': 'b', 'type': '11', 'op2': 'L9'}
[ENCODE] -> Instrução de branch detectada: b com condição gteq
[INSTRUCTION] -> Codificação concluída. Binário: 01001110000000000000000000001011

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'subi: r18 = r31, 1' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'subi: r18 = r31, 1'
[DISASSEMBLE] -> Parte do opcode: 'subi', Parte dos operandos: 'r18 = r31, 1'
[DISASSEMBLE] -> Sufixo de suporte encontrado: 'i'. Opcode final é 'sub'
[DISASSEMBLE] -> Opcode final: 'sub', Tipo: 00
[DISASSEMBLE] -> Instrução com atribuição. Destino: 'r18', Origem: 'r31, 1'
[DISASSEMBLE] -> Operandos finais: Rd='r18', Rh='r31', Op2='1'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'i', 'opcode': 'sub', 'type': '00', 'rd': 'r18', 'rh': 'r31', 'op2': '1'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'sub', 'type': '00', 'rd': 'r18', 'rh': 'r31', 'op2': '1'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'sub', 'type': '00', 'rd': 'r18', 'rh': 'r31', 'op2': '1'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000010000110010111110000000001

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'mov: r17 = r18' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'mov: r17 = r18'
[DISASSEMBLE] -> Parte do opcode: 'mov', Parte dos operandos: 'r17 = r18'
[DISASSEMBLE] -> Opcode final: 'mov', Tipo: 00
[DISASSEMBLE] -> Instrução 'mov' identificada. Destino: 'r17', Origem: 'r18'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'na', 'opcode': 'mov', 'type': '00', 'rd': 'r17', 'rh': 'r0', 'op2': 'r18'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'mov', 'type': '00', 'rd': 'r17', 'rh': 'r0', 'op2': 'r18'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'mov', 'type': '00', 'rd': 'r17', 'rh': 'r0', 'op2': 'r18'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000000100010001000001001000000

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'add: r19 = r17, r15' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'add: r19 = r17, r15'
[DISASSEMBLE] -> Parte do opcode: 'add', Parte dos operandos: 'r19 = r17, r15'
[DISASSEMBLE] -> Opcode final: 'add', Tipo: 00
[DISASSEMBLE] -> Instrução com atribuição. Destino: 'r19', Origem: 'r17, r15'
[DISASSEMBLE] -> Operandos finais: Rd='r19', Rh='r17', Op2='r15'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'na', 'opcode': 'add', 'type': '00', 'rd': 'r19', 'rh': 'r17', 'op2': 'r15'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'add', 'type': '00', 'rd': 'r19', 'rh': 'r17', 'op2': 'r15'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'add', 'type': '00', 'rd': 'r19', 'rh': 'r17', 'op2': 'r15'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000000000010011100010111100000

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'load: r20 = [r19]' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'load: r20 = [r19]'
[DISASSEMBLE] -> Parte do opcode: 'load', Parte dos operandos: 'r20 = [r19]'
[DISASSEMBLE] -> Opcode final: 'load', Tipo: 01
[DISASSEMBLE] -> Instrução Load/Store com endereçamento por registrador.
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'na', 'opcode': 'load', 'type': '01', 'rd': 'r20', 'rh': 'r0', 'op2': 'r19'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'load', 'type': '01', 'rd': 'r20', 'rh': 'r0', 'op2': 'r19'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'load', 'type': '01', 'rd': 'r20', 'rh': 'r0', 'op2': 'r19'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000100000110100000001001100000

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'mov: r1 = r20' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'mov: r1 = r20'
[DISASSEMBLE] -> Parte do opcode: 'mov', Parte dos operandos: 'r1 = r20'
[DISASSEMBLE] -> Opcode final: 'mov', Tipo: 00
[DISASSEMBLE] -> Instrução 'mov' identificada. Destino: 'r1', Origem: 'r20'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'na', 'opcode': 'mov', 'type': '00', 'rd': 'r1', 'rh': 'r0', 'op2': 'r20'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'mov', 'type': '00', 'rd': 'r1', 'rh': 'r0', 'op2': 'r20'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'mov', 'type': '00', 'rd': 'r1', 'rh': 'r0', 'op2': 'r20'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000000100000001000001010000000

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'out: r1' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'out: r1'
[DISASSEMBLE] -> Parte do opcode: 'out', Parte dos operandos: 'r1'
[DISASSEMBLE] -> Instrução 'out' identificada.
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'na', 'opcode': 'out', 'type': '00', 'rd': 'r0', 'rh': 'r0', 'op2': 'r1'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'out', 'type': '00', 'rd': 'r0', 'rh': 'r0', 'op2': 'r1'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'out', 'type': '00', 'rd': 'r0', 'rh': 'r0', 'op2': 'r1'}
[ENCODE] -> Instrução 'out' detectada.
[INSTRUCTION] -> Codificação concluída. Binário: 00000000101000000000000000100000

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'addi: r21 = r15, 1' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'addi: r21 = r15, 1'
[DISASSEMBLE] -> Parte do opcode: 'addi', Parte dos operandos: 'r21 = r15, 1'
[DISASSEMBLE] -> Sufixo de suporte encontrado: 'i'. Opcode final é 'add'
[DISASSEMBLE] -> Opcode final: 'add', Tipo: 00
[DISASSEMBLE] -> Instrução com atribuição. Destino: 'r21', Origem: 'r15, 1'
[DISASSEMBLE] -> Operandos finais: Rd='r21', Rh='r15', Op2='1'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'i', 'opcode': 'add', 'type': '00', 'rd': 'r21', 'rh': 'r15', 'op2': '1'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'add', 'type': '00', 'rd': 'r21', 'rh': 'r15', 'op2': '1'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'add', 'type': '00', 'rd': 'r21', 'rh': 'r15', 'op2': '1'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000010000010101011110000000001

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'subi: r30 = r31, 2' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'subi: r30 = r31, 2'
[DISASSEMBLE] -> Parte do opcode: 'subi', Parte dos operandos: 'r30 = r31, 2'
[DISASSEMBLE] -> Sufixo de suporte encontrado: 'i'. Opcode final é 'sub'
[DISASSEMBLE] -> Opcode final: 'sub', Tipo: 00
[DISASSEMBLE] -> Instrução com atribuição. Destino: 'r30', Origem: 'r31, 2'
[DISASSEMBLE] -> Operandos finais: Rd='r30', Rh='r31', Op2='2'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'i', 'opcode': 'sub', 'type': '00', 'rd': 'r30', 'rh': 'r31', 'op2': '2'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'sub', 'type': '00', 'rd': 'r30', 'rh': 'r31', 'op2': '2'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'sub', 'type': '00', 'rd': 'r30', 'rh': 'r31', 'op2': '2'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000010000111110111110000000010

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'store: [r30] = r21' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'store: [r30] = r21'
[DISASSEMBLE] -> Parte do opcode: 'store', Parte dos operandos: '[r30] = r21'
[DISASSEMBLE] -> Opcode final: 'store', Tipo: 01
[DISASSEMBLE] -> Instrução Store com endereçamento por registrador. Dest detectado: [r30]. Source detectado: 'r21'
[DISASSEMBLE] -> Instrução Load/Store com endereçamento por registrador.
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'na', 'opcode': 'store', 'type': '01', 'rd': 'r0', 'op2': 'r30', 'rh': 'r21'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'store', 'type': '01', 'rd': 'r0', 'op2': 'r30', 'rh': 'r21'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'store', 'type': '01', 'rd': 'r0', 'op2': 'r30', 'rh': 'r21'}
[ENCODE] -> Instrução Store detectada.
[ENCODE] -> rd_bin, rh_bin calculados: Rd(r0)=:00000 e Rh(r21)=:10101
[ENCODE] -> Op2 é um registrador: r30, convertido para binário: 1111000000
[INSTRUCTION] -> Codificação concluída. Binário: 00000100000000000101011111000000

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'subi: r30 = r31, 2' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'subi: r30 = r31, 2'
[DISASSEMBLE] -> Parte do opcode: 'subi', Parte dos operandos: 'r30 = r31, 2'
[DISASSEMBLE] -> Sufixo de suporte encontrado: 'i'. Opcode final é 'sub'
[DISASSEMBLE] -> Opcode final: 'sub', Tipo: 00
[DISASSEMBLE] -> Instrução com atribuição. Destino: 'r30', Origem: 'r31, 2'
[DISASSEMBLE] -> Operandos finais: Rd='r30', Rh='r31', Op2='2'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'i', 'opcode': 'sub', 'type': '00', 'rd': 'r30', 'rh': 'r31', 'op2': '2'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'sub', 'type': '00', 'rd': 'r30', 'rh': 'r31', 'op2': '2'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'sub', 'type': '00', 'rd': 'r30', 'rh': 'r31', 'op2': '2'}
[INSTRUCTION] -> Codificação concluída. Binário: 00000010000111110111110000000010

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'store: [r30] = r21' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'store: [r30] = r21'
[DISASSEMBLE] -> Parte do opcode: 'store', Parte dos operandos: '[r30] = r21'
[DISASSEMBLE] -> Opcode final: 'store', Tipo: 01
[DISASSEMBLE] -> Instrução Store com endereçamento por registrador. Dest detectado: [r30]. Source detectado: 'r21'
[DISASSEMBLE] -> Instrução Load/Store com endereçamento por registrador.
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'na', 'opcode': 'store', 'type': '01', 'rd': 'r0', 'op2': 'r30', 'rh': 'r21'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'store', 'type': '01', 'rd': 'r0', 'op2': 'r30', 'rh': 'r21'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'na', 'opcode': 'store', 'type': '01', 'rd': 'r0', 'op2': 'r30', 'rh': 'r21'}
[ENCODE] -> Instrução Store detectada.
[ENCODE] -> rd_bin, rh_bin calculados: Rd(r0)=:00000 e Rh(r21)=:10101
[ENCODE] -> Op2 é um registrador: r30, convertido para binário: 1111000000
[INSTRUCTION] -> Codificação concluída. Binário: 00000100000000000101011111000000

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'bi: main_epilogue' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'bi: main_epilogue'
[DISASSEMBLE] -> Parte do opcode: 'bi', Parte dos operandos: 'main_epilogue'
[DISASSEMBLE] -> Instrução de branch identificada: 'bi'
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'i', 'opcode': 'b', 'type': '11', 'op2': 'main_epilogue'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'b', 'type': '11', 'op2': 'main_epilogue'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'b', 'type': '11', 'op2': 'main_epilogue'}
[ENCODE] -> Instrução de branch detectada: b com condição do
[INSTRUCTION] -> Codificação concluída. Binário: 00001110000000000000000000000000

--- [INSTRUCTION] Nova instrução em processamento na linha de montagem: 'ret:' ---
[INSTRUCTION] -> Passo 1: Desmontando a linha de assembly...
[DISASSEMBLE] Analisando: 'ret:'
[DISASSEMBLE] -> Instrução 'ret' identificada.
[INSTRUCTION] -> Desmontagem concluída. Detalhes: {'cond': 'do', 'supp': 'i', 'opcode': 'ret', 'type': '11'}
[INSTRUCTION] -> Passo 2: Codificando para binário...
[ENCODE] Iniciando codificação para a instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'ret', 'type': '11'}
[ENCODE] -> Tratando como instrução normal.
[ENCODE] -> Codificando instrução: {'cond': 'do', 'supp': 'i', 'opcode': 'ret', 'type': '11'}
[INSTRUCTION] -> Codificação concluída. Binário: 00001110111111111111111111111111

[PASS 2] -> 173 linhas de código de máquina geradas.

[PASS 2] Etapa 3: Adicionando a seção de dados e literais ao código de máquina final...
[PASS 2] -> Dados a serem adicionados (endereço: valor): [(0, '0'), (1, '0'), (2, '0'), (3, '0'), (4, '0'), (5, '0'), (6, '0'), (7, '0'), (8, '0'), (9, '0'), (10, '0'), (11, '0'), (12, '0'), (13, '0'), (14, '0'), (15, '0'), (16, '0'), (17, '0'), (18, '0'), (19, '0'), (20, '0'), (21, '0'), (22, '0'), (23, '0'), (24, '0'), (25, '0'), (26, '0'), (27, '0'), (28, '0'), (29, '0'), (30, '0'), (31, '0'), (32, '0'), (33, '0'), (34, '0'), (35, '0'), (36, '0'), (37, '0'), (38, '0'), (39, '0'), (40, '0'), (41, '0'), (42, '0'), (43, '0'), (44, '0'), (45, '0'), (46, '0'), (47, '0'), (48, '0'), (49, '0'), (50, '0'), (51, '0'), (52, '0'), (53, '0'), (54, '0'), (55, '0'), (56, '0'), (57, '0'), (58, '0'), (59, '0'), (60, '0'), (61, '0'), (62, '0'), (63, '0'), (64, '0'), (65, '0'), (66, '0'), (67, '0'), (68, '0'), (69, '0'), (70, '0'), (71, '0'), (72, '0'), (73, '0'), (74, '0'), (75, '0'), (76, '0'), (77, '0'), (78, '0'), (79, '0'), (80, '0'), (81, '0'), (82, '0'), (83, '0'), (84, '0'), (85, '0'), (86, '0'), (87, '0'), (88, '0'), (89, '0'), (90, '0'), (91, '0'), (92, '0'), (93, '0'), (94, '0'), (95, '0'), (96, '0'), (97, '0'), (98, '0'), (99, '0'), (100, '0'), (101, '0'), (102, '0'), (103, '0'), (104, '0'), (105, '0'), (106, '0'), (107, '0'), (108, '0'), (109, '0'), (110, '0'), (111, '0'), (112, '0'), (113, '0'), (114, '0'), (115, '0'), (116, '0'), (117, '0'), (118, '0'), (119, '0'), (120, '0'), (121, '0'), (122, '0'), (123, '0'), (124, '0'), (125, '0'), (126, '0'), (127, '0'), (128, '0'), (129, '0'), (130, '0'), (131, '0'), (132, '0'), (133, '0'), (134, '0'), (135, '0'), (136, '0'), (137, '0'), (138, '0'), (139, '0'), (140, '0'), (141, '0'), (142, '0'), (143, '0'), (144, '0'), (145, '0'), (146, '0'), (147, '0'), (148, '0'), (149, '0'), (150, '0'), (151, '0'), (152, '0'), (153, '0'), (154, '0'), (155, '0'), (156, '0'), (157, '0'), (158, '0'), (159, '0'), (160, '0'), (161, '0'), (162, '0'), (163, '0'), (164, '0'), (165, '0'), (166, '0'), (167, '0'), (168, '0'), (169, '0'), (170, '0'), (171, '0'), (172, '0'), (173, '0'), (174, '0'), (175, '0'), (176, '0'), (177, '0'), (178, '0'), (179, '0'), (180, '0'), (181, '0'), (182, '0'), (183, '0'), (184, '0'), (185, '0'), (186, '0'), (187, '0'), (188, '0'), (189, '0'), (190, '0'), (191, '0'), (192, '0'), (193, '0'), (194, '0'), (195, '0'), (196, '0'), (197, '0'), (198, '0'), (199, '0'), (200, '0'), (201, '0'), (202, '0'), (203, '0'), (204, '0'), (205, '0'), (206, '0'), (207, '0'), (208, '0'), (209, '0'), (210, '0'), (211, '0'), (212, '0'), (213, '0'), (214, '0'), (215, '0'), (216, '0'), (217, '0'), (218, '0'), (219, '0'), (220, '0'), (221, '0'), (222, '0'), (223, '0'), (224, '0'), (225, '0'), (226, '0'), (227, '0'), (228, '0'), (229, '0'), (230, '0'), (231, '0'), (232, '0'), (233, '0'), (234, '0'), (235, '0'), (236, '0'), (237, '0'), (238, '0'), (239, '0'), (240, '0'), (241, '0'), (242, '0'), (243, '0'), (244, '0'), (245, '0'), (246, '0'), (247, '0'), (248, '0'), (249, '0'), (250, '0'), (251, '0'), (252, '0'), (253, '0'), (254, '0'), (255, '0'), (256, '0'), (257, '0')]
--- Fim da Segunda Passagem ---
=== PROCESSO DE MONTAGEM CONCLUÍDO ===
--- DEBUG OUTPUT ---
00001110000000000000000001111010 -> cond[0000] type[11] supp[10] op[0000] offset_calc[(123 - 1) = 122]->bin[00000000000001111010]
00000010000111101111010000000001 -> cond[0000] type[00] supp[10] op[0001] Rd[11101] Rh[11101] imm[1=1]->[0000000001]
00000100000000000111001110100000 -> cond[0000] type[01] supp[00] op[0000] Rd[00000] Rh[11100] Ro[11101] pad[00000] (Store sem imediato)
00000010000111101111010000000001 -> cond[0000] type[00] supp[10] op[0001] Rd[11101] Rh[11101] imm[1=1]->[0000000001]
00000100000000000111111110100000 -> cond[0000] type[01] supp[00] op[0000] Rd[00000] Rh[11111] Ro[11101] pad[00000] (Store sem imediato)
00000000100011111000001110100000 -> cond[0000] type[00] supp[00] op[1000] Rd[11111] Rh[00000] Ro[11101] pad[00000] (Mov sem imediato)
00000010000111101111010000010000 -> cond[0000] type[00] supp[10] op[0001] Rd[11101] Rh[11101] imm[16=16]->[0000010000]
00000010000111110111110000000001 -> cond[0000] type[00] supp[10] op[0001] Rd[11110] Rh[11111] imm[1=1]->[0000000001]
00000100000000000000011111000000 -> cond[0000] type[01] supp[00] op[0000] Rd[00000] Rh[00001] Ro[11110] pad[00000] (Store sem imediato)
00000010000111110111110000000010 -> cond[0000] type[00] supp[10] op[0001] Rd[11110] Rh[11111] imm[2=2]->[0000000010]
00000100000000000000101111000000 -> cond[0000] type[01] supp[00] op[0000] Rd[00000] Rh[00010] Ro[11110] pad[00000] (Store sem imediato)
00000010000111110111110000000011 -> cond[0000] type[00] supp[10] op[0001] Rd[11110] Rh[11111] imm[3=3]->[0000000011]
00000100000000000000111111000000 -> cond[0000] type[01] supp[00] op[0000] Rd[00000] Rh[00011] Ro[11110] pad[00000] (Store sem imediato)
00000010000111110111110000000011 -> cond[0000] type[00] supp[10] op[0001] Rd[11110] Rh[11111] imm[3=3]->[0000000011]
00000100000100100000001111000000 -> cond[0000] type[01] supp[00] op[0001] Rd[00100] Rh[00000] Ro[11110] pad[00000] (Load sem imediato)
00000010000111110111110000000101 -> cond[0000] type[00] supp[10] op[0001] Rd[11110] Rh[11111] imm[5=5]->[0000000101]
00000100000000000001001111000000 -> cond[0000] type[01] supp[00] op[0000] Rd[00000] Rh[00100] Ro[11110] pad[00000] (Store sem imediato)
00000010000111110111110000000010 -> cond[0000] type[00] supp[10] op[0001] Rd[11110] Rh[11111] imm[2=2]->[0000000010]
00000100000100101000001111000000 -> cond[0000] type[01] supp[00] op[0001] Rd[00101] Rh[00000] Ro[11110] pad[00000] (Load sem imediato)
00000010000111110111110000000011 -> cond[0000] type[00] supp[10] op[0001] Rd[11110] Rh[11111] imm[3=3]->[0000000011]
00000100000100110000001111000000 -> cond[0000] type[01] supp[00] op[0001] Rd[00110] Rh[00000] Ro[11110] pad[00000] (Load sem imediato)
00000000000000111001010011000000 -> cond[0000] type[00] supp[00] op[0000] Rd[00111] Rh[00101] Ro[00110] pad[00000]
00000100000101000000000011100000 -> cond[0000] type[01] supp[00] op[0001] Rd[01000] Rh[00000] Ro[00111] pad[00000] (Load sem imediato)
00000010000111110111110000000110 -> cond[0000] type[00] supp[10] op[0001] Rd[11110] Rh[11111] imm[6=6]->[0000000110]
00000100000000000010001111000000 -> cond[0000] type[01] supp[00] op[0000] Rd[00000] Rh[01000] Ro[11110] pad[00000] (Store sem imediato)
00000010000001001001100000000001 -> cond[0000] type[00] supp[10] op[0000] Rd[01001] Rh[00110] imm[1=1]->[0000000001]
00000010000111110111110000000100 -> cond[0000] type[00] supp[10] op[0001] Rd[11110] Rh[11111] imm[4=4]->[0000000100]
00000100000000000010011111000000 -> cond[0000] type[01] supp[00] op[0000] Rd[00000] Rh[01001] Ro[11110] pad[00000] (Store sem imediato)
00000010000111110111110000000100 -> cond[0000] type[00] supp[10] op[0001] Rd[11110] Rh[11111] imm[4=4]->[0000000100]
00000100000000000010011111000000 -> cond[0000] type[01] supp[00] op[0000] Rd[00000] Rh[01001] Ro[11110] pad[00000] (Store sem imediato)
00000010000111110111110000000110 -> cond[0000] type[00] supp[10] op[0001] Rd[11110] Rh[11111] imm[6=6]->[0000000110]
00000100000000000010001111000000 -> cond[0000] type[01] supp[00] op[0000] Rd[00000] Rh[01000] Ro[11110] pad[00000] (Store sem imediato)
00000010000111110111110000000001 -> cond[0000] type[00] supp[10] op[0001] Rd[11110] Rh[11111] imm[1=1]->[0000000001]
00000100000101010000001111000000 -> cond[0000] type[01] supp[00] op[0001] Rd[01010] Rh[00000] Ro[11110] pad[00000] (Load sem imediato)
00000001000100000010010101000000 -> cond[0000] type[00] supp[01] op[0001] Rd[00000] Rh[01001] Ro[01010] pad[00000]
01001110000000000000000000010100 -> cond[0100] type[11] supp[10] op[0000] offset_calc[(56 - 36) = 20]->bin[00000000000000010100]
00000000000001011001010100100000 -> cond[0000] type[00] supp[00] op[0000] Rd[01011] Rh[00101] Ro[01001] pad[00000]
00000100000101100000000101100000 -> cond[0000] type[01] supp[00] op[0001] Rd[01100] Rh[00000] Ro[01011] pad[00000] (Load sem imediato)
00000001000100000011000100000000 -> cond[0000] type[00] supp[01] op[0001] Rd[00000] Rh[01100] Ro[01000] pad[00000]
01001110000000000000000000001001 -> cond[0100] type[11] supp[10] op[0000] offset_calc[(49 - 40) = 9]->bin[00000000000000001001]
00000000000001101001010100100000 -> cond[0000] type[00] supp[00] op[0000] Rd[01101] Rh[00101] Ro[01001] pad[00000]
00000100000101110000000110100000 -> cond[0000] type[01] supp[00] op[0001] Rd[01110] Rh[00000] Ro[01101] pad[00000] (Load sem imediato)
00000010000111110111110000000110 -> cond[0000] type[00] supp[10] op[0001] Rd[11110] Rh[11111] imm[6=6]->[0000000110]
00000100000000000011101111000000 -> cond[0000] type[01] supp[00] op[0000] Rd[00000] Rh[01110] Ro[11110] pad[00000] (Store sem imediato)
00000010000111110111110000000101 -> cond[0000] type[00] supp[10] op[0001] Rd[11110] Rh[11111] imm[5=5]->[0000000101]
00000100000000000010011111000000 -> cond[0000] type[01] supp[00] op[0000] Rd[00000] Rh[01001] Ro[11110] pad[00000] (Store sem imediato)
00000010000111110111110000000110 -> cond[0000] type[00] supp[10] op[0001] Rd[11110] Rh[11111] imm[6=6]->[0000000110]
00000100000000000011101111000000 -> cond[0000] type[01] supp[00] op[0000] Rd[00000] Rh[01110] Ro[11110] pad[00000] (Store sem imediato)
00001110000000000000000000000000 -> cond[0000] type[11] supp[10] op[0000] offset_calc[(49 - 49) = 0]->bin[00000000000000000000]
00000010000111110111110000000100 -> cond[0000] type[00] supp[10] op[0001] Rd[11110] Rh[11111] imm[4=4]->[0000000100]
00000100000101111000001111000000 -> cond[0000] type[01] supp[00] op[0001] Rd[01111] Rh[00000] Ro[11110] pad[00000] (Load sem imediato)
00000010000010000011110000000001 -> cond[0000] type[00] supp[10] op[0000] Rd[10000] Rh[01111] imm[1=1]->[0000000001]
00000010000111110111110000000100 -> cond[0000] type[00] supp[10] op[0001] Rd[11110] Rh[11111] imm[4=4]->[0000000100]
00000100000000000100001111000000 -> cond[0000] type[01] supp[00] op[0000] Rd[00000] Rh[10000] Ro[11110] pad[00000] (Store sem imediato)
00000010000111110111110000000100 -> cond[0000] type[00] supp[10] op[0001] Rd[11110] Rh[11111] imm[4=4]->[0000000100]
00000100000000000100001111000000 -> cond[0000] type[01] supp[00] op[0000] Rd[00000] Rh[10000] Ro[11110] pad[00000] (Store sem imediato)
00000000100000000000000100100000 -> cond[0000] type[00] supp[00] op[1000] Rd[00000] Rh[00000] Ro[01001] pad[00000] (Mov sem imediato)
00001110000000000000000000000000 -> cond[0000] type[11] supp[10] op[0000] offset_calc[(58 - 58) = 0]->bin[00000000000000000000]
00000000100011101000001111100000 -> cond[0000] type[00] supp[00] op[1000] Rd[11101] Rh[00000] Ro[11111] pad[00000] (Mov sem imediato)
00000100000111111000001110100000 -> cond[0000] type[01] supp[00] op[0001] Rd[11111] Rh[00000] Ro[11101] pad[00000] (Load sem imediato)
00000010000011101111010000000001 -> cond[0000] type[00] supp[10] op[0000] Rd[11101] Rh[11101] imm[1=1]->[0000000001]
00000100000111100000001110100000 -> cond[0000] type[01] supp[00] op[0001] Rd[11100] Rh[00000] Ro[11101] pad[00000] (Load sem imediato)
00000010000011101111010000000001 -> cond[0000] type[00] supp[10] op[0000] Rd[11101] Rh[11101] imm[1=1]->[0000000001]
00001100000000000000001110000000 -> cond[0000] type[11] supp[00] op[0000] reg_target[r28]->bin[00000000001110000000]
00000010000111101111010000000001 -> cond[0000] type[00] supp[10] op[0001] Rd[11101] Rh[11101] imm[1=1]->[0000000001]
00000100000000000111001110100000 -> cond[0000] type[01] supp[00] op[0000] Rd[00000] Rh[11100] Ro[11101] pad[00000] (Store sem imediato)
00000010000111101111010000000001 -> cond[0000] type[00] supp[10] op[0001] Rd[11101] Rh[11101] imm[1=1]->[0000000001]
00000100000000000111111110100000 -> cond[0000] type[01] supp[00] op[0000] Rd[00000] Rh[11111] Ro[11101] pad[00000] (Store sem imediato)
00000000100011111000001110100000 -> cond[0000] type[00] supp[00] op[1000] Rd[11111] Rh[00000] Ro[11101] pad[00000] (Mov sem imediato)
00000010000111101111010000001111 -> cond[0000] type[00] supp[10] op[0001] Rd[11101] Rh[11101] imm[15=15]->[0000001111]
00000010000111110111110000000001 -> cond[0000] type[00] supp[10] op[0001] Rd[11110] Rh[11111] imm[1=1]->[0000000001]
00000100000000000000011111000000 -> cond[0000] type[01] supp[00] op[0000] Rd[00000] Rh[00001] Ro[11110] pad[00000] (Store sem imediato)
00000010000111110111110000000010 -> cond[0000] type[00] supp[10] op[0001] Rd[11110] Rh[11111] imm[2=2]->[0000000010]
00000100000000000000101111000000 -> cond[0000] type[01] supp[00] op[0000] Rd[00000] Rh[00010] Ro[11110] pad[00000] (Store sem imediato)
00000010000111110111110000000011 -> cond[0000] type[00] supp[10] op[0001] Rd[11110] Rh[11111] imm[3=3]->[0000000011]
00000100000000000000111111000000 -> cond[0000] type[01] supp[00] op[0000] Rd[00000] Rh[00011] Ro[11110] pad[00000] (Store sem imediato)
00000010000111110111110000000011 -> cond[0000] type[00] supp[10] op[0001] Rd[11110] Rh[11111] imm[3=3]->[0000000011]
00000100000100100000001111000000 -> cond[0000] type[01] supp[00] op[0001] Rd[00100] Rh[00000] Ro[11110] pad[00000] (Load sem imediato)
00000010000111110111110000000100 -> cond[0000] type[00] supp[10] op[0001] Rd[11110] Rh[11111] imm[4=4]->[0000000100]
00000100000000000001001111000000 -> cond[0000] type[01] supp[00] op[0000] Rd[00000] Rh[00100] Ro[11110] pad[00000] (Store sem imediato)
00000010000111110111110000000001 -> cond[0000] type[00] supp[10] op[0001] Rd[11110] Rh[11111] imm[1=1]->[0000000001]
00000100000100101000001111000000 -> cond[0000] type[01] supp[00] op[0001] Rd[00101] Rh[00000] Ro[11110] pad[00000] (Load sem imediato)
00000010000100110001010000000001 -> cond[0000] type[00] supp[10] op[0001] Rd[00110] Rh[00101] imm[1=1]->[0000000001]
00000001000100000001000011000000 -> cond[0000] type[00] supp[01] op[0001] Rd[00000] Rh[00100] Ro[00110] pad[00000]
01001110000000000000000000011111 -> cond[0100] type[11] supp[10] op[0000] offset_calc[(116 - 85) = 31]->bin[00000000000000011111]
00000010000111110111110000000010 -> cond[0000] type[00] supp[10] op[0001] Rd[11110] Rh[11111] imm[2=2]->[0000000010]
00000100000100111000001111000000 -> cond[0000] type[01] supp[00] op[0001] Rd[00111] Rh[00000] Ro[11110] pad[00000] (Load sem imediato)
00000000100000001000000011100000 -> cond[0000] type[00] supp[00] op[1000] Rd[00001] Rh[00000] Ro[00111] pad[00000] (Mov sem imediato)
00000000100000010000000010000000 -> cond[0000] type[00] supp[00] op[1000] Rd[00010] Rh[00000] Ro[00100] pad[00000] (Mov sem imediato)
00000000100000011000000010100000 -> cond[0000] type[00] supp[00] op[1000] Rd[00011] Rh[00000] Ro[00101] pad[00000] (Mov sem imediato)
00000010100001000000000001011101 -> cond[0000] type[00] supp[10] op[1000] Rd[01000] Rh[00000] imm[sort_Lret0=93]->[0001011101]
00000000100011100000000100000000 -> cond[0000] type[00] supp[00] op[1000] Rd[11100] Rh[00000] Ro[01000] pad[00000] (Mov sem imediato)
00001110100011111111111110100100 -> cond[0000] type[11] supp[10] op[1000] offset_calc[(1 - 93) = -92]->bin[11111111111110100100]
00000000100001001000000000000000 -> cond[0000] type[00] supp[00] op[1000] Rd[01001] Rh[00000] Ro[00000] pad[00000] (Mov sem imediato)
00000010000111110111110000000101 -> cond[0000] type[00] supp[10] op[0001] Rd[11110] Rh[11111] imm[5=5]->[0000000101]
00000100000000000010011111000000 -> cond[0000] type[01] supp[00] op[0000] Rd[00000] Rh[01001] Ro[11110] pad[00000] (Store sem imediato)
00000010000111110111110000000010 -> cond[0000] type[00] supp[10] op[0001] Rd[11110] Rh[11111] imm[2=2]->[0000000010]
00000100000101010000001111000000 -> cond[0000] type[01] supp[00] op[0001] Rd[01010] Rh[00000] Ro[11110] pad[00000] (Load sem imediato)
00000000000001011010100100100000 -> cond[0000] type[00] supp[00] op[0000] Rd[01011] Rh[01010] Ro[01001] pad[00000]
00000100000101100000000101100000 -> cond[0000] type[01] supp[00] op[0001] Rd[01100] Rh[00000] Ro[01011] pad[00000] (Load sem imediato)
00000010000111110111110000000100 -> cond[0000] type[00] supp[10] op[0001] Rd[11110] Rh[11111] imm[4=4]->[0000000100]
00000100000101101000001111000000 -> cond[0000] type[01] supp[00] op[0001] Rd[01101] Rh[00000] Ro[11110] pad[00000] (Load sem imediato)
00000000000001110010100110100000 -> cond[0000] type[00] supp[00] op[0000] Rd[01110] Rh[01010] Ro[01101] pad[00000]
00000100000101111000000111000000 -> cond[0000] type[01] supp[00] op[0001] Rd[01111] Rh[00000] Ro[01110] pad[00000] (Load sem imediato)
00000000000010000010100100100000 -> cond[0000] type[00] supp[00] op[0000] Rd[10000] Rh[01010] Ro[01001] pad[00000]
00000100000000000011111000000000 -> cond[0000] type[01] supp[00] op[0000] Rd[00000] Rh[01111] Ro[10000] pad[00000] (Store sem imediato)
00000000000010001010100110100000 -> cond[0000] type[00] supp[00] op[0000] Rd[10001] Rh[01010] Ro[01101] pad[00000]
00000100000000000100101000100000 -> cond[0000] type[01] supp[00] op[0000] Rd[00000] Rh[10010] Ro[10001] pad[00000] (Store sem imediato)
00000010000010011011010000000001 -> cond[0000] type[00] supp[10] op[0000] Rd[10011] Rh[01101] imm[1=1]->[0000000001]
00000010000111110111110000000100 -> cond[0000] type[00] supp[10] op[0001] Rd[11110] Rh[11111] imm[4=4]->[0000000100]
00000100000000000100111111000000 -> cond[0000] type[01] supp[00] op[0000] Rd[00000] Rh[10011] Ro[11110] pad[00000] (Store sem imediato)
00000010000111110111110000000101 -> cond[0000] type[00] supp[10] op[0001] Rd[11110] Rh[11111] imm[5=5]->[0000000101]
00000100000000000010011111000000 -> cond[0000] type[01] supp[00] op[0000] Rd[00000] Rh[01001] Ro[11110] pad[00000] (Store sem imediato)
00000010000111110111110000000100 -> cond[0000] type[00] supp[10] op[0001] Rd[11110] Rh[11111] imm[4=4]->[0000000100]
00000100000000000100111111000000 -> cond[0000] type[01] supp[00] op[0000] Rd[00000] Rh[10011] Ro[11110] pad[00000] (Store sem imediato)
00001110000011111111111111011100 -> cond[0000] type[11] supp[10] op[0000] offset_calc[(80 - 116) = -36]->bin[11111111111111011100]
00001110000000000000000000000000 -> cond[0000] type[11] supp[10] op[0000] offset_calc[(117 - 117) = 0]->bin[00000000000000000000]
00000000100011101000001111100000 -> cond[0000] type[00] supp[00] op[1000] Rd[11101] Rh[00000] Ro[11111] pad[00000] (Mov sem imediato)
00000100000111111000001110100000 -> cond[0000] type[01] supp[00] op[0001] Rd[11111] Rh[00000] Ro[11101] pad[00000] (Load sem imediato)
00000010000011101111010000000001 -> cond[0000] type[00] supp[10] op[0000] Rd[11101] Rh[11101] imm[1=1]->[0000000001]
00000100000111100000001110100000 -> cond[0000] type[01] supp[00] op[0001] Rd[11100] Rh[00000] Ro[11101] pad[00000] (Load sem imediato)
00000010000011101111010000000001 -> cond[0000] type[00] supp[10] op[0000] Rd[11101] Rh[11101] imm[1=1]->[0000000001]
00001100000000000000001110000000 -> cond[0000] type[11] supp[00] op[0000] reg_target[r28]->bin[00000000001110000000]
00000010100011101000000011111111 -> cond[0000] type[00] supp[10] op[1000] Rd[11101] Rh[00000] imm[255=255]->[0011111111]
00000000100011111000001110100000 -> cond[0000] type[00] supp[00] op[1000] Rd[11111] Rh[00000] Ro[11101] pad[00000] (Mov sem imediato)
00000010000111101111010000001101 -> cond[0000] type[00] supp[10] op[0001] Rd[11101] Rh[11101] imm[13=13]->[0000001101]
00000010000111110111110000000001 -> cond[0000] type[00] supp[10] op[0001] Rd[11110] Rh[11111] imm[1=1]->[0000000001]
00000100000000000000011111000000 -> cond[0000] type[01] supp[00] op[0000] Rd[00000] Rh[00001] Ro[11110] pad[00000] (Store sem imediato)
00000010100000100000000000000000 -> cond[0000] type[00] supp[10] op[1000] Rd[00100] Rh[00000] imm[0=0]->[0000000000]
00000010000111110111110000000010 -> cond[0000] type[00] supp[10] op[0001] Rd[11110] Rh[11111] imm[2=2]->[0000000010]
00000100000000000001001111000000 -> cond[0000] type[01] supp[00] op[0000] Rd[00000] Rh[00100] Ro[11110] pad[00000] (Store sem imediato)
00000010100000101000000000000010 -> cond[0000] type[00] supp[10] op[1000] Rd[00101] Rh[00000] imm[2=2]->[0000000010]
00000001000100000001000010100000 -> cond[0000] type[00] supp[01] op[0001] Rd[00000] Rh[00100] Ro[00101] pad[00000]
01001110000000000000000000001011 -> cond[0100] type[11] supp[10] op[0000] offset_calc[(145 - 134) = 11]->bin[00000000000000001011]
00000000100100110000000000000000 -> cond[0000] type[00] supp[00] op[1001] Rd[00110] Rh[00000] Ro[00000] pad[00000]
00000010000101000111110000000001 -> cond[0000] type[00] supp[10] op[0001] Rd[01000] Rh[11111] imm[1=1]->[0000000001]
00000000100000111000000100000000 -> cond[0000] type[00] supp[00] op[1000] Rd[00111] Rh[00000] Ro[01000] pad[00000] (Mov sem imediato)
00000000000001001001110010000000 -> cond[0000] type[00] supp[00] op[0000] Rd[01001] Rh[00111] Ro[00100] pad[00000]
00000100000000000001100100100000 -> cond[0000] type[01] supp[00] op[0000] Rd[00000] Rh[00110] Ro[01001] pad[00000] (Store sem imediato)
00000010000001010001000000000001 -> cond[0000] type[00] supp[10] op[0000] Rd[01010] Rh[00100] imm[1=1]->[0000000001]
00000010000111110111110000000010 -> cond[0000] type[00] supp[10] op[0001] Rd[11110] Rh[11111] imm[2=2]->[0000000010]
00000100000000000010101111000000 -> cond[0000] type[01] supp[00] op[0000] Rd[00000] Rh[01010] Ro[11110] pad[00000] (Store sem imediato)
00000010000111110111110000000010 -> cond[0000] type[00] supp[10] op[0001] Rd[11110] Rh[11111] imm[2=2]->[0000000010]
00000100000000000010101111000000 -> cond[0000] type[01] supp[00] op[0000] Rd[00000] Rh[01010] Ro[11110] pad[00000] (Store sem imediato)
00001110000011111111111111110010 -> cond[0000] type[11] supp[10] op[0000] offset_calc[(131 - 145) = -14]->bin[11111111111111110010]
00000010000101100111110000000001 -> cond[0000] type[00] supp[10] op[0001] Rd[01100] Rh[11111] imm[1=1]->[0000000001]
00000000100001011000000110000000 -> cond[0000] type[00] supp[00] op[1000] Rd[01011] Rh[00000] Ro[01100] pad[00000] (Mov sem imediato)
00000000100000001000000101100000 -> cond[0000] type[00] supp[00] op[1000] Rd[00001] Rh[00000] Ro[01011] pad[00000] (Mov sem imediato)
00000010100001101000000000000000 -> cond[0000] type[00] supp[10] op[1000] Rd[01101] Rh[00000] imm[0=0]->[0000000000]
00000000100000010000000110100000 -> cond[0000] type[00] supp[00] op[1000] Rd[00010] Rh[00000] Ro[01101] pad[00000] (Mov sem imediato)
00000010100001110000000000000010 -> cond[0000] type[00] supp[10] op[1000] Rd[01110] Rh[00000] imm[2=2]->[0000000010]
00000000100000011000000111000000 -> cond[0000] type[00] supp[00] op[1000] Rd[00011] Rh[00000] Ro[01110] pad[00000] (Mov sem imediato)
00000010100011100000000010011010 -> cond[0000] type[00] supp[10] op[1000] Rd[11100] Rh[00000] imm[main_Lret0=154]->[0010011010]
00001110100011111111111110100110 -> cond[0000] type[11] supp[10] op[1000] offset_calc[(64 - 154) = -90]->bin[11111111111110100110]
00000010100001111000000000000000 -> cond[0000] type[00] supp[10] op[1000] Rd[01111] Rh[00000] imm[0=0]->[0000000000]
00000010000111110111110000000010 -> cond[0000] type[00] supp[10] op[0001] Rd[11110] Rh[11111] imm[2=2]->[0000000010]
00000100000000000011111111000000 -> cond[0000] type[01] supp[00] op[0000] Rd[00000] Rh[01111] Ro[11110] pad[00000] (Store sem imediato)
00000010100010000000000000000010 -> cond[0000] type[00] supp[10] op[1000] Rd[10000] Rh[00000] imm[2=2]->[0000000010]
00000001000100000011111000000000 -> cond[0000] type[00] supp[01] op[0001] Rd[00000] Rh[01111] Ro[10000] pad[00000]
01001110000000000000000000001011 -> cond[0100] type[11] supp[10] op[0000] offset_calc[(171 - 160) = 11]->bin[00000000000000001011]
00000010000110010111110000000001 -> cond[0000] type[00] supp[10] op[0001] Rd[10010] Rh[11111] imm[1=1]->[0000000001]
00000000100010001000001001000000 -> cond[0000] type[00] supp[00] op[1000] Rd[10001] Rh[00000] Ro[10010] pad[00000] (Mov sem imediato)
00000000000010011100010111100000 -> cond[0000] type[00] supp[00] op[0000] Rd[10011] Rh[10001] Ro[01111] pad[00000]
00000100000110100000001001100000 -> cond[0000] type[01] supp[00] op[0001] Rd[10100] Rh[00000] Ro[10011] pad[00000] (Load sem imediato)
00000000100000001000001010000000 -> cond[0000] type[00] supp[00] op[1000] Rd[00001] Rh[00000] Ro[10100] pad[00000] (Mov sem imediato)
00000000101000000000000000100000 -> cond[0000] type[00] supp[00] op[1010] Rd[00000] Rh[00000] Ro[00001] pad[00000] (Out sem imediato)
00000010000010101011110000000001 -> cond[0000] type[00] supp[10] op[0000] Rd[10101] Rh[01111] imm[1=1]->[0000000001]
00000010000111110111110000000010 -> cond[0000] type[00] supp[10] op[0001] Rd[11110] Rh[11111] imm[2=2]->[0000000010]
00000100000000000101011111000000 -> cond[0000] type[01] supp[00] op[0000] Rd[00000] Rh[10101] Ro[11110] pad[00000] (Store sem imediato)
00000010000111110111110000000010 -> cond[0000] type[00] supp[10] op[0001] Rd[11110] Rh[11111] imm[2=2]->[0000000010]
00000100000000000101011111000000 -> cond[0000] type[01] supp[00] op[0000] Rd[00000] Rh[10101] Ro[11110] pad[00000] (Store sem imediato)
00001110000000000000000000000000 -> cond[0000] type[11] supp[10] op[0000] offset_calc[(172 - 172) = 0]->bin[00000000000000000000]
00001110111111111111111111111111 -> cond[0000] type[11] supp[10] op[1111] operand[-1]

Código de máquina gerado com sucesso em: docs/output/generated_machine_code.txt

--- Iniciando a Decodificação do Código de Máquina ---
--- Decodificação Concluída ---
--- MACHINE CODE DECODED ---
