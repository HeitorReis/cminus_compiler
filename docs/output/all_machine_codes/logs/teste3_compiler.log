Initializing symbol table and scope stack...
[SYM_TABLE DBG] setFunctionParams: 'input' in scope 'global' with 0 params
[SYM_TABLE DBG] setFunctionParams: 'output' in scope 'global' with 1 params
Symbol table initialized successfully.
Parsing 'docs/test_files/teste3.txt'...
[LEX][3] SKIP_COMMENT
[LEX][5] INT      -> 'int'
[LEX][5] ID       -> 'gcd'
[LEX][5] LPAREN   -> '('
[LEX][5] INT      -> 'int'
[LEX][5] ID       -> 'u'
[LEX][5] COMMA    -> ','
[AST DBG] newNode kind=AST_PARAM -> 0x5b2ff9a7a860
[AST DBG] newNode kind=AST_PARAM_LIST -> 0x5b2ff9a7a8c0
[AST DBG] addChild parent=0x5b2ff9a7a8c0(AST_PARAM_LIST, lineno=0) child=0x5b2ff9a7a860(AST_PARAM, lineno=5)
[LEX][5] INT      -> 'int'
[LEX][5] ID       -> 'v'
[LEX][5] RPAREN   -> ')'
[AST DBG] newNode kind=AST_PARAM -> 0x5b2ff9a7a9b0
[AST DBG] addChild parent=0x5b2ff9a7a8c0(AST_PARAM_LIST, lineno=0) child=0x5b2ff9a7a9b0(AST_PARAM, lineno=5)
[LEX][6] LBRACE   -> '{'
[LEX][7] IF       -> 'if'
[LEX][7] LPAREN   -> '('
[LEX][7] ID       -> 'v'
[LEX][7] EQ       -> '=='
[SYM_TABLE DBG] useSymbol: 'v' in scope 'gcd' at line 7
[AST DBG] newNode kind=AST_ID -> 0x5b2ff9a7aa30
[AST DBG] newIdNode("v") -> 0x5b2ff9a7aa30
[AST DBG] newNode kind=AST_BINOP -> 0x5b2ff9a7aa90
[LEX][7] NUM      -> '0' (0)
[AST DBG] newNode kind=AST_NUM -> 0x5b2ff9a7aad0
[AST DBG] newNumNode(0) -> 0x5b2ff9a7aad0
[LEX][7] RPAREN   -> ')'
[AST DBG] newNode kind=AST_BINOP -> 0x5b2ff9a7ab10
[AST DBG] addChild parent=0x5b2ff9a7ab10(AST_BINOP, lineno=7) child=0x5b2ff9a7aa30(AST_ID, lineno=7)
[AST DBG] addChild parent=0x5b2ff9a7ab10(AST_BINOP, lineno=7) child=0x5b2ff9a7aa90(AST_BINOP, lineno=7)
[AST DBG] addChild parent=0x5b2ff9a7ab10(AST_BINOP, lineno=7) child=0x5b2ff9a7aad0(AST_NUM, lineno=7)
[PARSER DBG] binop: left=0x5b2ff9a7aa30 op=0x5b2ff9a7aa90 right=0x5b2ff9a7aad0
[LEX][7] RETURN   -> 'return'
[LEX][7] ID       -> 'u'
[LEX][7] SEMI     -> ';'
[SYM_TABLE DBG] useSymbol: 'u' in scope 'gcd' at line 7
[AST DBG] newNode kind=AST_ID -> 0x5b2ff9a7ab90
[AST DBG] newIdNode("u") -> 0x5b2ff9a7ab90
[AST DBG] newNode kind=AST_RETURN -> 0x5b2ff9a7abf0
[AST DBG] addChild parent=0x5b2ff9a7abf0(AST_RETURN, lineno=7) child=0x5b2ff9a7ab90(AST_ID, lineno=7)
[LEX][8] ELSE     -> 'else'
[LEX][8] RETURN   -> 'return'
[LEX][8] ID       -> 'gcd'
[LEX][8] LPAREN   -> '('
[LEX][8] ID       -> 'v'
[LEX][8] COMMA    -> ','
[SYM_TABLE DBG] useSymbol: 'v' in scope 'gcd' at line 8
[AST DBG] newNode kind=AST_ID -> 0x5b2ff9a7ac70
[AST DBG] newIdNode("v") -> 0x5b2ff9a7ac70
[AST DBG] newNode kind=AST_ARG_LIST -> 0x5b2ff9a7acd0
[AST DBG] addChild parent=0x5b2ff9a7acd0(AST_ARG_LIST, lineno=8) child=0x5b2ff9a7ac70(AST_ID, lineno=8)
[LEX][8] ID       -> 'u'
[LEX][8] MINUS    -> '-'
[SYM_TABLE DBG] useSymbol: 'u' in scope 'gcd' at line 8
[AST DBG] newNode kind=AST_ID -> 0x5b2ff9a7ad30
[AST DBG] newIdNode("u") -> 0x5b2ff9a7ad30
[AST DBG] newNode kind=AST_BINOP -> 0x5b2ff9a7ad90
[LEX][8] ID       -> 'u'
[LEX][8] DIV      -> '/'
[SYM_TABLE DBG] useSymbol: 'u' in scope 'gcd' at line 8
[AST DBG] newNode kind=AST_ID -> 0x5b2ff9a7ae10
[AST DBG] newIdNode("u") -> 0x5b2ff9a7ae10
[AST DBG] newNode kind=AST_BINOP -> 0x5b2ff9a7ae70
[LEX][8] ID       -> 'v'
[LEX][8] TIMES    -> '*'
[SYM_TABLE DBG] useSymbol: 'v' in scope 'gcd' at line 8
[AST DBG] newNode kind=AST_ID -> 0x5b2ff9a7aef0
[AST DBG] newIdNode("v") -> 0x5b2ff9a7aef0
[AST DBG] newNode kind=AST_BINOP -> 0x5b2ff9a7af50
[AST DBG] addChild parent=0x5b2ff9a7af50(AST_BINOP, lineno=8) child=0x5b2ff9a7ae10(AST_ID, lineno=8)
[AST DBG] addChild parent=0x5b2ff9a7af50(AST_BINOP, lineno=8) child=0x5b2ff9a7ae70(AST_BINOP, lineno=8)
[AST DBG] addChild parent=0x5b2ff9a7af50(AST_BINOP, lineno=8) child=0x5b2ff9a7aef0(AST_ID, lineno=8)
[AST DBG] newNode kind=AST_BINOP -> 0x5b2ff9a7af90
[LEX][8] ID       -> 'v'
[LEX][8] RPAREN   -> ')'
[SYM_TABLE DBG] useSymbol: 'v' in scope 'gcd' at line 8
[AST DBG] newNode kind=AST_ID -> 0x5b2ff9a7b010
[AST DBG] newIdNode("v") -> 0x5b2ff9a7b010
[AST DBG] newNode kind=AST_BINOP -> 0x5b2ff9a7b070
[AST DBG] addChild parent=0x5b2ff9a7b070(AST_BINOP, lineno=8) child=0x5b2ff9a7af50(AST_BINOP, lineno=8)
[AST DBG] addChild parent=0x5b2ff9a7b070(AST_BINOP, lineno=8) child=0x5b2ff9a7af90(AST_BINOP, lineno=8)
[AST DBG] addChild parent=0x5b2ff9a7b070(AST_BINOP, lineno=8) child=0x5b2ff9a7b010(AST_ID, lineno=8)
[AST DBG] newNode kind=AST_BINOP -> 0x5b2ff9a7b0b0
[AST DBG] addChild parent=0x5b2ff9a7b0b0(AST_BINOP, lineno=0) child=0x5b2ff9a7ad30(AST_ID, lineno=8)
[AST DBG] addChild parent=0x5b2ff9a7b0b0(AST_BINOP, lineno=0) child=0x5b2ff9a7ad90(AST_BINOP, lineno=8)
[AST DBG] addChild parent=0x5b2ff9a7b0b0(AST_BINOP, lineno=0) child=0x5b2ff9a7b070(AST_BINOP, lineno=8)
[AST DBG] addChild parent=0x5b2ff9a7acd0(AST_ARG_LIST, lineno=8) child=0x5b2ff9a7b0b0(AST_BINOP, lineno=0)
[SYM_TABLE DBG] useSymbol: 'gcd' in scope 'gcd' at line 8
[AST DBG] newNode kind=AST_CALL -> 0x5b2ff9a7b0f0
[AST DBG] addChild parent=0x5b2ff9a7b0f0(AST_CALL, lineno=8) child=0x5b2ff9a7acd0(AST_ARG_LIST, lineno=8)
[LEX][8] SEMI     -> ';'
[AST DBG] newNode kind=AST_RETURN -> 0x5b2ff9a7b150
[AST DBG] addChild parent=0x5b2ff9a7b150(AST_RETURN, lineno=8) child=0x5b2ff9a7b0f0(AST_CALL, lineno=8)
[AST DBG] newNode kind=AST_IF -> 0x5b2ff9a7b190
[AST DBG] addChild parent=0x5b2ff9a7b190(AST_IF, lineno=0) child=0x5b2ff9a7ab10(AST_BINOP, lineno=7)
[AST DBG] addChild parent=0x5b2ff9a7b190(AST_IF, lineno=0) child=0x5b2ff9a7abf0(AST_RETURN, lineno=7)
[AST DBG] addChild parent=0x5b2ff9a7b190(AST_IF, lineno=0) child=0x5b2ff9a7b150(AST_RETURN, lineno=8)
[LEX][9] SKIP_COMMENT
[LEX][10] RBRACE   -> '}'
[AST DBG] newNode kind=AST_BLOCK -> 0x5b2ff9a7b1d0
[AST DBG] addChild parent=0x5b2ff9a7b1d0(AST_BLOCK, lineno=10) child=0x5b2ff9a7b190(AST_IF, lineno=0)
[PARSER DBG] compound_stmt: decls=(nil) stmts=0x5b2ff9a7b190
[AST DBG] newNode kind=AST_FUN_DECL -> 0x5b2ff9a7b210
[AST DBG] addChild parent=0x5b2ff9a7b210(AST_FUN_DECL, lineno=5) child=0x5b2ff9a7a8c0(AST_PARAM_LIST, lineno=0)
[AST DBG] addChild parent=0x5b2ff9a7b210(AST_FUN_DECL, lineno=5) child=0x5b2ff9a7b1d0(AST_BLOCK, lineno=10)
[SYM_TABLE DBG] setFunctionParams: 'gcd' in scope 'gcd' with 2 params
[PARSER DBG] fun_declaration: name=gcd, params=0x5b2ff9a7a8c0, body=0x5b2ff9a7b1d0
[LEX][12] VOID     -> 'void'
[LEX][12] ID       -> 'main'
[LEX][12] LPAREN   -> '('
[LEX][12] VOID     -> 'void'
[LEX][12] RPAREN   -> ')'
[LEX][13] LBRACE   -> '{'
[LEX][13] INT      -> 'int'
[LEX][13] ID       -> 'x'
[LEX][13] SEMI     -> ';'
[AST DBG] newNode kind=AST_VAR_DECL -> 0x5b2ff9a7b3f0
[PARSER DBG] var_declaration: name=x[LEX][13] INT      -> 'int'
[LEX][13] ID       -> 'y'
[LEX][13] SEMI     -> ';'
[AST DBG] newNode kind=AST_VAR_DECL -> 0x5b2ff9a7b500
[PARSER DBG] var_declaration: name=y[LEX][14] ID       -> 'x'
[LEX][14] ASSIGN   -> '='
[SYM_TABLE DBG] useSymbol: 'x' in scope 'main' at line 14
[AST DBG] newNode kind=AST_ID -> 0x5b2ff9a7b580
[AST DBG] newIdNode("x") -> 0x5b2ff9a7b580
[LEX][14] ID       -> 'input'
[LEX][14] LPAREN   -> '('
[LEX][14] RPAREN   -> ')'
[SYM_TABLE DBG] useSymbol: 'input' in scope 'main' at line 14
[AST DBG] newNode kind=AST_CALL -> 0x5b2ff9a7b600
[LEX][14] SEMI     -> ';'
[AST DBG] newNode kind=AST_ASSIGN -> 0x5b2ff9a7b660
[AST DBG] addChild parent=0x5b2ff9a7b660(AST_ASSIGN, lineno=14) child=0x5b2ff9a7b580(AST_ID, lineno=14)
[AST DBG] addChild parent=0x5b2ff9a7b660(AST_ASSIGN, lineno=14) child=0x5b2ff9a7b600(AST_CALL, lineno=14)
[PARSER DBG] assignment: var=0x5b2ff9a7b580 expr=0x5b2ff9a7b600
[LEX][14] ID       -> 'y'
[LEX][14] ASSIGN   -> '='
[SYM_TABLE DBG] useSymbol: 'y' in scope 'main' at line 14
[AST DBG] newNode kind=AST_ID -> 0x5b2ff9a7b6c0
[AST DBG] newIdNode("y") -> 0x5b2ff9a7b6c0
[LEX][14] ID       -> 'input'
[LEX][14] LPAREN   -> '('
[LEX][14] RPAREN   -> ')'
[SYM_TABLE DBG] useSymbol: 'input' in scope 'main' at line 14
[AST DBG] newNode kind=AST_CALL -> 0x5b2ff9a7b740
[LEX][14] SEMI     -> ';'
[AST DBG] newNode kind=AST_ASSIGN -> 0x5b2ff9a7b7a0
[AST DBG] addChild parent=0x5b2ff9a7b7a0(AST_ASSIGN, lineno=14) child=0x5b2ff9a7b6c0(AST_ID, lineno=14)
[AST DBG] addChild parent=0x5b2ff9a7b7a0(AST_ASSIGN, lineno=14) child=0x5b2ff9a7b740(AST_CALL, lineno=14)
[PARSER DBG] assignment: var=0x5b2ff9a7b6c0 expr=0x5b2ff9a7b740
[LEX][15] ID       -> 'output'
[LEX][15] LPAREN   -> '('
[LEX][15] ID       -> 'gcd'
[LEX][15] LPAREN   -> '('
[LEX][15] ID       -> 'x'
[LEX][15] COMMA    -> ','
[SYM_TABLE DBG] useSymbol: 'x' in scope 'main' at line 15
[AST DBG] newNode kind=AST_ID -> 0x5b2ff9a7b840
[AST DBG] newIdNode("x") -> 0x5b2ff9a7b840
[AST DBG] newNode kind=AST_ARG_LIST -> 0x5b2ff9a7b8a0
[AST DBG] addChild parent=0x5b2ff9a7b8a0(AST_ARG_LIST, lineno=15) child=0x5b2ff9a7b840(AST_ID, lineno=15)
[LEX][15] ID       -> 'y'
[LEX][15] RPAREN   -> ')'
[SYM_TABLE DBG] useSymbol: 'y' in scope 'main' at line 15
[AST DBG] newNode kind=AST_ID -> 0x5b2ff9a7b900
[AST DBG] newIdNode("y") -> 0x5b2ff9a7b900
[AST DBG] addChild parent=0x5b2ff9a7b8a0(AST_ARG_LIST, lineno=15) child=0x5b2ff9a7b900(AST_ID, lineno=15)
[SYM_TABLE DBG] useSymbol: 'gcd' in scope 'main' at line 15
[AST DBG] newNode kind=AST_CALL -> 0x5b2ff9a7b960
[AST DBG] addChild parent=0x5b2ff9a7b960(AST_CALL, lineno=15) child=0x5b2ff9a7b8a0(AST_ARG_LIST, lineno=15)
[LEX][15] RPAREN   -> ')'
[AST DBG] newNode kind=AST_ARG_LIST -> 0x5b2ff9a7b9c0
[AST DBG] addChild parent=0x5b2ff9a7b9c0(AST_ARG_LIST, lineno=15) child=0x5b2ff9a7b960(AST_CALL, lineno=15)
[SYM_TABLE DBG] useSymbol: 'output' in scope 'main' at line 15
[AST DBG] newNode kind=AST_CALL -> 0x5b2ff9a7ba00
[AST DBG] addChild parent=0x5b2ff9a7ba00(AST_CALL, lineno=15) child=0x5b2ff9a7b9c0(AST_ARG_LIST, lineno=15)
[LEX][15] SEMI     -> ';'
[LEX][16] RBRACE   -> '}'
[AST DBG] newNode kind=AST_BLOCK -> 0x5b2ff9a7ba60
[AST DBG] addChild parent=0x5b2ff9a7ba60(AST_BLOCK, lineno=16) child=0x5b2ff9a7b3f0(AST_VAR_DECL, lineno=13)
[AST DBG] addChild parent=0x5b2ff9a7ba60(AST_BLOCK, lineno=16) child=0x5b2ff9a7b660(AST_ASSIGN, lineno=14)
[AST DBG] addChild parent=0x5b2ff9a7ba60(AST_BLOCK, lineno=16) child=0x5b2ff9a7b7a0(AST_ASSIGN, lineno=14)
[AST DBG] addChild parent=0x5b2ff9a7ba60(AST_BLOCK, lineno=16) child=0x5b2ff9a7ba00(AST_CALL, lineno=15)
[PARSER DBG] compound_stmt: decls=0x5b2ff9a7b3f0 stmts=0x5b2ff9a7b660
[AST DBG] newNode kind=AST_FUN_DECL -> 0x5b2ff9a7baa0
[AST DBG] addChild parent=0x5b2ff9a7baa0(AST_FUN_DECL, lineno=12) child=0x5b2ff9a7ba60(AST_BLOCK, lineno=16)
[SYM_TABLE DBG] setFunctionParams: 'main' in scope 'main' with 0 params
[PARSER DBG] fun_declaration: name=main, params=(nil), body=0x5b2ff9a7ba60
[PARSER DBG] declaration_list: added main
[LEX][17] EOF
[AST DBG] newNode kind=AST_PROGRAM -> 0x5b2ff9a7bae0
[AST DBG] addChild parent=0x5b2ff9a7bae0(AST_PROGRAM, lineno=0) child=0x5b2ff9a7b210(AST_FUN_DECL, lineno=5)
[AST DBG] addChild parent=0x5b2ff9a7bae0(AST_PROGRAM, lineno=0) child=0x5b2ff9a7baa0(AST_FUN_DECL, lineno=12)
Parse successful.
======= SYMBOL TABLE =======
Name            Scope      Kind   Decl Lines           Use Lines            Type  
--------------------------------------------------------------------------
y               main       VAR    13 	15,14 	INT   
x               main       VAR    13 	15,14 	INT   
main            global     FUNC   12 	 	VOID  
v               gcd        VAR    5 	8,8,8,7 	INT   
u               gcd        VAR    5 	8,8,7 	INT   
gcd             global     FUNC   5 	15,8 	INT   
output          global     FUNC   0 	15 	VOID  
input           global     FUNC   0 	14,14 	INT   
======= END OF TABLE =======
Symbol table printed successfully.

=== AST ===
Program (lineno=0)
  FunDecl(name=gcd, lineno=5)
    ParamList (lineno=0)
      Param(name=u, lineno=5)
      Param(name=v, lineno=5)
    Block (lineno=10)
      If (lineno=0)
        BinOp (lineno=7)
          Id(name=v, lineno=7)
          BinOp(op='==', lineno=7)
          Num(value=0, lineno=7)
        Return (lineno=7)
          Id(name=u, lineno=7)
        Return (lineno=8)
          Call(name=gcd, lineno=8)
            ArgList (lineno=8)
              Id(name=v, lineno=8)
              BinOp (lineno=0)
                Id(name=u, lineno=8)
                BinOp(op='-', lineno=8)
                BinOp (lineno=8)
                  BinOp (lineno=8)
                    Id(name=u, lineno=8)
                    BinOp(op='/', lineno=8)
                    Id(name=v, lineno=8)
                  BinOp(op='*', lineno=8)
                  Id(name=v, lineno=8)
  FunDecl(name=main, lineno=12)
    Block (lineno=16)
      VarDecl(name=x, lineno=13)
      VarDecl(name=y, lineno=13)
      Assign (lineno=14)
        Id(name=x, lineno=14)
        Call(name=input, lineno=14)
      Assign (lineno=14)
        Id(name=y, lineno=14)
        Call(name=input, lineno=14)
      Call(name=output, lineno=15)
        ArgList (lineno=15)
          Call(name=gcd, lineno=15)
            ArgList (lineno=15)
              Id(name=x, lineno=15)
              Id(name=y, lineno=15)
[Semantic DBG] analyzeProgram: entering program node
[Semantic DBG] declaration: kind=3 name="gcd" at line 5
[Semantic DBG] analyzeDeclaration: kind=3 name="gcd" line=5
[Semantic DBG] FunDecl: name="gcd" line=5
[Semantic DBG]   return-type = int
[Semantic DBG]  switched currentScope = gcd
[Semantic DBG]   Found parameter list
[Semantic DBG]   Param: name="u" line=5
[Semantic DBG]   Param: name="v" line=5
[Semantic DBG] analyzeBlock: scope="gcd"
[Semantic DBG]   Statement: kind=8 line=0
[Semantic DBG] → analyzeStatement(stmt=0x5b2ff9a7b190, kind=8, line=0)
[Semantic DBG] → analyzeExpression(expr=0x5b2ff9a7ab10, kind=12, line=7)
[Semantic DBG] → analyzeExpression(expr=0x5b2ff9a7aa30, kind=14, line=7)
[Semantic DBG] ← analyzeExpression(expr=0x5b2ff9a7aa30) returns 1
[Semantic DBG] → analyzeExpression(expr=0x5b2ff9a7aad0, kind=15, line=7)
[Semantic DBG] ← analyzeExpression(expr=0x5b2ff9a7aad0) returns 1
[Semantic DBG] ← analyzeExpression(expr=0x5b2ff9a7ab10) returns 1
[Semantic DBG] → analyzeStatement(stmt=0x5b2ff9a7abf0, kind=10, line=7)
[Semantic DBG] → analyzeExpression(expr=0x5b2ff9a7ab90, kind=14, line=7)
[Semantic DBG] ← analyzeExpression(expr=0x5b2ff9a7ab90) returns 1
[Semantic DBG] ← analyzeStatement(stmt=0x5b2ff9a7abf0)
[Semantic DBG] → analyzeStatement(stmt=0x5b2ff9a7b150, kind=10, line=8)
[Semantic DBG] → analyzeExpression(expr=0x5b2ff9a7b0f0, kind=13, line=8)
[Semantic DBG] → analyzeExpression(expr=0x5b2ff9a7ac70, kind=14, line=8)
[Semantic DBG] ← analyzeExpression(expr=0x5b2ff9a7ac70) returns 1
[Semantic DBG] → analyzeExpression(expr=0x5b2ff9a7b0b0, kind=12, line=0)
[Semantic DBG] → analyzeExpression(expr=0x5b2ff9a7ad30, kind=14, line=8)
[Semantic DBG] ← analyzeExpression(expr=0x5b2ff9a7ad30) returns 1
[Semantic DBG] → analyzeExpression(expr=0x5b2ff9a7b070, kind=12, line=8)
[Semantic DBG] → analyzeExpression(expr=0x5b2ff9a7af50, kind=12, line=8)
[Semantic DBG] → analyzeExpression(expr=0x5b2ff9a7ae10, kind=14, line=8)
[Semantic DBG] ← analyzeExpression(expr=0x5b2ff9a7ae10) returns 1
[Semantic DBG] → analyzeExpression(expr=0x5b2ff9a7aef0, kind=14, line=8)
[Semantic DBG] ← analyzeExpression(expr=0x5b2ff9a7aef0) returns 1
[Semantic DBG] ← analyzeExpression(expr=0x5b2ff9a7af50) returns 1
[Semantic DBG] → analyzeExpression(expr=0x5b2ff9a7b010, kind=14, line=8)
[Semantic DBG] ← analyzeExpression(expr=0x5b2ff9a7b010) returns 1
[Semantic DBG] ← analyzeExpression(expr=0x5b2ff9a7b070) returns 1
[Semantic DBG] ← analyzeExpression(expr=0x5b2ff9a7b0b0) returns 1
[Semantic DBG] ← analyzeExpression(expr=0x5b2ff9a7b0f0) returns 1
[Semantic DBG] ← analyzeStatement(stmt=0x5b2ff9a7b150)
[Semantic DBG] ← analyzeStatement(stmt=0x5b2ff9a7b190)
[Semantic DBG]   currentScope restored to global
[Semantic DBG] declaration: kind=3 name="main" at line 12
[Semantic DBG] analyzeDeclaration: kind=3 name="main" line=12
[Semantic DBG] FunDecl: name="main" line=12
[Semantic DBG]   return-type = void
[Semantic DBG]  switched currentScope = main
[Semantic DBG]   No parameters, just a block
[Semantic DBG] analyzeBlock: scope="main"
[Semantic DBG] analyzeDeclaration: kind=2 name="x" line=13
[Semantic DBG]   VarDecl: Found simple var 'x'
[Semantic DBG] analyzeDeclaration: kind=2 name="y" line=13
[Semantic DBG]   VarDecl: Found simple var 'y'
[Semantic DBG]   Statement: kind=11 line=14
[Semantic DBG] → analyzeStatement(stmt=0x5b2ff9a7b660, kind=11, line=14)
[Semantic DBG] → analyzeExpression(expr=0x5b2ff9a7b660, kind=11, line=14)
[Semantic DBG] → analyzeExpression(expr=0x5b2ff9a7b600, kind=13, line=14)
[Semantic DBG] ← analyzeExpression(expr=0x5b2ff9a7b600) returns 1
[Semantic DBG] ← analyzeExpression(expr=0x5b2ff9a7b660) returns 1
[Semantic DBG] ← analyzeStatement(stmt=0x5b2ff9a7b660)
[Semantic DBG]   Statement: kind=11 line=14
[Semantic DBG] → analyzeStatement(stmt=0x5b2ff9a7b7a0, kind=11, line=14)
[Semantic DBG] → analyzeExpression(expr=0x5b2ff9a7b7a0, kind=11, line=14)
[Semantic DBG] → analyzeExpression(expr=0x5b2ff9a7b740, kind=13, line=14)
[Semantic DBG] ← analyzeExpression(expr=0x5b2ff9a7b740) returns 1
[Semantic DBG] ← analyzeExpression(expr=0x5b2ff9a7b7a0) returns 1
[Semantic DBG] ← analyzeStatement(stmt=0x5b2ff9a7b7a0)
[Semantic DBG]   Statement: kind=13 line=15
[Semantic DBG] → analyzeStatement(stmt=0x5b2ff9a7ba00, kind=13, line=15)
[Semantic DBG] → analyzeExpression(expr=0x5b2ff9a7ba00, kind=13, line=15)
[Semantic DBG] → analyzeExpression(expr=0x5b2ff9a7b960, kind=13, line=15)
[Semantic DBG] → analyzeExpression(expr=0x5b2ff9a7b840, kind=14, line=15)
[Semantic DBG] ← analyzeExpression(expr=0x5b2ff9a7b840) returns 1
[Semantic DBG] → analyzeExpression(expr=0x5b2ff9a7b900, kind=14, line=15)
[Semantic DBG] ← analyzeExpression(expr=0x5b2ff9a7b900) returns 1
[Semantic DBG] ← analyzeExpression(expr=0x5b2ff9a7b960) returns 1
[Semantic DBG] ← analyzeExpression(expr=0x5b2ff9a7ba00) returns 2
[Semantic DBG] ← analyzeStatement(stmt=0x5b2ff9a7ba00)
[Semantic DBG]   currentScope restored to global
Semantic analysis completed successfully with no errors.

=== IR ===

[IR_DBG] === Starting IR Generation ===
[IR_DBG] Pass 1: Searching for global variable declarations...
[IR_DBG] > generate_ir_for_node: Processing node kind AST_PROGRAM at line 0
[IR_DBG]   Case AST_PROGRAM
[IR_DBG] > generate_ir_for_node: Processing node kind AST_FUN_DECL at line 5
[IR_DBG]   Case AST_FUN_DECL for 'gcd'
[IR_DBG] Creating new name operand: gcd
[IR_DBG] Emitting instruction with opcode 15
[IR_DBG] > generate_ir_for_node: Processing node kind AST_BLOCK at line 10
[IR_DBG]   Case AST_BLOCK
[IR_DBG] > generate_ir_for_node: Processing node kind AST_IF at line 0
[IR_DBG]   Case AST_IF
[IR_DBG] Creating new label: L0
[IR_DBG] Creating new label: L1
[IR_DBG] >> generate_ir_for_expr: Processing expression kind AST_BINOP at line 7
[IR_DBG]    Case AST_BINOP
[IR_DBG]      Operator: '=='
[IR_DBG] >> generate_ir_for_expr: Processing expression kind AST_ID at line 7
[IR_DBG]    Case AST_ID
[IR_DBG] Creating new name operand: v
[IR_DBG] << generate_ir_for_expr: Finished processing expression kind AST_ID
[IR_DBG] >> generate_ir_for_expr: Processing expression kind AST_NUM at line 7
[IR_DBG]    Case AST_NUM
[IR_DBG] Creating new constant: 0
[IR_DBG] << generate_ir_for_expr: Finished processing expression kind AST_NUM
[IR_DBG] Creating new temporary: t0
[IR_DBG] Emitting instruction with opcode 9
[IR_DBG] << generate_ir_for_expr: Finished processing expression kind AST_BINOP
[IR_DBG] Emitting instruction with opcode 17
[IR_DBG] > generate_ir_for_node: Processing node kind AST_RETURN at line 7
[IR_DBG]   Case AST_RETURN
[IR_DBG] >> generate_ir_for_expr: Processing expression kind AST_ID at line 7
[IR_DBG]    Case AST_ID
[IR_DBG] Creating new name operand: u
[IR_DBG] << generate_ir_for_expr: Finished processing expression kind AST_ID
[IR_DBG] Emitting instruction with opcode 18
[IR_DBG] < generate_ir_for_node: Finished processing node kind AST_RETURN
[IR_DBG] Emitting instruction with opcode 16
[IR_DBG] Emitting instruction with opcode 15
[IR_DBG] > generate_ir_for_node: Processing node kind AST_RETURN at line 8
[IR_DBG]   Case AST_RETURN
[IR_DBG] >> generate_ir_for_expr: Processing expression kind AST_CALL at line 8
[IR_DBG]    Case AST_CALL for function 'gcd'
[IR_DBG] >> generate_ir_for_expr: Processing expression kind AST_ID at line 8
[IR_DBG]    Case AST_ID
[IR_DBG] Creating new name operand: v
[IR_DBG] << generate_ir_for_expr: Finished processing expression kind AST_ID
[IR_DBG] Emitting instruction with opcode 19
[IR_DBG] >> generate_ir_for_expr: Processing expression kind AST_BINOP at line 0
[IR_DBG]    Case AST_BINOP
[IR_DBG]      Operator: '-'
[IR_DBG] >> generate_ir_for_expr: Processing expression kind AST_ID at line 8
[IR_DBG]    Case AST_ID
[IR_DBG] Creating new name operand: u
[IR_DBG] << generate_ir_for_expr: Finished processing expression kind AST_ID
[IR_DBG] >> generate_ir_for_expr: Processing expression kind AST_BINOP at line 8
[IR_DBG]    Case AST_BINOP
[IR_DBG]      Operator: '*'
[IR_DBG] >> generate_ir_for_expr: Processing expression kind AST_BINOP at line 8
[IR_DBG]    Case AST_BINOP
[IR_DBG]      Operator: '/'
[IR_DBG] >> generate_ir_for_expr: Processing expression kind AST_ID at line 8
[IR_DBG]    Case AST_ID
[IR_DBG] Creating new name operand: u
[IR_DBG] << generate_ir_for_expr: Finished processing expression kind AST_ID
[IR_DBG] >> generate_ir_for_expr: Processing expression kind AST_ID at line 8
[IR_DBG]    Case AST_ID
[IR_DBG] Creating new name operand: v
[IR_DBG] << generate_ir_for_expr: Finished processing expression kind AST_ID
[IR_DBG] Creating new temporary: t1
[IR_DBG] Emitting instruction with opcode 8
[IR_DBG] << generate_ir_for_expr: Finished processing expression kind AST_BINOP
[IR_DBG] >> generate_ir_for_expr: Processing expression kind AST_ID at line 8
[IR_DBG]    Case AST_ID
[IR_DBG] Creating new name operand: v
[IR_DBG] << generate_ir_for_expr: Finished processing expression kind AST_ID
[IR_DBG] Creating new temporary: t2
[IR_DBG] Emitting instruction with opcode 7
[IR_DBG] << generate_ir_for_expr: Finished processing expression kind AST_BINOP
[IR_DBG] Creating new temporary: t3
[IR_DBG] Emitting instruction with opcode 6
[IR_DBG] << generate_ir_for_expr: Finished processing expression kind AST_BINOP
[IR_DBG] Emitting instruction with opcode 19
[IR_DBG] Creating new temporary: t4
[IR_DBG] Creating new constant: 2
[IR_DBG] Creating new name operand: gcd
[IR_DBG] Emitting instruction with opcode 21
[IR_DBG] << generate_ir_for_expr: Finished processing expression kind AST_CALL
[IR_DBG] Emitting instruction with opcode 18
[IR_DBG] < generate_ir_for_node: Finished processing node kind AST_RETURN
[IR_DBG] Emitting instruction with opcode 15
[IR_DBG] < generate_ir_for_node: Finished processing node kind AST_IF
[IR_DBG] < generate_ir_for_node: Finished processing node kind AST_BLOCK
[IR_DBG] Emitting instruction with opcode 18
[IR_DBG] < generate_ir_for_node: Finished processing node kind AST_FUN_DECL
[IR_DBG] > generate_ir_for_node: Processing node kind AST_FUN_DECL at line 12
[IR_DBG]   Case AST_FUN_DECL for 'main'
[IR_DBG] Creating new name operand: main
[IR_DBG] Emitting instruction with opcode 15
[IR_DBG] > generate_ir_for_node: Processing node kind AST_BLOCK at line 16
[IR_DBG]   Case AST_BLOCK
[IR_DBG] > generate_ir_for_node: Processing node kind AST_ASSIGN at line 14
[IR_DBG]   Case AST_ASSIGN (as statement)
[IR_DBG] >> generate_ir_for_expr: Processing expression kind AST_ASSIGN at line 14
[IR_DBG]    Case AST_ASSIGN
[IR_DBG] >> generate_ir_for_expr: Processing expression kind AST_CALL at line 14
[IR_DBG]    Case AST_CALL for function 'input'
[IR_DBG] Creating new temporary: t5
[IR_DBG] Creating new constant: 0
[IR_DBG] Creating new name operand: input
[IR_DBG] Emitting instruction with opcode 21
[IR_DBG] << generate_ir_for_expr: Finished processing expression kind AST_CALL
[IR_DBG] Creating new name operand: x
[IR_DBG] Emitting instruction with opcode 0
[IR_DBG] << generate_ir_for_expr: Finished processing expression kind AST_ASSIGN
[IR_DBG] < generate_ir_for_node: Finished processing node kind AST_ASSIGN
[IR_DBG] > generate_ir_for_node: Processing node kind AST_ASSIGN at line 14
[IR_DBG]   Case AST_ASSIGN (as statement)
[IR_DBG] >> generate_ir_for_expr: Processing expression kind AST_ASSIGN at line 14
[IR_DBG]    Case AST_ASSIGN
[IR_DBG] >> generate_ir_for_expr: Processing expression kind AST_CALL at line 14
[IR_DBG]    Case AST_CALL for function 'input'
[IR_DBG] Creating new temporary: t6
[IR_DBG] Creating new constant: 0
[IR_DBG] Creating new name operand: input
[IR_DBG] Emitting instruction with opcode 21
[IR_DBG] << generate_ir_for_expr: Finished processing expression kind AST_CALL
[IR_DBG] Creating new name operand: y
[IR_DBG] Emitting instruction with opcode 0
[IR_DBG] << generate_ir_for_expr: Finished processing expression kind AST_ASSIGN
[IR_DBG] < generate_ir_for_node: Finished processing node kind AST_ASSIGN
[IR_DBG] > generate_ir_for_node: Processing node kind AST_CALL at line 15
[IR_DBG]   Case AST_CALL (as statement)
[IR_DBG] >> generate_ir_for_expr: Processing expression kind AST_CALL at line 15
[IR_DBG]    Case AST_CALL for function 'output'
[IR_DBG] >> generate_ir_for_expr: Processing expression kind AST_CALL at line 15
[IR_DBG]    Case AST_CALL for function 'gcd'
[IR_DBG] >> generate_ir_for_expr: Processing expression kind AST_ID at line 15
[IR_DBG]    Case AST_ID
[IR_DBG] Creating new name operand: x
[IR_DBG] << generate_ir_for_expr: Finished processing expression kind AST_ID
[IR_DBG] Emitting instruction with opcode 19
[IR_DBG] >> generate_ir_for_expr: Processing expression kind AST_ID at line 15
[IR_DBG]    Case AST_ID
[IR_DBG] Creating new name operand: y
[IR_DBG] << generate_ir_for_expr: Finished processing expression kind AST_ID
[IR_DBG] Emitting instruction with opcode 19
[IR_DBG] Creating new temporary: t7
[IR_DBG] Creating new constant: 2
[IR_DBG] Creating new name operand: gcd
[IR_DBG] Emitting instruction with opcode 21
[IR_DBG] << generate_ir_for_expr: Finished processing expression kind AST_CALL
[IR_DBG] Emitting instruction with opcode 19
[IR_DBG] Creating new constant: 1
[IR_DBG] Creating new name operand: output
[IR_DBG] Emitting instruction with opcode 20
[IR_DBG] << generate_ir_for_expr: Finished processing expression kind AST_CALL
[IR_DBG] < generate_ir_for_node: Finished processing node kind AST_CALL
[IR_DBG] < generate_ir_for_node: Finished processing node kind AST_BLOCK
[IR_DBG] Emitting instruction with opcode 18
[IR_DBG] < generate_ir_for_node: Finished processing node kind AST_FUN_DECL
[IR_DBG] < generate_ir_for_node: Finished processing node kind AST_PROGRAM
[IR_DBG] === Finished IR Generation ===

--- BEGIN IR DUMP (Terminal) ---
gcd:
  t0 := v == 0
  if_false t0 goto L0
  return u
L0:
  arg v
  t1 := u / v
  t2 := t1 * v
  t3 := u - t2
  arg t3
  t4 := call gcd, 2
  return t4
L1:
  return _
main:
  t5 := call input, 0
  x := t5
  t6 := call input, 0
  y := t6
  arg x
  arg y
  t7 := call gcd, 2
  arg t7
  call output, 1
  return _
--- END IR DUMP ---
IR dump has been saved to: docs/output/generated_IR.txt
