Initializing symbol table and scope stack...
[SYM_TABLE DBG] setFunctionParams: 'input' in scope 'global' with 0 params
[SYM_TABLE DBG] setFunctionParams: 'output' in scope 'global' with 1 params
Symbol table initialized successfully.
Parsing 'docs/test_files/teste4.txt'...
[LEX][1] INT      -> 'int'
[LEX][1] ID       -> 'vec'
[LEX][1] LBRACK   -> '['
[LEX][1] NUM      -> '3' (3)
[LEX][1] RBRACK   -> ']'
[LEX][1] SEMI     -> ';'
[AST DBG] newNode kind=AST_VAR_DECL -> 0x5ed45f01f790
[PARSER DBG] var_declaration (vector): name=vec, size=0x3[LEX][3] VOID     -> 'void'
[LEX][3] ID       -> 'main'
[LEX][3] LPAREN   -> '('
[LEX][3] VOID     -> 'void'
[LEX][3] RPAREN   -> ')'
[LEX][3] LBRACE   -> '{'
[LEX][5] INT      -> 'int'
[LEX][5] ID       -> 'i'
[LEX][5] SEMI     -> ';'
[AST DBG] newNode kind=AST_VAR_DECL -> 0x5ed45f01f990
[PARSER DBG] var_declaration: name=i[LEX][5] INT      -> 'int'
[LEX][5] ID       -> 'gap'
[LEX][5] SEMI     -> ';'
[AST DBG] newNode kind=AST_VAR_DECL -> 0x5ed45f01faa0
[PARSER DBG] var_declaration: name=gap[LEX][7] ID       -> 'i'
[LEX][7] ASSIGN   -> '='
[SYM_TABLE DBG] useSymbol: 'i' in scope 'main' at line 7
[AST DBG] newNode kind=AST_ID -> 0x5ed45f01fb20
[AST DBG] newIdNode("i") -> 0x5ed45f01fb20
[LEX][7] NUM      -> '0' (0)
[AST DBG] newNode kind=AST_NUM -> 0x5ed45f01fb80
[AST DBG] newNumNode(0) -> 0x5ed45f01fb80
[LEX][7] SEMI     -> ';'
[AST DBG] newNode kind=AST_ASSIGN -> 0x5ed45f01fbc0
[AST DBG] addChild parent=0x5ed45f01fbc0(AST_ASSIGN, lineno=7) child=0x5ed45f01fb20(AST_ID, lineno=7)
[AST DBG] addChild parent=0x5ed45f01fbc0(AST_ASSIGN, lineno=7) child=0x5ed45f01fb80(AST_NUM, lineno=7)
[PARSER DBG] assignment: var=0x5ed45f01fb20 expr=0x5ed45f01fb80
[LEX][8] ID       -> 'gap'
[LEX][8] ASSIGN   -> '='
[SYM_TABLE DBG] useSymbol: 'gap' in scope 'main' at line 8
[AST DBG] newNode kind=AST_ID -> 0x5ed45f01fc20
[AST DBG] newIdNode("gap") -> 0x5ed45f01fc20
[LEX][8] ID       -> 'input'
[LEX][8] LPAREN   -> '('
[LEX][8] RPAREN   -> ')'
[SYM_TABLE DBG] useSymbol: 'input' in scope 'main' at line 8
[AST DBG] newNode kind=AST_CALL -> 0x5ed45f01fca0
[LEX][8] SEMI     -> ';'
[AST DBG] newNode kind=AST_ASSIGN -> 0x5ed45f01fd00
[AST DBG] addChild parent=0x5ed45f01fd00(AST_ASSIGN, lineno=8) child=0x5ed45f01fc20(AST_ID, lineno=8)
[AST DBG] addChild parent=0x5ed45f01fd00(AST_ASSIGN, lineno=8) child=0x5ed45f01fca0(AST_CALL, lineno=8)
[PARSER DBG] assignment: var=0x5ed45f01fc20 expr=0x5ed45f01fca0
[LEX][10] ID       -> 'vec'
[LEX][10] LBRACK   -> '['
[LEX][10] ID       -> 'i'
[LEX][10] RBRACK   -> ']'
[SYM_TABLE DBG] useSymbol: 'i' in scope 'main' at line 10
[AST DBG] newNode kind=AST_ID -> 0x5ed45f01fd80
[AST DBG] newIdNode("i") -> 0x5ed45f01fd80
[AST DBG] newNode kind=AST_ARRAY_ACCESS -> 0x5ed45f01fde0
[AST DBG] addChild parent=0x5ed45f01fde0(AST_ARRAY_ACCESS, lineno=10) child=0x5ed45f01fd80(AST_ID, lineno=10)
[SYM_TABLE DBG] useSymbol: 'vec' in scope 'main' at line 10
[LEX][10] ASSIGN   -> '='
[LEX][10] ID       -> 'gap'
[LEX][10] SEMI     -> ';'
[SYM_TABLE DBG] useSymbol: 'gap' in scope 'main' at line 10
[AST DBG] newNode kind=AST_ID -> 0x5ed45f01fe60
[AST DBG] newIdNode("gap") -> 0x5ed45f01fe60
[AST DBG] newNode kind=AST_ASSIGN -> 0x5ed45f01fec0
[AST DBG] addChild parent=0x5ed45f01fec0(AST_ASSIGN, lineno=10) child=0x5ed45f01fde0(AST_ARRAY_ACCESS, lineno=10)
[AST DBG] addChild parent=0x5ed45f01fec0(AST_ASSIGN, lineno=10) child=0x5ed45f01fe60(AST_ID, lineno=10)
[PARSER DBG] assignment: var=0x5ed45f01fde0 expr=0x5ed45f01fe60
[LEX][11] ID       -> 'output'
[LEX][11] LPAREN   -> '('
[LEX][11] ID       -> 'vec'
[LEX][11] LBRACK   -> '['
[LEX][11] ID       -> 'i'
[LEX][11] RBRACK   -> ']'
[SYM_TABLE DBG] useSymbol: 'i' in scope 'main' at line 11
[AST DBG] newNode kind=AST_ID -> 0x5ed45f01ff60
[AST DBG] newIdNode("i") -> 0x5ed45f01ff60
[AST DBG] newNode kind=AST_ARRAY_ACCESS -> 0x5ed45f01ffc0
[AST DBG] addChild parent=0x5ed45f01ffc0(AST_ARRAY_ACCESS, lineno=11) child=0x5ed45f01ff60(AST_ID, lineno=11)
[SYM_TABLE DBG] useSymbol: 'vec' in scope 'main' at line 11
[LEX][11] RPAREN   -> ')'
[AST DBG] newNode kind=AST_ARG_LIST -> 0x5ed45f020020
[AST DBG] addChild parent=0x5ed45f020020(AST_ARG_LIST, lineno=11) child=0x5ed45f01ffc0(AST_ARRAY_ACCESS, lineno=11)
[SYM_TABLE DBG] useSymbol: 'output' in scope 'main' at line 11
[AST DBG] newNode kind=AST_CALL -> 0x5ed45f020060
[AST DBG] addChild parent=0x5ed45f020060(AST_CALL, lineno=11) child=0x5ed45f020020(AST_ARG_LIST, lineno=11)
[LEX][11] SEMI     -> ';'
[LEX][12] ID       -> 'i'
[LEX][12] ASSIGN   -> '='
[SYM_TABLE DBG] useSymbol: 'i' in scope 'main' at line 12
[AST DBG] newNode kind=AST_ID -> 0x5ed45f0200e0
[AST DBG] newIdNode("i") -> 0x5ed45f0200e0
[LEX][12] ID       -> 'i'
[LEX][12] PLUS     -> '+'
[SYM_TABLE DBG] useSymbol: 'i' in scope 'main' at line 12
[AST DBG] newNode kind=AST_ID -> 0x5ed45f020160
[AST DBG] newIdNode("i") -> 0x5ed45f020160
[AST DBG] newNode kind=AST_BINOP -> 0x5ed45f0201c0
[LEX][12] NUM      -> '1' (1)
[AST DBG] newNode kind=AST_NUM -> 0x5ed45f020200
[AST DBG] newNumNode(1) -> 0x5ed45f020200
[LEX][12] SEMI     -> ';'
[AST DBG] newNode kind=AST_BINOP -> 0x5ed45f020240
[AST DBG] addChild parent=0x5ed45f020240(AST_BINOP, lineno=0) child=0x5ed45f020160(AST_ID, lineno=12)
[AST DBG] addChild parent=0x5ed45f020240(AST_BINOP, lineno=0) child=0x5ed45f0201c0(AST_BINOP, lineno=12)
[AST DBG] addChild parent=0x5ed45f020240(AST_BINOP, lineno=0) child=0x5ed45f020200(AST_NUM, lineno=12)
[AST DBG] newNode kind=AST_ASSIGN -> 0x5ed45f020280
[AST DBG] addChild parent=0x5ed45f020280(AST_ASSIGN, lineno=12) child=0x5ed45f0200e0(AST_ID, lineno=12)
[AST DBG] addChild parent=0x5ed45f020280(AST_ASSIGN, lineno=12) child=0x5ed45f020240(AST_BINOP, lineno=0)
[PARSER DBG] assignment: var=0x5ed45f0200e0 expr=0x5ed45f020240
[LEX][13] ID       -> 'vec'
[LEX][13] LBRACK   -> '['
[LEX][13] ID       -> 'i'
[LEX][13] RBRACK   -> ']'
[SYM_TABLE DBG] useSymbol: 'i' in scope 'main' at line 13
[AST DBG] newNode kind=AST_ID -> 0x5ed45f020320
[AST DBG] newIdNode("i") -> 0x5ed45f020320
[AST DBG] newNode kind=AST_ARRAY_ACCESS -> 0x5ed45f020380
[AST DBG] addChild parent=0x5ed45f020380(AST_ARRAY_ACCESS, lineno=13) child=0x5ed45f020320(AST_ID, lineno=13)
[SYM_TABLE DBG] useSymbol: 'vec' in scope 'main' at line 13
[LEX][13] ASSIGN   -> '='
[LEX][13] ID       -> 'vec'
[LEX][13] LBRACK   -> '['
[LEX][13] ID       -> 'i'
[LEX][13] MINUS    -> '-'
[SYM_TABLE DBG] useSymbol: 'i' in scope 'main' at line 13
[AST DBG] newNode kind=AST_ID -> 0x5ed45f020420
[AST DBG] newIdNode("i") -> 0x5ed45f020420
[AST DBG] newNode kind=AST_BINOP -> 0x5ed45f020480
[LEX][13] NUM      -> '1' (1)
[AST DBG] newNode kind=AST_NUM -> 0x5ed45f0204c0
[AST DBG] newNumNode(1) -> 0x5ed45f0204c0
[LEX][13] RBRACK   -> ']'
[AST DBG] newNode kind=AST_BINOP -> 0x5ed45f020500
[AST DBG] addChild parent=0x5ed45f020500(AST_BINOP, lineno=0) child=0x5ed45f020420(AST_ID, lineno=13)
[AST DBG] addChild parent=0x5ed45f020500(AST_BINOP, lineno=0) child=0x5ed45f020480(AST_BINOP, lineno=13)
[AST DBG] addChild parent=0x5ed45f020500(AST_BINOP, lineno=0) child=0x5ed45f0204c0(AST_NUM, lineno=13)
[AST DBG] newNode kind=AST_ARRAY_ACCESS -> 0x5ed45f020540
[AST DBG] addChild parent=0x5ed45f020540(AST_ARRAY_ACCESS, lineno=13) child=0x5ed45f020500(AST_BINOP, lineno=0)
[SYM_TABLE DBG] useSymbol: 'vec' in scope 'main' at line 13
[LEX][13] PLUS     -> '+'
[AST DBG] newNode kind=AST_BINOP -> 0x5ed45f0205c0
[LEX][13] ID       -> 'gap'
[LEX][13] SEMI     -> ';'
[SYM_TABLE DBG] useSymbol: 'gap' in scope 'main' at line 13
[AST DBG] newNode kind=AST_ID -> 0x5ed45f020640
[AST DBG] newIdNode("gap") -> 0x5ed45f020640
[AST DBG] newNode kind=AST_BINOP -> 0x5ed45f0206a0
[AST DBG] addChild parent=0x5ed45f0206a0(AST_BINOP, lineno=0) child=0x5ed45f020540(AST_ARRAY_ACCESS, lineno=13)
[AST DBG] addChild parent=0x5ed45f0206a0(AST_BINOP, lineno=0) child=0x5ed45f0205c0(AST_BINOP, lineno=13)
[AST DBG] addChild parent=0x5ed45f0206a0(AST_BINOP, lineno=0) child=0x5ed45f020640(AST_ID, lineno=13)
[AST DBG] newNode kind=AST_ASSIGN -> 0x5ed45f0206e0
[AST DBG] addChild parent=0x5ed45f0206e0(AST_ASSIGN, lineno=13) child=0x5ed45f020380(AST_ARRAY_ACCESS, lineno=13)
[AST DBG] addChild parent=0x5ed45f0206e0(AST_ASSIGN, lineno=13) child=0x5ed45f0206a0(AST_BINOP, lineno=0)
[PARSER DBG] assignment: var=0x5ed45f020380 expr=0x5ed45f0206a0
[LEX][14] ID       -> 'output'
[LEX][14] LPAREN   -> '('
[LEX][14] ID       -> 'vec'
[LEX][14] LBRACK   -> '['
[LEX][14] ID       -> 'i'
[LEX][14] RBRACK   -> ']'
[SYM_TABLE DBG] useSymbol: 'i' in scope 'main' at line 14
[AST DBG] newNode kind=AST_ID -> 0x5ed45f020780
[AST DBG] newIdNode("i") -> 0x5ed45f020780
[AST DBG] newNode kind=AST_ARRAY_ACCESS -> 0x5ed45f0207e0
[AST DBG] addChild parent=0x5ed45f0207e0(AST_ARRAY_ACCESS, lineno=14) child=0x5ed45f020780(AST_ID, lineno=14)
[SYM_TABLE DBG] useSymbol: 'vec' in scope 'main' at line 14
[LEX][14] RPAREN   -> ')'
[AST DBG] newNode kind=AST_ARG_LIST -> 0x5ed45f020840
[AST DBG] addChild parent=0x5ed45f020840(AST_ARG_LIST, lineno=14) child=0x5ed45f0207e0(AST_ARRAY_ACCESS, lineno=14)
[SYM_TABLE DBG] useSymbol: 'output' in scope 'main' at line 14
[AST DBG] newNode kind=AST_CALL -> 0x5ed45f020880
[AST DBG] addChild parent=0x5ed45f020880(AST_CALL, lineno=14) child=0x5ed45f020840(AST_ARG_LIST, lineno=14)
[LEX][14] SEMI     -> ';'
[LEX][15] ID       -> 'i'
[LEX][15] ASSIGN   -> '='
[SYM_TABLE DBG] useSymbol: 'i' in scope 'main' at line 15
[AST DBG] newNode kind=AST_ID -> 0x5ed45f020900
[AST DBG] newIdNode("i") -> 0x5ed45f020900
[LEX][15] ID       -> 'i'
[LEX][15] PLUS     -> '+'
[SYM_TABLE DBG] useSymbol: 'i' in scope 'main' at line 15
[AST DBG] newNode kind=AST_ID -> 0x5ed45f020980
[AST DBG] newIdNode("i") -> 0x5ed45f020980
[AST DBG] newNode kind=AST_BINOP -> 0x5ed45f0209e0
[LEX][15] ID       -> 'gap'
[LEX][15] SEMI     -> ';'
[SYM_TABLE DBG] useSymbol: 'gap' in scope 'main' at line 15
[AST DBG] newNode kind=AST_ID -> 0x5ed45f020a60
[AST DBG] newIdNode("gap") -> 0x5ed45f020a60
[AST DBG] newNode kind=AST_BINOP -> 0x5ed45f020ac0
[AST DBG] addChild parent=0x5ed45f020ac0(AST_BINOP, lineno=0) child=0x5ed45f020980(AST_ID, lineno=15)
[AST DBG] addChild parent=0x5ed45f020ac0(AST_BINOP, lineno=0) child=0x5ed45f0209e0(AST_BINOP, lineno=15)
[AST DBG] addChild parent=0x5ed45f020ac0(AST_BINOP, lineno=0) child=0x5ed45f020a60(AST_ID, lineno=15)
[AST DBG] newNode kind=AST_ASSIGN -> 0x5ed45f020b00
[AST DBG] addChild parent=0x5ed45f020b00(AST_ASSIGN, lineno=15) child=0x5ed45f020900(AST_ID, lineno=15)
[AST DBG] addChild parent=0x5ed45f020b00(AST_ASSIGN, lineno=15) child=0x5ed45f020ac0(AST_BINOP, lineno=0)
[PARSER DBG] assignment: var=0x5ed45f020900 expr=0x5ed45f020ac0
[LEX][16] ID       -> 'vec'
[LEX][16] LBRACK   -> '['
[LEX][16] ID       -> 'i'
[LEX][16] RBRACK   -> ']'
[SYM_TABLE DBG] useSymbol: 'i' in scope 'main' at line 16
[AST DBG] newNode kind=AST_ID -> 0x5ed45f020b80
[AST DBG] newIdNode("i") -> 0x5ed45f020b80
[AST DBG] newNode kind=AST_ARRAY_ACCESS -> 0x5ed45f020be0
[AST DBG] addChild parent=0x5ed45f020be0(AST_ARRAY_ACCESS, lineno=16) child=0x5ed45f020b80(AST_ID, lineno=16)
[SYM_TABLE DBG] useSymbol: 'vec' in scope 'main' at line 16
[LEX][16] ASSIGN   -> '='
[LEX][16] ID       -> 'vec'
[LEX][16] LBRACK   -> '['
[LEX][16] ID       -> 'i'
[LEX][16] MINUS    -> '-'
[SYM_TABLE DBG] useSymbol: 'i' in scope 'main' at line 16
[AST DBG] newNode kind=AST_ID -> 0x5ed45f020c80
[AST DBG] newIdNode("i") -> 0x5ed45f020c80
[AST DBG] newNode kind=AST_BINOP -> 0x5ed45f020ce0
[LEX][16] NUM      -> '1' (1)
[AST DBG] newNode kind=AST_NUM -> 0x5ed45f020d20
[AST DBG] newNumNode(1) -> 0x5ed45f020d20
[LEX][16] RBRACK   -> ']'
[AST DBG] newNode kind=AST_BINOP -> 0x5ed45f020d60
[AST DBG] addChild parent=0x5ed45f020d60(AST_BINOP, lineno=0) child=0x5ed45f020c80(AST_ID, lineno=16)
[AST DBG] addChild parent=0x5ed45f020d60(AST_BINOP, lineno=0) child=0x5ed45f020ce0(AST_BINOP, lineno=16)
[AST DBG] addChild parent=0x5ed45f020d60(AST_BINOP, lineno=0) child=0x5ed45f020d20(AST_NUM, lineno=16)
[AST DBG] newNode kind=AST_ARRAY_ACCESS -> 0x5ed45f020da0
[AST DBG] addChild parent=0x5ed45f020da0(AST_ARRAY_ACCESS, lineno=16) child=0x5ed45f020d60(AST_BINOP, lineno=0)
[SYM_TABLE DBG] useSymbol: 'vec' in scope 'main' at line 16
[LEX][16] PLUS     -> '+'
[AST DBG] newNode kind=AST_BINOP -> 0x5ed45f020e20
[LEX][16] ID       -> 'gap'
[LEX][16] SEMI     -> ';'
[SYM_TABLE DBG] useSymbol: 'gap' in scope 'main' at line 16
[AST DBG] newNode kind=AST_ID -> 0x5ed45f020ea0
[AST DBG] newIdNode("gap") -> 0x5ed45f020ea0
[AST DBG] newNode kind=AST_BINOP -> 0x5ed45f020f00
[AST DBG] addChild parent=0x5ed45f020f00(AST_BINOP, lineno=0) child=0x5ed45f020da0(AST_ARRAY_ACCESS, lineno=16)
[AST DBG] addChild parent=0x5ed45f020f00(AST_BINOP, lineno=0) child=0x5ed45f020e20(AST_BINOP, lineno=16)
[AST DBG] addChild parent=0x5ed45f020f00(AST_BINOP, lineno=0) child=0x5ed45f020ea0(AST_ID, lineno=16)
[AST DBG] newNode kind=AST_ASSIGN -> 0x5ed45f020f40
[AST DBG] addChild parent=0x5ed45f020f40(AST_ASSIGN, lineno=16) child=0x5ed45f020be0(AST_ARRAY_ACCESS, lineno=16)
[AST DBG] addChild parent=0x5ed45f020f40(AST_ASSIGN, lineno=16) child=0x5ed45f020f00(AST_BINOP, lineno=0)
[PARSER DBG] assignment: var=0x5ed45f020be0 expr=0x5ed45f020f00
[LEX][17] ID       -> 'output'
[LEX][17] LPAREN   -> '('
[LEX][17] ID       -> 'vec'
[LEX][17] LBRACK   -> '['
[LEX][17] ID       -> 'i'
[LEX][17] RBRACK   -> ']'
[SYM_TABLE DBG] useSymbol: 'i' in scope 'main' at line 17
[AST DBG] newNode kind=AST_ID -> 0x5ed45f020fe0
[AST DBG] newIdNode("i") -> 0x5ed45f020fe0
[AST DBG] newNode kind=AST_ARRAY_ACCESS -> 0x5ed45f021040
[AST DBG] addChild parent=0x5ed45f021040(AST_ARRAY_ACCESS, lineno=17) child=0x5ed45f020fe0(AST_ID, lineno=17)
[SYM_TABLE DBG] useSymbol: 'vec' in scope 'main' at line 17
[LEX][17] RPAREN   -> ')'
[AST DBG] newNode kind=AST_ARG_LIST -> 0x5ed45f0210a0
[AST DBG] addChild parent=0x5ed45f0210a0(AST_ARG_LIST, lineno=17) child=0x5ed45f021040(AST_ARRAY_ACCESS, lineno=17)
[SYM_TABLE DBG] useSymbol: 'output' in scope 'main' at line 17
[AST DBG] newNode kind=AST_CALL -> 0x5ed45f0210e0
[AST DBG] addChild parent=0x5ed45f0210e0(AST_CALL, lineno=17) child=0x5ed45f0210a0(AST_ARG_LIST, lineno=17)
[LEX][17] SEMI     -> ';'
[LEX][18] RBRACE   -> '}'
[AST DBG] newNode kind=AST_BLOCK -> 0x5ed45f021140
[AST DBG] addChild parent=0x5ed45f021140(AST_BLOCK, lineno=18) child=0x5ed45f01f990(AST_VAR_DECL, lineno=5)
[AST DBG] addChild parent=0x5ed45f021140(AST_BLOCK, lineno=18) child=0x5ed45f01fbc0(AST_ASSIGN, lineno=7)
[AST DBG] addChild parent=0x5ed45f021140(AST_BLOCK, lineno=18) child=0x5ed45f01fd00(AST_ASSIGN, lineno=8)
[AST DBG] addChild parent=0x5ed45f021140(AST_BLOCK, lineno=18) child=0x5ed45f01fec0(AST_ASSIGN, lineno=10)
[AST DBG] addChild parent=0x5ed45f021140(AST_BLOCK, lineno=18) child=0x5ed45f020060(AST_CALL, lineno=11)
[AST DBG] addChild parent=0x5ed45f021140(AST_BLOCK, lineno=18) child=0x5ed45f020280(AST_ASSIGN, lineno=12)
[AST DBG] addChild parent=0x5ed45f021140(AST_BLOCK, lineno=18) child=0x5ed45f0206e0(AST_ASSIGN, lineno=13)
[AST DBG] addChild parent=0x5ed45f021140(AST_BLOCK, lineno=18) child=0x5ed45f020880(AST_CALL, lineno=14)
[AST DBG] addChild parent=0x5ed45f021140(AST_BLOCK, lineno=18) child=0x5ed45f020b00(AST_ASSIGN, lineno=15)
[AST DBG] addChild parent=0x5ed45f021140(AST_BLOCK, lineno=18) child=0x5ed45f020f40(AST_ASSIGN, lineno=16)
[AST DBG] addChild parent=0x5ed45f021140(AST_BLOCK, lineno=18) child=0x5ed45f0210e0(AST_CALL, lineno=17)
[PARSER DBG] compound_stmt: decls=0x5ed45f01f990 stmts=0x5ed45f01fbc0
[AST DBG] newNode kind=AST_FUN_DECL -> 0x5ed45f021180
[AST DBG] addChild parent=0x5ed45f021180(AST_FUN_DECL, lineno=3) child=0x5ed45f021140(AST_BLOCK, lineno=18)
[SYM_TABLE DBG] setFunctionParams: 'main' in scope 'main' with 0 params
[PARSER DBG] fun_declaration: name=¿D²Ñ^, params=(nil), body=0x5ed45f021140
[PARSER DBG] declaration_list: added main
[LEX][18] EOF
[AST DBG] newNode kind=AST_PROGRAM -> 0x5ed45f0211e0
[AST DBG] addChild parent=0x5ed45f0211e0(AST_PROGRAM, lineno=0) child=0x5ed45f01f790(AST_VAR_DECL, lineno=1)
[AST DBG] addChild parent=0x5ed45f0211e0(AST_PROGRAM, lineno=0) child=0x5ed45f021180(AST_FUN_DECL, lineno=3)
Parse successful.
======= SYMBOL TABLE =======
Name            Scope      Kind   Decl Lines           Use Lines            Type  
--------------------------------------------------------------------------
gap             main       VAR    5 	16,15,13,10,8 	INT   
i               main       VAR    5 	17,16,16,15,15,14,13,13,12,12,11,10,7 	INT   
main            global     FUNC   3 	 	VOID  
vec             global     VAR    1 	17,16,16,14,13,13,11,10 	ARRAY(3, INT)
output          global     FUNC   0 	17,14,11 	VOID  
input           global     FUNC   0 	8 	INT   
======= END OF TABLE =======
Symbol table printed successfully.

=== AST ===
Program (lineno=0)
  VarDecl(name=vec, lineno=1)
  FunDecl(name=main, lineno=3)
    Block (lineno=18)
      VarDecl(name=i, lineno=5)
      VarDecl(name=gap, lineno=5)
      Assign (lineno=7)
        Id(name=i, lineno=7)
        Num(value=0, lineno=7)
      Assign (lineno=8)
        Id(name=gap, lineno=8)
        Call(name=input, lineno=8)
      Assign (lineno=10)
        ArrayAccess(name=vec, lineno=10)
          Id(name=i, lineno=10)
        Id(name=gap, lineno=10)
      Call(name=output, lineno=11)
        ArgList (lineno=11)
          ArrayAccess(name=vec, lineno=11)
            Id(name=i, lineno=11)
      Assign (lineno=12)
        Id(name=i, lineno=12)
        BinOp (lineno=0)
          Id(name=i, lineno=12)
          BinOp(op='+', lineno=12)
          Num(value=1, lineno=12)
      Assign (lineno=13)
        ArrayAccess(name=vec, lineno=13)
          Id(name=i, lineno=13)
        BinOp (lineno=0)
          ArrayAccess(name=vec, lineno=13)
            BinOp (lineno=0)
              Id(name=i, lineno=13)
              BinOp(op='-', lineno=13)
              Num(value=1, lineno=13)
          BinOp(op='+', lineno=13)
          Id(name=gap, lineno=13)
      Call(name=output, lineno=14)
        ArgList (lineno=14)
          ArrayAccess(name=vec, lineno=14)
            Id(name=i, lineno=14)
      Assign (lineno=15)
        Id(name=i, lineno=15)
        BinOp (lineno=0)
          Id(name=i, lineno=15)
          BinOp(op='+', lineno=15)
          Id(name=gap, lineno=15)
      Assign (lineno=16)
        ArrayAccess(name=vec, lineno=16)
          Id(name=i, lineno=16)
        BinOp (lineno=0)
          ArrayAccess(name=vec, lineno=16)
            BinOp (lineno=0)
              Id(name=i, lineno=16)
              BinOp(op='-', lineno=16)
              Num(value=1, lineno=16)
          BinOp(op='+', lineno=16)
          Id(name=gap, lineno=16)
      Call(name=output, lineno=17)
        ArgList (lineno=17)
          ArrayAccess(name=vec, lineno=17)
            Id(name=i, lineno=17)
[Semantic DBG] analyzeProgram: entering program node
[Semantic DBG] declaration: kind=2 name="vec" at line 1
[Semantic DBG] analyzeDeclaration: kind=2 name="vec" line=1
[Semantic DBG]   VarDecl: Found array 'vec' of size 3
[Semantic DBG] declaration: kind=3 name="main" at line 3
[Semantic DBG] analyzeDeclaration: kind=3 name="main" line=3
[Semantic DBG] FunDecl: name="main" line=3
[Semantic DBG]   return-type = void
[Semantic DBG]  switched currentScope = main
[Semantic DBG]   No parameters, just a block
[Semantic DBG] analyzeBlock: scope="main"
[Semantic DBG] analyzeDeclaration: kind=2 name="i" line=5
[Semantic DBG]   VarDecl: Found simple var 'i'
[Semantic DBG] analyzeDeclaration: kind=2 name="gap" line=5
[Semantic DBG]   VarDecl: Found simple var 'gap'
[Semantic DBG]   Statement: kind=11 line=7
[Semantic DBG] â†’ analyzeStatement(stmt=0x5ed45f01fbc0, kind=11, line=7)
[Semantic DBG] â†’ analyzeExpression(expr=0x5ed45f01fbc0, kind=11, line=7)
[Semantic DBG] â†’ analyzeExpression(expr=0x5ed45f01fb80, kind=15, line=7)
[Semantic DBG] â† analyzeExpression(expr=0x5ed45f01fb80) returns 1
[Semantic DBG] â† analyzeExpression(expr=0x5ed45f01fbc0) returns 1
[Semantic DBG] â† analyzeStatement(stmt=0x5ed45f01fbc0)
[Semantic DBG]   Statement: kind=11 line=8
[Semantic DBG] â†’ analyzeStatement(stmt=0x5ed45f01fd00, kind=11, line=8)
[Semantic DBG] â†’ analyzeExpression(expr=0x5ed45f01fd00, kind=11, line=8)
[Semantic DBG] â†’ analyzeExpression(expr=0x5ed45f01fca0, kind=13, line=8)
[Semantic DBG] â† analyzeExpression(expr=0x5ed45f01fca0) returns 1
[Semantic DBG] â† analyzeExpression(expr=0x5ed45f01fd00) returns 1
[Semantic DBG] â† analyzeStatement(stmt=0x5ed45f01fd00)
[Semantic DBG]   Statement: kind=11 line=10
[Semantic DBG] â†’ analyzeStatement(stmt=0x5ed45f01fec0, kind=11, line=10)
[Semantic DBG] â†’ analyzeExpression(expr=0x5ed45f01fec0, kind=11, line=10)
[Semantic DBG] â†’ analyzeExpression(expr=0x5ed45f01fe60, kind=14, line=10)
[Semantic DBG] â† analyzeExpression(expr=0x5ed45f01fe60) returns 1
[Semantic DBG] â† analyzeExpression(expr=0x5ed45f01fec0) returns 1
[Semantic DBG] â† analyzeStatement(stmt=0x5ed45f01fec0)
[Semantic DBG]   Statement: kind=13 line=11
[Semantic DBG] â†’ analyzeStatement(stmt=0x5ed45f020060, kind=13, line=11)
[Semantic DBG] â†’ analyzeExpression(expr=0x5ed45f020060, kind=13, line=11)
[Semantic DBG] â†’ analyzeExpression(expr=0x5ed45f01ffc0, kind=16, line=11)
[Semantic DBG]   Case AST_ARRAY_ACCESS for 'vec' at line 11
[Semantic DBG]   Analyzing index expression for 'vec'
[Semantic DBG] â†’ analyzeExpression(expr=0x5ed45f01ff60, kind=14, line=11)
[Semantic DBG] â† analyzeExpression(expr=0x5ed45f01ff60) returns 1
[Semantic DBG]   Array access is valid, returning TYPE_INT.
[Semantic DBG] â† analyzeExpression(expr=0x5ed45f01ffc0) returns 1
[Semantic DBG] â† analyzeExpression(expr=0x5ed45f020060) returns 2
[Semantic DBG] â† analyzeStatement(stmt=0x5ed45f020060)
[Semantic DBG]   Statement: kind=11 line=12
[Semantic DBG] â†’ analyzeStatement(stmt=0x5ed45f020280, kind=11, line=12)
[Semantic DBG] â†’ analyzeExpression(expr=0x5ed45f020280, kind=11, line=12)
[Semantic DBG] â†’ analyzeExpression(expr=0x5ed45f020240, kind=12, line=0)
[Semantic DBG] â†’ analyzeExpression(expr=0x5ed45f020160, kind=14, line=12)
[Semantic DBG] â† analyzeExpression(expr=0x5ed45f020160) returns 1
[Semantic DBG] â†’ analyzeExpression(expr=0x5ed45f020200, kind=15, line=12)
[Semantic DBG] â† analyzeExpression(expr=0x5ed45f020200) returns 1
[Semantic DBG] â† analyzeExpression(expr=0x5ed45f020240) returns 1
[Semantic DBG] â† analyzeExpression(expr=0x5ed45f020280) returns 1
[Semantic DBG] â† analyzeStatement(stmt=0x5ed45f020280)
[Semantic DBG]   Statement: kind=11 line=13
[Semantic DBG] â†’ analyzeStatement(stmt=0x5ed45f0206e0, kind=11, line=13)
[Semantic DBG] â†’ analyzeExpression(expr=0x5ed45f0206e0, kind=11, line=13)
[Semantic DBG] â†’ analyzeExpression(expr=0x5ed45f0206a0, kind=12, line=0)
[Semantic DBG] â†’ analyzeExpression(expr=0x5ed45f020540, kind=16, line=13)
[Semantic DBG]   Case AST_ARRAY_ACCESS for 'vec' at line 13
[Semantic DBG]   Analyzing index expression for 'vec'
[Semantic DBG] â†’ analyzeExpression(expr=0x5ed45f020500, kind=12, line=0)
[Semantic DBG] â†’ analyzeExpression(expr=0x5ed45f020420, kind=14, line=13)
[Semantic DBG] â† analyzeExpression(expr=0x5ed45f020420) returns 1
[Semantic DBG] â†’ analyzeExpression(expr=0x5ed45f0204c0, kind=15, line=13)
[Semantic DBG] â† analyzeExpression(expr=0x5ed45f0204c0) returns 1
[Semantic DBG] â† analyzeExpression(expr=0x5ed45f020500) returns 1
[Semantic DBG]   Array access is valid, returning TYPE_INT.
[Semantic DBG] â† analyzeExpression(expr=0x5ed45f020540) returns 1
[Semantic DBG] â†’ analyzeExpression(expr=0x5ed45f020640, kind=14, line=13)
[Semantic DBG] â† analyzeExpression(expr=0x5ed45f020640) returns 1
[Semantic DBG] â† analyzeExpression(expr=0x5ed45f0206a0) returns 1
[Semantic DBG] â† analyzeExpression(expr=0x5ed45f0206e0) returns 1
[Semantic DBG] â† analyzeStatement(stmt=0x5ed45f0206e0)
[Semantic DBG]   Statement: kind=13 line=14
[Semantic DBG] â†’ analyzeStatement(stmt=0x5ed45f020880, kind=13, line=14)
[Semantic DBG] â†’ analyzeExpression(expr=0x5ed45f020880, kind=13, line=14)
[Semantic DBG] â†’ analyzeExpression(expr=0x5ed45f0207e0, kind=16, line=14)
[Semantic DBG]   Case AST_ARRAY_ACCESS for 'vec' at line 14
[Semantic DBG]   Analyzing index expression for 'vec'
[Semantic DBG] â†’ analyzeExpression(expr=0x5ed45f020780, kind=14, line=14)
[Semantic DBG] â† analyzeExpression(expr=0x5ed45f020780) returns 1
[Semantic DBG]   Array access is valid, returning TYPE_INT.
[Semantic DBG] â† analyzeExpression(expr=0x5ed45f0207e0) returns 1
[Semantic DBG] â† analyzeExpression(expr=0x5ed45f020880) returns 2
[Semantic DBG] â† analyzeStatement(stmt=0x5ed45f020880)
[Semantic DBG]   Statement: kind=11 line=15
[Semantic DBG] â†’ analyzeStatement(stmt=0x5ed45f020b00, kind=11, line=15)
[Semantic DBG] â†’ analyzeExpression(expr=0x5ed45f020b00, kind=11, line=15)
[Semantic DBG] â†’ analyzeExpression(expr=0x5ed45f020ac0, kind=12, line=0)
[Semantic DBG] â†’ analyzeExpression(expr=0x5ed45f020980, kind=14, line=15)
[Semantic DBG] â† analyzeExpression(expr=0x5ed45f020980) returns 1
[Semantic DBG] â†’ analyzeExpression(expr=0x5ed45f020a60, kind=14, line=15)
[Semantic DBG] â† analyzeExpression(expr=0x5ed45f020a60) returns 1
[Semantic DBG] â† analyzeExpression(expr=0x5ed45f020ac0) returns 1
[Semantic DBG] â† analyzeExpression(expr=0x5ed45f020b00) returns 1
[Semantic DBG] â† analyzeStatement(stmt=0x5ed45f020b00)
[Semantic DBG]   Statement: kind=11 line=16
[Semantic DBG] â†’ analyzeStatement(stmt=0x5ed45f020f40, kind=11, line=16)
[Semantic DBG] â†’ analyzeExpression(expr=0x5ed45f020f40, kind=11, line=16)
[Semantic DBG] â†’ analyzeExpression(expr=0x5ed45f020f00, kind=12, line=0)
[Semantic DBG] â†’ analyzeExpression(expr=0x5ed45f020da0, kind=16, line=16)
[Semantic DBG]   Case AST_ARRAY_ACCESS for 'vec' at line 16
[Semantic DBG]   Analyzing index expression for 'vec'
[Semantic DBG] â†’ analyzeExpression(expr=0x5ed45f020d60, kind=12, line=0)
[Semantic DBG] â†’ analyzeExpression(expr=0x5ed45f020c80, kind=14, line=16)
[Semantic DBG] â† analyzeExpression(expr=0x5ed45f020c80) returns 1
[Semantic DBG] â†’ analyzeExpression(expr=0x5ed45f020d20, kind=15, line=16)
[Semantic DBG] â† analyzeExpression(expr=0x5ed45f020d20) returns 1
[Semantic DBG] â† analyzeExpression(expr=0x5ed45f020d60) returns 1
[Semantic DBG]   Array access is valid, returning TYPE_INT.
[Semantic DBG] â† analyzeExpression(expr=0x5ed45f020da0) returns 1
[Semantic DBG] â†’ analyzeExpression(expr=0x5ed45f020ea0, kind=14, line=16)
[Semantic DBG] â† analyzeExpression(expr=0x5ed45f020ea0) returns 1
[Semantic DBG] â† analyzeExpression(expr=0x5ed45f020f00) returns 1
[Semantic DBG] â† analyzeExpression(expr=0x5ed45f020f40) returns 1
[Semantic DBG] â† analyzeStatement(stmt=0x5ed45f020f40)
[Semantic DBG]   Statement: kind=13 line=17
[Semantic DBG] â†’ analyzeStatement(stmt=0x5ed45f0210e0, kind=13, line=17)
[Semantic DBG] â†’ analyzeExpression(expr=0x5ed45f0210e0, kind=13, line=17)
[Semantic DBG] â†’ analyzeExpression(expr=0x5ed45f021040, kind=16, line=17)
[Semantic DBG]   Case AST_ARRAY_ACCESS for 'vec' at line 17
[Semantic DBG]   Analyzing index expression for 'vec'
[Semantic DBG] â†’ analyzeExpression(expr=0x5ed45f020fe0, kind=14, line=17)
[Semantic DBG] â† analyzeExpression(expr=0x5ed45f020fe0) returns 1
[Semantic DBG]   Array access is valid, returning TYPE_INT.
[Semantic DBG] â† analyzeExpression(expr=0x5ed45f021040) returns 1
[Semantic DBG] â† analyzeExpression(expr=0x5ed45f0210e0) returns 2
[Semantic DBG] â† analyzeStatement(stmt=0x5ed45f0210e0)
[Semantic DBG]   currentScope restored to global
Semantic analysis completed successfully with no errors.

=== IR ===

[IR_DBG] === Starting IR Generation ===
[IR_DBG] Pass 1: Searching for global variable declarations...
[IR_DBG]   Found global var declaration for 'vec'
[IR_DBG] Creating new constant: 3
[IR_DBG] Creating new name operand: .space
[IR_DBG] Creating new name operand: vec
[IR_DBG] Emitting instruction with opcode 4
[IR_DBG] > generate_ir_for_node: Processing node kind AST_PROGRAM at line 0
[IR_DBG]   Case AST_PROGRAM
[IR_DBG] > generate_ir_for_node: Processing node kind AST_FUN_DECL at line 3
[IR_DBG]   Case AST_FUN_DECL for 'main'
[IR_DBG] Creating new name operand: main
[IR_DBG] Emitting instruction with opcode 15
[IR_DBG] > generate_ir_for_node: Processing node kind AST_BLOCK at line 18
[IR_DBG]   Case AST_BLOCK
[IR_DBG] > generate_ir_for_node: Processing node kind AST_ASSIGN at line 7
[IR_DBG]   Case AST_ASSIGN (as statement)
[IR_DBG] >> generate_ir_for_expr: Processing expression kind AST_ASSIGN at line 7
[IR_DBG]    Case AST_ASSIGN
[IR_DBG] >> generate_ir_for_expr: Processing expression kind AST_NUM at line 7
[IR_DBG]    Case AST_NUM
[IR_DBG] Creating new constant: 0
[IR_DBG] << generate_ir_for_expr: Finished processing expression kind AST_NUM
[IR_DBG] Creating new name operand: i
[IR_DBG] Emitting instruction with opcode 2
[IR_DBG] << generate_ir_for_expr: Finished processing expression kind AST_ASSIGN
[IR_DBG] < generate_ir_for_node: Finished processing node kind AST_ASSIGN
[IR_DBG] > generate_ir_for_node: Processing node kind AST_ASSIGN at line 8
[IR_DBG]   Case AST_ASSIGN (as statement)
[IR_DBG] >> generate_ir_for_expr: Processing expression kind AST_ASSIGN at line 8
[IR_DBG]    Case AST_ASSIGN
[IR_DBG] >> generate_ir_for_expr: Processing expression kind AST_CALL at line 8
[IR_DBG]    Case AST_CALL for function 'input'
[IR_DBG] Creating new temporary: t0
[IR_DBG] Creating new constant: 0
[IR_DBG] Creating new name operand: input
[IR_DBG] Emitting instruction with opcode 21
[IR_DBG] << generate_ir_for_expr: Finished processing expression kind AST_CALL
[IR_DBG] Creating new name operand: gap
[IR_DBG] Emitting instruction with opcode 2
[IR_DBG] << generate_ir_for_expr: Finished processing expression kind AST_ASSIGN
[IR_DBG] < generate_ir_for_node: Finished processing node kind AST_ASSIGN
[IR_DBG] > generate_ir_for_node: Processing node kind AST_ASSIGN at line 10
[IR_DBG]   Case AST_ASSIGN (as statement)
[IR_DBG] >> generate_ir_for_expr: Processing expression kind AST_ASSIGN at line 10
[IR_DBG]    Case AST_ASSIGN
[IR_DBG] >> generate_ir_for_expr: Processing expression kind AST_ID at line 10
[IR_DBG]    Case AST_ID
[IR_DBG] Creating new temporary: t1
[IR_DBG] Creating new name operand: gap
[IR_DBG] Emitting instruction with opcode 1
[IR_DBG] << generate_ir_for_expr: Finished processing expression kind AST_ID
[IR_DBG]      Assigning to Array Access
[IR_DBG] >> generate_ir_for_expr: Processing expression kind AST_ID at line 10
[IR_DBG]    Case AST_ID
[IR_DBG] Creating new temporary: t2
[IR_DBG] Creating new name operand: i
[IR_DBG] Emitting instruction with opcode 1
[IR_DBG] << generate_ir_for_expr: Finished processing expression kind AST_ID
[IR_DBG] Creating new temporary: t3
[IR_DBG] Creating new name operand: vec
[IR_DBG] Emitting instruction with opcode 3
[IR_DBG] Creating new temporary: t4
[IR_DBG] Emitting instruction with opcode 5
[IR_DBG] Emitting instruction with opcode 2
[IR_DBG] << generate_ir_for_expr: Finished processing expression kind AST_ASSIGN
[IR_DBG] < generate_ir_for_node: Finished processing node kind AST_ASSIGN
[IR_DBG] > generate_ir_for_node: Processing node kind AST_CALL at line 11
[IR_DBG]   Case AST_CALL (as statement)
[IR_DBG] >> generate_ir_for_expr: Processing expression kind AST_CALL at line 11
[IR_DBG]    Case AST_CALL for function 'output'
[IR_DBG] >> generate_ir_for_expr: Processing expression kind UNKNOWN at line 11
[IR_DBG]    Case AST_ARRAY_ACCESS (Load)
[IR_DBG] >> generate_ir_for_expr: Processing expression kind AST_ID at line 11
[IR_DBG]    Case AST_ID
[IR_DBG] Creating new temporary: t5
[IR_DBG] Creating new name operand: i
[IR_DBG] Emitting instruction with opcode 1
[IR_DBG] << generate_ir_for_expr: Finished processing expression kind AST_ID
[IR_DBG] Creating new temporary: t6
[IR_DBG] Creating new name operand: vec
[IR_DBG] Emitting instruction with opcode 3
[IR_DBG] Creating new temporary: t7
[IR_DBG] Emitting instruction with opcode 5
[IR_DBG] Creating new temporary: t8
[IR_DBG] Emitting instruction with opcode 1
[IR_DBG] << generate_ir_for_expr: Finished processing expression kind UNKNOWN
[IR_DBG] Emitting instruction with opcode 19
[IR_DBG] Creating new constant: 1
[IR_DBG] Creating new name operand: output
[IR_DBG] Emitting instruction with opcode 20
[IR_DBG] << generate_ir_for_expr: Finished processing expression kind AST_CALL
[IR_DBG] < generate_ir_for_node: Finished processing node kind AST_CALL
[IR_DBG] > generate_ir_for_node: Processing node kind AST_ASSIGN at line 12
[IR_DBG]   Case AST_ASSIGN (as statement)
[IR_DBG] >> generate_ir_for_expr: Processing expression kind AST_ASSIGN at line 12
[IR_DBG]    Case AST_ASSIGN
[IR_DBG] >> generate_ir_for_expr: Processing expression kind AST_BINOP at line 0
[IR_DBG]    Case AST_BINOP
[IR_DBG]      Operator: '+'
[IR_DBG] >> generate_ir_for_expr: Processing expression kind AST_ID at line 12
[IR_DBG]    Case AST_ID
[IR_DBG] Creating new temporary: t9
[IR_DBG] Creating new name operand: i
[IR_DBG] Emitting instruction with opcode 1
[IR_DBG] << generate_ir_for_expr: Finished processing expression kind AST_ID
[IR_DBG] >> generate_ir_for_expr: Processing expression kind AST_NUM at line 12
[IR_DBG]    Case AST_NUM
[IR_DBG] Creating new constant: 1
[IR_DBG] << generate_ir_for_expr: Finished processing expression kind AST_NUM
[IR_DBG] Creating new temporary: t10
[IR_DBG] Emitting instruction with opcode 5
[IR_DBG] << generate_ir_for_expr: Finished processing expression kind AST_BINOP
[IR_DBG] Creating new name operand: i
[IR_DBG] Emitting instruction with opcode 2
[IR_DBG] << generate_ir_for_expr: Finished processing expression kind AST_ASSIGN
[IR_DBG] < generate_ir_for_node: Finished processing node kind AST_ASSIGN
[IR_DBG] > generate_ir_for_node: Processing node kind AST_ASSIGN at line 13
[IR_DBG]   Case AST_ASSIGN (as statement)
[IR_DBG] >> generate_ir_for_expr: Processing expression kind AST_ASSIGN at line 13
[IR_DBG]    Case AST_ASSIGN
[IR_DBG] >> generate_ir_for_expr: Processing expression kind AST_BINOP at line 0
[IR_DBG]    Case AST_BINOP
[IR_DBG]      Operator: '+'
[IR_DBG] >> generate_ir_for_expr: Processing expression kind UNKNOWN at line 13
[IR_DBG]    Case AST_ARRAY_ACCESS (Load)
[IR_DBG] >> generate_ir_for_expr: Processing expression kind AST_BINOP at line 0
[IR_DBG]    Case AST_BINOP
[IR_DBG]      Operator: '-'
[IR_DBG] >> generate_ir_for_expr: Processing expression kind AST_ID at line 13
[IR_DBG]    Case AST_ID
[IR_DBG] Creating new temporary: t11
[IR_DBG] Creating new name operand: i
[IR_DBG] Emitting instruction with opcode 1
[IR_DBG] << generate_ir_for_expr: Finished processing expression kind AST_ID
[IR_DBG] >> generate_ir_for_expr: Processing expression kind AST_NUM at line 13
[IR_DBG]    Case AST_NUM
[IR_DBG] Creating new constant: 1
[IR_DBG] << generate_ir_for_expr: Finished processing expression kind AST_NUM
[IR_DBG] Creating new temporary: t12
[IR_DBG] Emitting instruction with opcode 6
[IR_DBG] << generate_ir_for_expr: Finished processing expression kind AST_BINOP
[IR_DBG] Creating new temporary: t13
[IR_DBG] Creating new name operand: vec
[IR_DBG] Emitting instruction with opcode 3
[IR_DBG] Creating new temporary: t14
[IR_DBG] Emitting instruction with opcode 5
[IR_DBG] Creating new temporary: t15
[IR_DBG] Emitting instruction with opcode 1
[IR_DBG] << generate_ir_for_expr: Finished processing expression kind UNKNOWN
[IR_DBG] >> generate_ir_for_expr: Processing expression kind AST_ID at line 13
[IR_DBG]    Case AST_ID
[IR_DBG] Creating new temporary: t16
[IR_DBG] Creating new name operand: gap
[IR_DBG] Emitting instruction with opcode 1
[IR_DBG] << generate_ir_for_expr: Finished processing expression kind AST_ID
[IR_DBG] Creating new temporary: t17
[IR_DBG] Emitting instruction with opcode 5
[IR_DBG] << generate_ir_for_expr: Finished processing expression kind AST_BINOP
[IR_DBG]      Assigning to Array Access
[IR_DBG] >> generate_ir_for_expr: Processing expression kind AST_ID at line 13
[IR_DBG]    Case AST_ID
[IR_DBG] Creating new temporary: t18
[IR_DBG] Creating new name operand: i
[IR_DBG] Emitting instruction with opcode 1
[IR_DBG] << generate_ir_for_expr: Finished processing expression kind AST_ID
[IR_DBG] Creating new temporary: t19
[IR_DBG] Creating new name operand: vec
[IR_DBG] Emitting instruction with opcode 3
[IR_DBG] Creating new temporary: t20
[IR_DBG] Emitting instruction with opcode 5
[IR_DBG] Emitting instruction with opcode 2
[IR_DBG] << generate_ir_for_expr: Finished processing expression kind AST_ASSIGN
[IR_DBG] < generate_ir_for_node: Finished processing node kind AST_ASSIGN
[IR_DBG] > generate_ir_for_node: Processing node kind AST_CALL at line 14
[IR_DBG]   Case AST_CALL (as statement)
[IR_DBG] >> generate_ir_for_expr: Processing expression kind AST_CALL at line 14
[IR_DBG]    Case AST_CALL for function 'output'
[IR_DBG] >> generate_ir_for_expr: Processing expression kind UNKNOWN at line 14
[IR_DBG]    Case AST_ARRAY_ACCESS (Load)
[IR_DBG] >> generate_ir_for_expr: Processing expression kind AST_ID at line 14
[IR_DBG]    Case AST_ID
[IR_DBG] Creating new temporary: t21
[IR_DBG] Creating new name operand: i
[IR_DBG] Emitting instruction with opcode 1
[IR_DBG] << generate_ir_for_expr: Finished processing expression kind AST_ID
[IR_DBG] Creating new temporary: t22
[IR_DBG] Creating new name operand: vec
[IR_DBG] Emitting instruction with opcode 3
[IR_DBG] Creating new temporary: t23
[IR_DBG] Emitting instruction with opcode 5
[IR_DBG] Creating new temporary: t24
[IR_DBG] Emitting instruction with opcode 1
[IR_DBG] << generate_ir_for_expr: Finished processing expression kind UNKNOWN
[IR_DBG] Emitting instruction with opcode 19
[IR_DBG] Creating new constant: 1
[IR_DBG] Creating new name operand: output
[IR_DBG] Emitting instruction with opcode 20
[IR_DBG] << generate_ir_for_expr: Finished processing expression kind AST_CALL
[IR_DBG] < generate_ir_for_node: Finished processing node kind AST_CALL
[IR_DBG] > generate_ir_for_node: Processing node kind AST_ASSIGN at line 15
[IR_DBG]   Case AST_ASSIGN (as statement)
[IR_DBG] >> generate_ir_for_expr: Processing expression kind AST_ASSIGN at line 15
[IR_DBG]    Case AST_ASSIGN
[IR_DBG] >> generate_ir_for_expr: Processing expression kind AST_BINOP at line 0
[IR_DBG]    Case AST_BINOP
[IR_DBG]      Operator: '+'
[IR_DBG] >> generate_ir_for_expr: Processing expression kind AST_ID at line 15
[IR_DBG]    Case AST_ID
[IR_DBG] Creating new temporary: t25
[IR_DBG] Creating new name operand: i
[IR_DBG] Emitting instruction with opcode 1
[IR_DBG] << generate_ir_for_expr: Finished processing expression kind AST_ID
[IR_DBG] >> generate_ir_for_expr: Processing expression kind AST_ID at line 15
[IR_DBG]    Case AST_ID
[IR_DBG] Creating new temporary: t26
[IR_DBG] Creating new name operand: gap
[IR_DBG] Emitting instruction with opcode 1
[IR_DBG] << generate_ir_for_expr: Finished processing expression kind AST_ID
[IR_DBG] Creating new temporary: t27
[IR_DBG] Emitting instruction with opcode 5
[IR_DBG] << generate_ir_for_expr: Finished processing expression kind AST_BINOP
[IR_DBG] Creating new name operand: i
[IR_DBG] Emitting instruction with opcode 2
[IR_DBG] << generate_ir_for_expr: Finished processing expression kind AST_ASSIGN
[IR_DBG] < generate_ir_for_node: Finished processing node kind AST_ASSIGN
[IR_DBG] > generate_ir_for_node: Processing node kind AST_ASSIGN at line 16
[IR_DBG]   Case AST_ASSIGN (as statement)
[IR_DBG] >> generate_ir_for_expr: Processing expression kind AST_ASSIGN at line 16
[IR_DBG]    Case AST_ASSIGN
[IR_DBG] >> generate_ir_for_expr: Processing expression kind AST_BINOP at line 0
[IR_DBG]    Case AST_BINOP
[IR_DBG]      Operator: '+'
[IR_DBG] >> generate_ir_for_expr: Processing expression kind UNKNOWN at line 16
[IR_DBG]    Case AST_ARRAY_ACCESS (Load)
[IR_DBG] >> generate_ir_for_expr: Processing expression kind AST_BINOP at line 0
[IR_DBG]    Case AST_BINOP
[IR_DBG]      Operator: '-'
[IR_DBG] >> generate_ir_for_expr: Processing expression kind AST_ID at line 16
[IR_DBG]    Case AST_ID
[IR_DBG] Creating new temporary: t28
[IR_DBG] Creating new name operand: i
[IR_DBG] Emitting instruction with opcode 1
[IR_DBG] << generate_ir_for_expr: Finished processing expression kind AST_ID
[IR_DBG] >> generate_ir_for_expr: Processing expression kind AST_NUM at line 16
[IR_DBG]    Case AST_NUM
[IR_DBG] Creating new constant: 1
[IR_DBG] << generate_ir_for_expr: Finished processing expression kind AST_NUM
[IR_DBG] Creating new temporary: t29
[IR_DBG] Emitting instruction with opcode 6
[IR_DBG] << generate_ir_for_expr: Finished processing expression kind AST_BINOP
[IR_DBG] Creating new temporary: t30
[IR_DBG] Creating new name operand: vec
[IR_DBG] Emitting instruction with opcode 3
[IR_DBG] Creating new temporary: t31
[IR_DBG] Emitting instruction with opcode 5
[IR_DBG] Creating new temporary: t32
[IR_DBG] Emitting instruction with opcode 1
[IR_DBG] << generate_ir_for_expr: Finished processing expression kind UNKNOWN
[IR_DBG] >> generate_ir_for_expr: Processing expression kind AST_ID at line 16
[IR_DBG]    Case AST_ID
[IR_DBG] Creating new temporary: t33
[IR_DBG] Creating new name operand: gap
[IR_DBG] Emitting instruction with opcode 1
[IR_DBG] << generate_ir_for_expr: Finished processing expression kind AST_ID
[IR_DBG] Creating new temporary: t34
[IR_DBG] Emitting instruction with opcode 5
[IR_DBG] << generate_ir_for_expr: Finished processing expression kind AST_BINOP
[IR_DBG]      Assigning to Array Access
[IR_DBG] >> generate_ir_for_expr: Processing expression kind AST_ID at line 16
[IR_DBG]    Case AST_ID
[IR_DBG] Creating new temporary: t35
[IR_DBG] Creating new name operand: i
[IR_DBG] Emitting instruction with opcode 1
[IR_DBG] << generate_ir_for_expr: Finished processing expression kind AST_ID
[IR_DBG] Creating new temporary: t36
[IR_DBG] Creating new name operand: vec
[IR_DBG] Emitting instruction with opcode 3
[IR_DBG] Creating new temporary: t37
[IR_DBG] Emitting instruction with opcode 5
[IR_DBG] Emitting instruction with opcode 2
[IR_DBG] << generate_ir_for_expr: Finished processing expression kind AST_ASSIGN
[IR_DBG] < generate_ir_for_node: Finished processing node kind AST_ASSIGN
[IR_DBG] > generate_ir_for_node: Processing node kind AST_CALL at line 17
[IR_DBG]   Case AST_CALL (as statement)
[IR_DBG] >> generate_ir_for_expr: Processing expression kind AST_CALL at line 17
[IR_DBG]    Case AST_CALL for function 'output'
[IR_DBG] >> generate_ir_for_expr: Processing expression kind UNKNOWN at line 17
[IR_DBG]    Case AST_ARRAY_ACCESS (Load)
[IR_DBG] >> generate_ir_for_expr: Processing expression kind AST_ID at line 17
[IR_DBG]    Case AST_ID
[IR_DBG] Creating new temporary: t38
[IR_DBG] Creating new name operand: i
[IR_DBG] Emitting instruction with opcode 1
[IR_DBG] << generate_ir_for_expr: Finished processing expression kind AST_ID
[IR_DBG] Creating new temporary: t39
[IR_DBG] Creating new name operand: vec
[IR_DBG] Emitting instruction with opcode 3
[IR_DBG] Creating new temporary: t40
[IR_DBG] Emitting instruction with opcode 5
[IR_DBG] Creating new temporary: t41
[IR_DBG] Emitting instruction with opcode 1
[IR_DBG] << generate_ir_for_expr: Finished processing expression kind UNKNOWN
[IR_DBG] Emitting instruction with opcode 19
[IR_DBG] Creating new constant: 1
[IR_DBG] Creating new name operand: output
[IR_DBG] Emitting instruction with opcode 20
[IR_DBG] << generate_ir_for_expr: Finished processing expression kind AST_CALL
[IR_DBG] < generate_ir_for_node: Finished processing node kind AST_CALL
[IR_DBG] < generate_ir_for_node: Finished processing node kind AST_BLOCK
[IR_DBG] Emitting instruction with opcode 18
[IR_DBG] < generate_ir_for_node: Finished processing node kind AST_FUN_DECL
[IR_DBG] < generate_ir_for_node: Finished processing node kind AST_PROGRAM
[IR_DBG] === Finished IR Generation ===

--- BEGIN IR DUMP (Terminal) ---
  vec := .space ? 3
main:
  *i := 0
  t0 := call input, 0
  *gap := t0
  t1 := *gap
  t2 := *i
  t3 := &vec
  t4 := t3 + t2
  *t4 := t1
  t5 := *i
  t6 := &vec
  t7 := t6 + t5
  t8 := *t7
  arg t8
  call output, 1
  t9 := *i
  t10 := t9 + 1
  *i := t10
  t11 := *i
  t12 := t11 - 1
  t13 := &vec
  t14 := t13 + t12
  t15 := *t14
  t16 := *gap
  t17 := t15 + t16
  t18 := *i
  t19 := &vec
  t20 := t19 + t18
  *t20 := t17
  t21 := *i
  t22 := &vec
  t23 := t22 + t21
  t24 := *t23
  arg t24
  call output, 1
  t25 := *i
  t26 := *gap
  t27 := t25 + t26
  *i := t27
  t28 := *i
  t29 := t28 - 1
  t30 := &vec
  t31 := t30 + t29
  t32 := *t31
  t33 := *gap
  t34 := t32 + t33
  t35 := *i
  t36 := &vec
  t37 := t36 + t35
  *t37 := t34
  t38 := *i
  t39 := &vec
  t40 := t39 + t38
  t41 := *t40
  arg t41
  call output, 1
  return _
--- END IR DUMP ---
IR dump has been saved to: docs/output/generated_IR.txt
